package genesis

import (
	"context"
	"errors"
	"math/rand"
	"sort"
	"strings"
	"sync"
	"time")

var ErrNotFound = errors.New("given element is not found")


var ErrNegativeValue = errors.New("negative value passed")


var ErrNonPositiveValue = errors.New("value must be positive")


var ErrOutOfRange = errors.New("index is bigger than container size")


var ErrEmpty = errors.New("container is empty")


// Channel is a set of operations with channel
type ChannelBool struct {
	Data chan bool
}

// AsyncSlice is a set of operations to work with slice asynchronously
type AsyncSliceBool struct {
	Data    []bool
	Workers int
}

// Sequence is a set of operations to generate sequences
type SequenceBool struct {
	ctx context.Context
}

// Pair is a set of functions for 2 values that you can pass into reduce-like funcs
type PairBool struct {
	// empty
}

// Slice is a set of operations to work with slice
type SliceBool struct {
	Data []bool
}

// Slices is a set of operations to work with slice of slices
type SlicesBool struct {
	Data [][]bool
}

// Any returns true if f returns true for any element in channel
func (c ChannelBool) Any(f func(el bool) bool) bool {
	for el := range c.Data {
		if f(el) {
			return true
		}
	}
	return false
}

// All returns true if f returns true for all elements in channel
func (c ChannelBool) All(f func(el bool) bool) bool {
	for el := range c.Data {
		if !f(el) {
			return false
		}
	}
	return true
}

// ChunkEvery returns channel with slices containing count elements each
func (c ChannelBool) ChunkEvery(count int) chan []bool {
	chunks := make(chan []bool, 1)
	go func() {
		chunk := make([]bool, 0, count)
		i := 0
		for el := range c.Data {
			chunk = append(chunk, el)
			i++
			if i%count == 0 {
				i = 0
				chunks <- chunk
				chunk = make([]bool, 0, count)
			}
		}
		if len(chunk) > 0 {
			chunks <- chunk
		}
		close(chunks)
	}()
	return chunks
}

// Count return count of el occurences in channel.
func (c ChannelBool) Count(el bool) int {
	count := 0
	for val := range c.Data {
		if val == el {
			count++
		}
	}
	return count
}

// Drop drops first n elements from channel c and returns a new channel with the rest.
// It returns channel do be unblocking. If you want array instead, wrap result into TakeAll.
func (c ChannelBool) Drop(n int) chan bool {
	result := make(chan bool, 1)
	go func() {
		i := 0
		for el := range c.Data {
			if i >= n {
				result <- el
			}
			i++
		}
		close(result)
	}()
	return result
}

// Each calls f for every element in the channel
func (c ChannelBool) Each(f func(el bool)) {
	for el := range c.Data {
		f(el)
	}
}

// Filter returns a new channel with elements from input channel
// for which f returns true
func (c ChannelBool) Filter(f func(el bool) bool) chan bool {
	result := make(chan bool, 1)
	go func() {
		for el := range c.Data {
			if f(el) {
				result <- el
			}
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelBool) MapBool(f func(el bool) bool) chan bool {
	result := make(chan bool, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelBool) MapByte(f func(el bool) byte) chan byte {
	result := make(chan byte, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelBool) MapString(f func(el bool) string) chan string {
	result := make(chan string, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelBool) MapFloat32(f func(el bool) float32) chan float32 {
	result := make(chan float32, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelBool) MapFloat64(f func(el bool) float64) chan float64 {
	result := make(chan float64, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelBool) MapInt(f func(el bool) int) chan int {
	result := make(chan int, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelBool) MapInt8(f func(el bool) int8) chan int8 {
	result := make(chan int8, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelBool) MapInt16(f func(el bool) int16) chan int16 {
	result := make(chan int16, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelBool) MapInt32(f func(el bool) int32) chan int32 {
	result := make(chan int32, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelBool) MapInt64(f func(el bool) int64) chan int64 {
	result := make(chan int64, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelBool) MapUint(f func(el bool) uint) chan uint {
	result := make(chan uint, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelBool) MapUint8(f func(el bool) uint8) chan uint8 {
	result := make(chan uint8, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelBool) MapUint16(f func(el bool) uint16) chan uint16 {
	result := make(chan uint16, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelBool) MapUint32(f func(el bool) uint32) chan uint32 {
	result := make(chan uint32, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelBool) MapUint64(f func(el bool) uint64) chan uint64 {
	result := make(chan uint64, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelBool) MapInterface(f func(el bool) interface{}) chan interface{} {
	result := make(chan interface{}, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelBool) ReduceBool(acc bool, f func(el bool, acc bool) bool) bool {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelBool) ReduceByte(acc byte, f func(el bool, acc byte) byte) byte {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelBool) ReduceString(acc string, f func(el bool, acc string) string) string {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelBool) ReduceFloat32(acc float32, f func(el bool, acc float32) float32) float32 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelBool) ReduceFloat64(acc float64, f func(el bool, acc float64) float64) float64 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelBool) ReduceInt(acc int, f func(el bool, acc int) int) int {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelBool) ReduceInt8(acc int8, f func(el bool, acc int8) int8) int8 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelBool) ReduceInt16(acc int16, f func(el bool, acc int16) int16) int16 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelBool) ReduceInt32(acc int32, f func(el bool, acc int32) int32) int32 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelBool) ReduceInt64(acc int64, f func(el bool, acc int64) int64) int64 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelBool) ReduceUint(acc uint, f func(el bool, acc uint) uint) uint {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelBool) ReduceUint8(acc uint8, f func(el bool, acc uint8) uint8) uint8 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelBool) ReduceUint16(acc uint16, f func(el bool, acc uint16) uint16) uint16 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelBool) ReduceUint32(acc uint32, f func(el bool, acc uint32) uint32) uint32 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelBool) ReduceUint64(acc uint64, f func(el bool, acc uint64) uint64) uint64 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelBool) ReduceInterface(acc interface{}, f func(el bool, acc interface{}) interface{}) interface{} {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelBool) ScanBool(acc bool, f func(el bool, acc bool) bool) chan bool {
	result := make(chan bool, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelBool) ScanByte(acc byte, f func(el bool, acc byte) byte) chan byte {
	result := make(chan byte, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelBool) ScanString(acc string, f func(el bool, acc string) string) chan string {
	result := make(chan string, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelBool) ScanFloat32(acc float32, f func(el bool, acc float32) float32) chan float32 {
	result := make(chan float32, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelBool) ScanFloat64(acc float64, f func(el bool, acc float64) float64) chan float64 {
	result := make(chan float64, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelBool) ScanInt(acc int, f func(el bool, acc int) int) chan int {
	result := make(chan int, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelBool) ScanInt8(acc int8, f func(el bool, acc int8) int8) chan int8 {
	result := make(chan int8, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelBool) ScanInt16(acc int16, f func(el bool, acc int16) int16) chan int16 {
	result := make(chan int16, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelBool) ScanInt32(acc int32, f func(el bool, acc int32) int32) chan int32 {
	result := make(chan int32, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelBool) ScanInt64(acc int64, f func(el bool, acc int64) int64) chan int64 {
	result := make(chan int64, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelBool) ScanUint(acc uint, f func(el bool, acc uint) uint) chan uint {
	result := make(chan uint, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelBool) ScanUint8(acc uint8, f func(el bool, acc uint8) uint8) chan uint8 {
	result := make(chan uint8, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelBool) ScanUint16(acc uint16, f func(el bool, acc uint16) uint16) chan uint16 {
	result := make(chan uint16, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelBool) ScanUint32(acc uint32, f func(el bool, acc uint32) uint32) chan uint32 {
	result := make(chan uint32, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelBool) ScanUint64(acc uint64, f func(el bool, acc uint64) uint64) chan uint64 {
	result := make(chan uint64, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelBool) ScanInterface(acc interface{}, f func(el bool, acc interface{}) interface{}) chan interface{} {
	result := make(chan interface{}, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Take takes first count elements from the channel.
func (c ChannelBool) Take(count int) chan bool {
	result := make(chan bool, 1)
	go func() {
		defer close(result)
		if count <= 0 {
			return
		}
		i := 0
		for el := range c.Data {
			result <- el
			i++
			if i == count {
				return
			}
		}
	}()
	return result
}

// Tee returns 2 channels with elements from the input channel
func (c ChannelBool) Tee(count int) []chan bool {
	channels := make([]chan bool, 0, count)
	for i := 0; i < count; i++ {
		channels = append(channels, make(chan bool, 1))
	}
	go func() {
		for el := range c.Data {
			wg := sync.WaitGroup{}
			putInto := func(ch chan bool) {
				defer wg.Done()
				ch <- el
			}
			wg.Add(count)
			for _, ch := range channels {
				putInto(ch)
			}
			wg.Wait()
		}
		for _, ch := range channels {
			close(ch)
		}
	}()
	return channels
}

// ToSlice returns slice with all elements from channel.
func (c ChannelBool) ToSlice() []bool {
	result := make([]bool, 0)
	for val := range c.Data {
		result = append(result, val)
	}
	return result
}

// All returns true if f returns true for all elements in slice
func (s AsyncSliceBool) All(f func(el bool) bool) bool {
	if len(s.Data) == 0 {
		return true
	}

	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int, result chan<- bool, ctx context.Context) {
		defer wg.Done()
		for {
			select {
			case <-ctx.Done():
				return
			case index, ok := <-jobs:
				if !ok {
					return
				}
				if !f(s.Data[index]) {
					result <- false
					return
				}
			}
		}
	}

	ctx, cancel := context.WithCancel(context.Background())
	// when we're returning the result, cancel all workers
	defer cancel()

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	result := make(chan bool, workers)
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs, result, ctx)
	}

	// close the result channel when all workers have done
	go func() {
		wg.Wait()
		close(result)
	}()

	// schedule the jobs: indices to check
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)

	for range result {
		return false
	}
	return true
}

// Any returns true if f returns true for any element from slice
func (s AsyncSliceBool) Any(f func(el bool) bool) bool {
	if len(s.Data) == 0 {
		return false
	}

	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int, result chan<- bool, ctx context.Context) {
		defer wg.Done()
		for {
			select {
			case <-ctx.Done():
				return
			case index, ok := <-jobs:
				if !ok {
					return
				}
				if f(s.Data[index]) {
					result <- true
					return
				}
			}
		}
	}

	ctx, cancel := context.WithCancel(context.Background())
	// when we're returning the result, cancel all workers
	defer cancel()

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	result := make(chan bool, workers)
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs, result, ctx)
	}

	// close the result channel when all workers have done
	go func() {
		wg.Wait()
		close(result)
	}()

	// schedule the jobs: indices to check
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)

	for range result {
		return true
	}
	return false
}

// Each calls f for every element from slice
func (s AsyncSliceBool) Each(f func(el bool)) {
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		defer wg.Done()
		for index := range jobs {
			f(s.Data[index])
		}
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
}

// Filter returns slice of element for which f returns true
func (s AsyncSliceBool) Filter(f func(el bool) bool) []bool {
	resultMap := make([]bool, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			if f(s.Data[index]) {
				resultMap[index] = true
			}
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()

	// return filtered results
	result := make([]bool, 0, len(s.Data))
	for i, el := range s.Data {
		if resultMap[i] {
			result = append(result, el)
		}
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceBool) MapBool(f func(el bool) bool) []bool {
	result := make([]bool, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceBool) MapByte(f func(el bool) byte) []byte {
	result := make([]byte, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceBool) MapString(f func(el bool) string) []string {
	result := make([]string, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceBool) MapFloat32(f func(el bool) float32) []float32 {
	result := make([]float32, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceBool) MapFloat64(f func(el bool) float64) []float64 {
	result := make([]float64, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceBool) MapInt(f func(el bool) int) []int {
	result := make([]int, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceBool) MapInt8(f func(el bool) int8) []int8 {
	result := make([]int8, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceBool) MapInt16(f func(el bool) int16) []int16 {
	result := make([]int16, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceBool) MapInt32(f func(el bool) int32) []int32 {
	result := make([]int32, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceBool) MapInt64(f func(el bool) int64) []int64 {
	result := make([]int64, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceBool) MapUint(f func(el bool) uint) []uint {
	result := make([]uint, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceBool) MapUint8(f func(el bool) uint8) []uint8 {
	result := make([]uint8, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceBool) MapUint16(f func(el bool) uint16) []uint16 {
	result := make([]uint16, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceBool) MapUint32(f func(el bool) uint32) []uint32 {
	result := make([]uint32, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceBool) MapUint64(f func(el bool) uint64) []uint64 {
	result := make([]uint64, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceBool) MapInterface(f func(el bool) interface{}) []interface{} {
	result := make([]interface{}, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Reduce reduces slice to a single value with f
func (s AsyncSliceBool) Reduce(f func(left bool, right bool) bool) bool {
	if len(s.Data) == 0 {
		var tmp bool
		return tmp
	}

	state := make([]bool, len(s.Data))
	state = append(state, s.Data...)
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int, result chan<- bool) {
		for index := range jobs {
			result <- f(state[index], state[index+1])
		}
		wg.Done()
	}

	for len(state) > 1 {
		// calculate workers count
		workers := s.Workers
		if workers == 0 || workers > len(state) {
			workers = len(state)
		}

		// run workers
		jobs := make(chan int, len(state))
		wg.Add(workers)
		result := make(chan bool, 1)
		for i := 0; i < workers; i++ {
			go worker(jobs, result)
		}

		go func() {
			wg.Wait()
			close(result)
		}()

		// add indices into jobs for workers
		for i := 0; i < len(state)-1; i += 2 {
			jobs <- i
		}
		close(jobs)

		// collect new state
		newState := make([]bool, 0, len(state)/2+len(state)%2)
		for el := range result {
			newState = append(newState, el)
		}
		if len(state)%2 == 1 {
			newState = append(newState, state[len(state)-1])
		}
		// put new state as current state after all
		state = newState
	}

	return state[0]
}

// Iterate returns an infinite list of repeated applications of f to val
func (s SequenceBool) Iterate(val bool, f func(val bool) bool) chan bool {
	c := make(chan bool, 1)
	go func() {
		defer close(c)
		for {
			select {
			case <-s.ctx.Done():
				return
			case c <- val:
				val = f(val)
			}
		}
	}()
	return c
}

// Repeat returns channel that produces val infinite times
func (s SequenceBool) Repeat(val bool) chan bool {
	c := make(chan bool, 1)
	go func() {
		defer close(c)
		for {
			select {
			case <-s.ctx.Done():
				return
			case c <- val:
				continue
			}
		}
	}()
	return c
}

// Replicate returns channel that produces val n times
func (s SequenceBool) Replicate(val bool, n int) chan bool {
	c := make(chan bool, 1)
	go func() {
		for i := 0; i < n; i++ {
			c <- val
		}
		close(c)
	}()
	return c
}

// Any returns true if f returns true for any element in arr
func (s SliceBool) Any(f func(el bool) bool) bool {
	for _, el := range s.Data {
		if f(el) {
			return true
		}
	}
	return false
}

// All returns true if f returns true for all elements in arr
func (s SliceBool) All(f func(el bool) bool) bool {
	for _, el := range s.Data {
		if !f(el) {
			return false
		}
	}
	return true
}

// Choice chooses a random element from the slice
func (s SliceBool) Choice() (bool, error) {
	if len(s.Data) == 0 {
		var tmp bool
		return tmp, ErrEmpty
	}

	rand.Seed(time.Now().UnixNano())
	i := rand.Intn(len(s.Data))
	return s.Data[i], nil
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceBool) ChunkByBool(f func(el bool) bool) [][]bool {
	chunks := make([][]bool, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]bool, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]bool, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceBool) ChunkByByte(f func(el bool) byte) [][]bool {
	chunks := make([][]bool, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]bool, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]bool, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceBool) ChunkByString(f func(el bool) string) [][]bool {
	chunks := make([][]bool, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]bool, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]bool, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceBool) ChunkByFloat32(f func(el bool) float32) [][]bool {
	chunks := make([][]bool, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]bool, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]bool, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceBool) ChunkByFloat64(f func(el bool) float64) [][]bool {
	chunks := make([][]bool, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]bool, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]bool, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceBool) ChunkByInt(f func(el bool) int) [][]bool {
	chunks := make([][]bool, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]bool, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]bool, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceBool) ChunkByInt8(f func(el bool) int8) [][]bool {
	chunks := make([][]bool, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]bool, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]bool, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceBool) ChunkByInt16(f func(el bool) int16) [][]bool {
	chunks := make([][]bool, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]bool, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]bool, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceBool) ChunkByInt32(f func(el bool) int32) [][]bool {
	chunks := make([][]bool, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]bool, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]bool, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceBool) ChunkByInt64(f func(el bool) int64) [][]bool {
	chunks := make([][]bool, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]bool, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]bool, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceBool) ChunkByUint(f func(el bool) uint) [][]bool {
	chunks := make([][]bool, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]bool, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]bool, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceBool) ChunkByUint8(f func(el bool) uint8) [][]bool {
	chunks := make([][]bool, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]bool, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]bool, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceBool) ChunkByUint16(f func(el bool) uint16) [][]bool {
	chunks := make([][]bool, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]bool, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]bool, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceBool) ChunkByUint32(f func(el bool) uint32) [][]bool {
	chunks := make([][]bool, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]bool, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]bool, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceBool) ChunkByUint64(f func(el bool) uint64) [][]bool {
	chunks := make([][]bool, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]bool, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]bool, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceBool) ChunkByInterface(f func(el bool) interface{}) [][]bool {
	chunks := make([][]bool, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]bool, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]bool, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkEvery returns slice of slices containing count elements each
func (s SliceBool) ChunkEvery(count int) ([][]bool, error) {
	chunks := make([][]bool, 0)
	if count <= 0 {
		return chunks, ErrNegativeValue
	}
	chunk := make([]bool, 0, count)
	for i, el := range s.Data {
		chunk = append(chunk, el)
		if (i+1)%count == 0 {
			chunks = append(chunks, chunk)
			chunk = make([]bool, 0, count)
		}
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks, nil
}

// Contains returns true if el in arr.
func (s SliceBool) Contains(el bool) bool {
	for _, val := range s.Data {
		if val == el {
			return true
		}
	}
	return false
}

// Count return count of el occurences in arr.
func (s SliceBool) Count(el bool) int {
	count := 0
	for _, val := range s.Data {
		if val == el {
			count++
		}
	}
	return count
}

// CountBy returns how many times f returns true.
func (s SliceBool) CountBy(f func(el bool) bool) int {
	count := 0
	for _, el := range s.Data {
		if f(el) {
			count++
		}
	}
	return count
}

// Cycle is an infinite loop over slice
func (s SliceBool) Cycle() chan bool {
	c := make(chan bool, 1)
	go func() {
		defer close(c)
		if len(s.Data) == 0 {
			return
		}
		for {
			for _, val := range s.Data {
				c <- val
			}
		}
	}()
	return c
}

// Dedup returns a given slice without consecutive duplicated elements
func (s SliceBool) Dedup() []bool {
	if len(s.Data) == 0 {
		return s.Data
	}

	result := make([]bool, 0, len(s.Data))
	prev := s.Data[0]
	result = append(result, prev)
	for _, el := range s.Data[1:] {
		if el != prev {
			result = append(result, el)
			prev = el
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceBool) DedupByBool(f func(el bool) bool) []bool {
	result := make([]bool, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceBool) DedupByByte(f func(el bool) byte) []bool {
	result := make([]bool, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceBool) DedupByString(f func(el bool) string) []bool {
	result := make([]bool, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceBool) DedupByFloat32(f func(el bool) float32) []bool {
	result := make([]bool, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceBool) DedupByFloat64(f func(el bool) float64) []bool {
	result := make([]bool, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceBool) DedupByInt(f func(el bool) int) []bool {
	result := make([]bool, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceBool) DedupByInt8(f func(el bool) int8) []bool {
	result := make([]bool, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceBool) DedupByInt16(f func(el bool) int16) []bool {
	result := make([]bool, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceBool) DedupByInt32(f func(el bool) int32) []bool {
	result := make([]bool, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceBool) DedupByInt64(f func(el bool) int64) []bool {
	result := make([]bool, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceBool) DedupByUint(f func(el bool) uint) []bool {
	result := make([]bool, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceBool) DedupByUint8(f func(el bool) uint8) []bool {
	result := make([]bool, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceBool) DedupByUint16(f func(el bool) uint16) []bool {
	result := make([]bool, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceBool) DedupByUint32(f func(el bool) uint32) []bool {
	result := make([]bool, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceBool) DedupByUint64(f func(el bool) uint64) []bool {
	result := make([]bool, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceBool) DedupByInterface(f func(el bool) interface{}) []bool {
	result := make([]bool, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// Delete deletes the first occurence of the element from the slice
func (s SliceBool) Delete(element bool) []bool {
	result := make([]bool, 0, len(s.Data)-1)
	deleted := false
	for _, el := range s.Data {
		if !deleted && el == element {
			continue
		}
		result = append(result, el)
	}
	return result

}

// DeleteAt returns the slice without elements on given positions
func (s SliceBool) DeleteAt(index int) ([]bool, error) {
	if index >= len(s.Data) {
		return s.Data, ErrOutOfRange
	}

	result := make([]bool, 0, len(s.Data)-1)
	for i, el := range s.Data {
		if i != index {
			result = append(result, el)
		}
	}
	return result, nil
}

// DropEvery returns a slice of every nth element in the enumerable dropped,
// starting with the first element.
func (s SliceBool) DropEvery(nth int) ([]bool, error) {
	if nth <= 0 {
		return s.Data, ErrNonPositiveValue
	}
	result := make([]bool, 0, len(s.Data)/nth)
	for i, el := range s.Data {
		if (i+1)%nth != 0 {
			result = append(result, el)
		}
	}
	return result, nil
}

// DropWhile drops elements from arr while f returns true
func (s SliceBool) DropWhile(f func(arr bool) bool) []bool {
	result := make([]bool, 0, len(s.Data))
	for _, el := range s.Data {
		if !f(el) {
			return result
		}
		result = append(result, el)
	}
	return result
}

// Each calls f for every element from arr
func (s SliceBool) Each(f func(el bool)) {
	for _, el := range s.Data {
		f(el)
	}
}

// Equal returns true if slices are equal
func (s SliceBool) Equal(other []bool) bool {
	if len(s.Data) != len(other) {
		return false
	}
	for i, el := range other {
		if s.Data[i] != el {
			return false
		}
	}
	return true
}

// Filter returns slice of T for which F returned true
func (s SliceBool) Filter(f func(el bool) bool) []bool {
	result := make([]bool, 0, len(s.Data))
	for _, el := range s.Data {
		if f(el) {
			result = append(result, el)
		}
	}
	return result
}

// Find returns the first element for which f returns true
func (s SliceBool) Find(f func(el bool) bool) (bool, error) {
	for _, el := range s.Data {
		if f(el) {
			return el, nil
		}
	}
	var tmp bool
	return tmp, ErrNotFound
}

// FindIndex is like Find, but return element index instead of element itself
func (s SliceBool) FindIndex(f func(el bool) bool) (int, error) {
	for i, el := range s.Data {
		if f(el) {
			return i, nil
		}
	}
	return 0, ErrNotFound
}

// GroupBy groups element from array by value returned by f
func (s SliceBool) GroupByBool(f func(el bool) bool) map[bool][]bool {
	result := make(map[bool][]bool)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]bool, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceBool) GroupByByte(f func(el bool) byte) map[byte][]bool {
	result := make(map[byte][]bool)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]bool, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceBool) GroupByString(f func(el bool) string) map[string][]bool {
	result := make(map[string][]bool)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]bool, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceBool) GroupByFloat32(f func(el bool) float32) map[float32][]bool {
	result := make(map[float32][]bool)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]bool, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceBool) GroupByFloat64(f func(el bool) float64) map[float64][]bool {
	result := make(map[float64][]bool)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]bool, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceBool) GroupByInt(f func(el bool) int) map[int][]bool {
	result := make(map[int][]bool)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]bool, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceBool) GroupByInt8(f func(el bool) int8) map[int8][]bool {
	result := make(map[int8][]bool)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]bool, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceBool) GroupByInt16(f func(el bool) int16) map[int16][]bool {
	result := make(map[int16][]bool)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]bool, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceBool) GroupByInt32(f func(el bool) int32) map[int32][]bool {
	result := make(map[int32][]bool)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]bool, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceBool) GroupByInt64(f func(el bool) int64) map[int64][]bool {
	result := make(map[int64][]bool)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]bool, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceBool) GroupByUint(f func(el bool) uint) map[uint][]bool {
	result := make(map[uint][]bool)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]bool, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceBool) GroupByUint8(f func(el bool) uint8) map[uint8][]bool {
	result := make(map[uint8][]bool)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]bool, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceBool) GroupByUint16(f func(el bool) uint16) map[uint16][]bool {
	result := make(map[uint16][]bool)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]bool, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceBool) GroupByUint32(f func(el bool) uint32) map[uint32][]bool {
	result := make(map[uint32][]bool)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]bool, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceBool) GroupByUint64(f func(el bool) uint64) map[uint64][]bool {
	result := make(map[uint64][]bool)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]bool, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceBool) GroupByInterface(f func(el bool) interface{}) map[interface{}][]bool {
	result := make(map[interface{}][]bool)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]bool, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// InsertAt returns the slice with element inserted at given index.
func (s SliceBool) InsertAt(index int, element bool) ([]bool, error) {
	result := make([]bool, 0, len(s.Data)+1)

	// insert at the end
	if index == len(s.Data) || index == -1 {
		result = append(result, s.Data...)
		result = append(result, element)
		return result, nil
	}

	if index > len(s.Data) {
		return s.Data, ErrOutOfRange
	}
	if index < 0 {
		return s.Data, ErrNegativeValue
	}

	for i, el := range s.Data {
		if i == index {
			result = append(result, element)
		}
		result = append(result, el)
	}
	return result, nil
}

// Intersperse inserts el between each element of arr
func (s SliceBool) Intersperse(el bool) []bool {
	if len(s.Data) == 0 {
		return s.Data
	}
	result := make([]bool, 0, len(s.Data)*2-1)
	result = append(result, s.Data[0])
	for _, val := range s.Data[1:] {
		result = append(result, el, val)
	}
	return result
}

// Last returns the last element from the slice
func (s SliceBool) Last() (bool, error) {
	if len(s.Data) == 0 {
		var tmp bool
		return tmp, ErrEmpty
	}
	return s.Data[len(s.Data)-1], nil
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceBool) MapBool(f func(el bool) bool) []bool {
	result := make([]bool, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceBool) MapByte(f func(el bool) byte) []byte {
	result := make([]byte, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceBool) MapString(f func(el bool) string) []string {
	result := make([]string, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceBool) MapFloat32(f func(el bool) float32) []float32 {
	result := make([]float32, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceBool) MapFloat64(f func(el bool) float64) []float64 {
	result := make([]float64, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceBool) MapInt(f func(el bool) int) []int {
	result := make([]int, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceBool) MapInt8(f func(el bool) int8) []int8 {
	result := make([]int8, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceBool) MapInt16(f func(el bool) int16) []int16 {
	result := make([]int16, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceBool) MapInt32(f func(el bool) int32) []int32 {
	result := make([]int32, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceBool) MapInt64(f func(el bool) int64) []int64 {
	result := make([]int64, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceBool) MapUint(f func(el bool) uint) []uint {
	result := make([]uint, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceBool) MapUint8(f func(el bool) uint8) []uint8 {
	result := make([]uint8, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceBool) MapUint16(f func(el bool) uint16) []uint16 {
	result := make([]uint16, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceBool) MapUint32(f func(el bool) uint32) []uint32 {
	result := make([]uint32, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceBool) MapUint64(f func(el bool) uint64) []uint64 {
	result := make([]uint64, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceBool) MapInterface(f func(el bool) interface{}) []interface{} {
	result := make([]interface{}, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Permutations returns successive size-length permutations of elements from the slice.
// {1, 2, 3} -> {1, 2}, {1, 3}, {2, 1}, {2, 3}, {3, 1}, {3, 2}
func (s SliceBool) Permutations(size int) chan []bool {
	c := make(chan []bool, 1)
	go func() {
		if len(s.Data) > 0 {
			s.permutations(c, size, []bool{}, s.Data)
		}
		close(c)
	}()
	return c
}

// permutations is a core implementation for Permutations
func (s SliceBool) permutations(c chan []bool, size int, left []bool, right []bool) {
	if len(left) == size || len(right) == 0 {
		c <- left
		return
	}

	for i, el := range right {
		newLeft := make([]bool, 0, len(left)+1)
		newLeft = append(newLeft, left...)
		newLeft = append(newLeft, el)

		newRight := make([]bool, 0, len(right)-1)
		for j, other := range right {
			if j != i {
				newRight = append(newRight, other)
			}
		}
		s.permutations(c, size, newLeft, newRight)
	}
}

// Product returns cortesian product of elements
// {{1, 2}, {3, 4}} -> {1, 3}, {1, 4}, {2, 3}, {2, 4}
func (s SliceBool) Product(repeat int) chan []bool {
	c := make(chan []bool, 1)
	go s.product(c, repeat, []bool{}, 0)
	return c
}

// product is a core implementation for Product
func (s SliceBool) product(c chan []bool, repeat int, left []bool, pos int) {
	// iterate over the last array
	if pos == repeat-1 {
		for _, el := range s.Data {
			result := make([]bool, 0, len(left)+1)
			result = append(result, left...)
			result = append(result, el)
			c <- result
		}
		return
	}

	for _, el := range s.Data {
		result := make([]bool, 0, len(left)+1)
		result = append(result, left...)
		result = append(result, el)
		s.product(c, repeat, result, pos+1)
	}

	if pos == 0 {
		close(c)
	}
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceBool) ReduceBool(acc bool, f func(el bool, acc bool) bool) bool {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceBool) ReduceByte(acc byte, f func(el bool, acc byte) byte) byte {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceBool) ReduceString(acc string, f func(el bool, acc string) string) string {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceBool) ReduceFloat32(acc float32, f func(el bool, acc float32) float32) float32 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceBool) ReduceFloat64(acc float64, f func(el bool, acc float64) float64) float64 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceBool) ReduceInt(acc int, f func(el bool, acc int) int) int {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceBool) ReduceInt8(acc int8, f func(el bool, acc int8) int8) int8 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceBool) ReduceInt16(acc int16, f func(el bool, acc int16) int16) int16 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceBool) ReduceInt32(acc int32, f func(el bool, acc int32) int32) int32 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceBool) ReduceInt64(acc int64, f func(el bool, acc int64) int64) int64 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceBool) ReduceUint(acc uint, f func(el bool, acc uint) uint) uint {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceBool) ReduceUint8(acc uint8, f func(el bool, acc uint8) uint8) uint8 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceBool) ReduceUint16(acc uint16, f func(el bool, acc uint16) uint16) uint16 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceBool) ReduceUint32(acc uint32, f func(el bool, acc uint32) uint32) uint32 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceBool) ReduceUint64(acc uint64, f func(el bool, acc uint64) uint64) uint64 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceBool) ReduceInterface(acc interface{}, f func(el bool, acc interface{}) interface{}) interface{} {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceBool) ReduceWhileBool(acc bool, f func(el bool, acc bool) (bool, error)) (bool, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceBool) ReduceWhileByte(acc byte, f func(el bool, acc byte) (byte, error)) (byte, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceBool) ReduceWhileString(acc string, f func(el bool, acc string) (string, error)) (string, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceBool) ReduceWhileFloat32(acc float32, f func(el bool, acc float32) (float32, error)) (float32, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceBool) ReduceWhileFloat64(acc float64, f func(el bool, acc float64) (float64, error)) (float64, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceBool) ReduceWhileInt(acc int, f func(el bool, acc int) (int, error)) (int, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceBool) ReduceWhileInt8(acc int8, f func(el bool, acc int8) (int8, error)) (int8, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceBool) ReduceWhileInt16(acc int16, f func(el bool, acc int16) (int16, error)) (int16, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceBool) ReduceWhileInt32(acc int32, f func(el bool, acc int32) (int32, error)) (int32, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceBool) ReduceWhileInt64(acc int64, f func(el bool, acc int64) (int64, error)) (int64, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceBool) ReduceWhileUint(acc uint, f func(el bool, acc uint) (uint, error)) (uint, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceBool) ReduceWhileUint8(acc uint8, f func(el bool, acc uint8) (uint8, error)) (uint8, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceBool) ReduceWhileUint16(acc uint16, f func(el bool, acc uint16) (uint16, error)) (uint16, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceBool) ReduceWhileUint32(acc uint32, f func(el bool, acc uint32) (uint32, error)) (uint32, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceBool) ReduceWhileUint64(acc uint64, f func(el bool, acc uint64) (uint64, error)) (uint64, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceBool) ReduceWhileInterface(acc interface{}, f func(el bool, acc interface{}) (interface{}, error)) (interface{}, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// Reverse returns given arr in reversed order
func (s SliceBool) Reverse() []bool {
	if len(s.Data) <= 1 {
		return s.Data
	}
	result := make([]bool, 0, len(s.Data))
	for i := len(s.Data) - 1; i >= 0; i-- {
		result = append(result, s.Data[i])
	}
	return result
}

// Same returns true if all element in arr the same
func (s SliceBool) Same() bool {
	if len(s.Data) <= 1 {
		return true
	}
	for i := 0; i < len(s.Data)-1; i++ {
		if s.Data[i] != s.Data[i+1] {
			return false
		}
	}
	return true
}

// Scan is like Reduce, but returns slice of f results
func (s SliceBool) ScanBool(acc bool, f func(el bool, acc bool) bool) []bool {
	result := make([]bool, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceBool) ScanByte(acc byte, f func(el bool, acc byte) byte) []byte {
	result := make([]byte, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceBool) ScanString(acc string, f func(el bool, acc string) string) []string {
	result := make([]string, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceBool) ScanFloat32(acc float32, f func(el bool, acc float32) float32) []float32 {
	result := make([]float32, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceBool) ScanFloat64(acc float64, f func(el bool, acc float64) float64) []float64 {
	result := make([]float64, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceBool) ScanInt(acc int, f func(el bool, acc int) int) []int {
	result := make([]int, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceBool) ScanInt8(acc int8, f func(el bool, acc int8) int8) []int8 {
	result := make([]int8, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceBool) ScanInt16(acc int16, f func(el bool, acc int16) int16) []int16 {
	result := make([]int16, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceBool) ScanInt32(acc int32, f func(el bool, acc int32) int32) []int32 {
	result := make([]int32, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceBool) ScanInt64(acc int64, f func(el bool, acc int64) int64) []int64 {
	result := make([]int64, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceBool) ScanUint(acc uint, f func(el bool, acc uint) uint) []uint {
	result := make([]uint, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceBool) ScanUint8(acc uint8, f func(el bool, acc uint8) uint8) []uint8 {
	result := make([]uint8, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceBool) ScanUint16(acc uint16, f func(el bool, acc uint16) uint16) []uint16 {
	result := make([]uint16, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceBool) ScanUint32(acc uint32, f func(el bool, acc uint32) uint32) []uint32 {
	result := make([]uint32, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceBool) ScanUint64(acc uint64, f func(el bool, acc uint64) uint64) []uint64 {
	result := make([]uint64, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceBool) ScanInterface(acc interface{}, f func(el bool, acc interface{}) interface{}) []interface{} {
	result := make([]interface{}, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Shuffle in random order arr elements
func (s SliceBool) Shuffle() []bool {
	if len(s.Data) <= 1 {
		return s.Data
	}
	rand.Seed(time.Now().UnixNano())
	swap := func(i, j int) {
		s.Data[i], s.Data[j] = s.Data[j], s.Data[i]
	}
	rand.Shuffle(len(s.Data), swap)
	return s.Data
}

// Split splits arr by sep
func (s SliceBool) Split(sep bool) [][]bool {
	result := make([][]bool, 0)
	curr := make([]bool, 0)
	for _, el := range s.Data {
		if el == sep {
			result = append(result, curr)
		} else {
			curr = append(curr, el)
		}
	}
	result = append(result, curr)
	return result
}

// StartsWith returns true if slice starts with the given prefix slice.
// If prefix is empty, it returns true.
func (s SliceBool) StartsWith(prefix []bool) bool {
	if len(prefix) > len(s.Data) {
		return false
	}
	for i, el := range prefix {
		if el != s.Data[i] {
			return false
		}
	}
	return true
}

// TakeEvery returns slice of every nth elements
func (s SliceBool) TakeEvery(nth int) ([]bool, error) {
	if nth <= 0 {
		return s.Data, ErrNonPositiveValue
	}
	result := make([]bool, 0, len(s.Data))
	for i, el := range s.Data {
		if (i+1)%nth == 0 {
			result = append(result, el)
		}
	}
	return result, nil
}

// TakeRandom returns slice of count random elements from the slice
func (s SliceBool) TakeRandom(count int) ([]bool, error) {
	if count > len(s.Data) {
		return nil, ErrOutOfRange
	}
	if count <= 0 {
		return nil, ErrNonPositiveValue
	}

	rand.Seed(time.Now().UnixNano())
	swap := func(i, j int) {
		s.Data[i], s.Data[j] = s.Data[j], s.Data[i]
	}
	rand.Shuffle(len(s.Data), swap)
	return s.Data[:count], nil
}

// TakeWhile takes elements from arr while f returns true
func (s SliceBool) TakeWhile(f func(el bool) bool) []bool {
	result := make([]bool, 0, len(s.Data))
	for _, el := range s.Data {
		if !f(el) {
			return result
		}
		result = append(result, el)
	}
	return result
}

// ToChannel returns channel with elements from the slice
func (s SliceBool) ToChannel() chan bool {
	c := make(chan bool, 1)
	go func() {
		for _, el := range s.Data {
			c <- el
		}
		close(c)
	}()
	return c
}

// Uniq returns arr with only first occurences of every element.
func (s SliceBool) Uniq() []bool {
	if len(s.Data) <= 1 {
		return s.Data
	}
	added := make(map[bool]struct{})
	nothing := struct{}{}
	result := make([]bool, 0, len(s.Data))
	for _, el := range s.Data {
		_, exists := added[el]
		if !exists {
			result = append(result, el)
			added[el] = nothing
		}
	}
	return result

}

// Window makes sliding window for a given slice:
// ({1,2,3}, 2) -> (1,2), (2,3)
func (s SliceBool) Window(size int) ([][]bool, error) {
	if size <= 0 {
		return nil, ErrNonPositiveValue
	}
	result := make([][]bool, 0, len(s.Data)/size)
	for i := 0; i <= len(s.Data)-size; i++ {
		chunk := s.Data[i : i+size]
		result = append(result, chunk)
	}
	return result, nil
}

// Without returns the slice with filtered out element
func (s SliceBool) Without(elements ...bool) []bool {
	result := make([]bool, 0, len(s.Data))
	for _, el := range s.Data {
		allowed := true
		for _, other := range elements {
			if el == other {
				allowed = false
			}
		}
		if allowed {
			result = append(result, el)
		}
	}
	return result
}

// Concat concatenates given slices into a single slice.
func (s SlicesBool) Concat() []bool {
	result := make([]bool, 0)
	for _, arr := range s.Data {
		result = append(result, arr...)
	}
	return result
}

// Product returns cortesian product of elements
// {{1, 2}, {3, 4}} -> {1, 3}, {1, 4}, {2, 3}, {2, 4}
func (s SlicesBool) Product() chan []bool {
	c := make(chan []bool, 1)
	go s.product(c, []bool{}, 0)
	return c
}

// product is a core implementation of Product
func (s SlicesBool) product(c chan []bool, left []bool, pos int) {
	// iterate over the last array
	if pos == len(s.Data)-1 {
		for _, el := range s.Data[pos] {
			result := make([]bool, 0, len(left)+1)
			result = append(result, left...)
			result = append(result, el)
			c <- result
		}
		return
	}

	for _, el := range s.Data[pos] {
		result := make([]bool, 0, len(left)+1)
		result = append(result, left...)
		result = append(result, el)
		s.product(c, result, pos+1)
	}

	if pos == 0 {
		close(c)
	}
}

// Zip returns array of arrays of elements from given arrs
// on the same position
func (s SlicesBool) Zip() [][]bool {
	size := len(s.Data[0])
	for _, arr := range s.Data[1:] {
		if len(arr) > size {
			size = len(arr)
		}
	}

	result := make([][]bool, 0, size)
	for i := 0; i <= size; i++ {
		chunk := make([]bool, 0, len(s.Data))
		for _, arr := range s.Data {
			chunk = append(chunk, arr[i])
		}
		result = append(result, chunk)
	}
	return result
}

// Channel is a set of operations with channel
type ChannelByte struct {
	Data chan byte
}

// AsyncSlice is a set of operations to work with slice asynchronously
type AsyncSliceByte struct {
	Data    []byte
	Workers int
}

// Sequence is a set of operations to generate sequences
type SequenceByte struct {
	ctx context.Context
}

// Pair is a set of functions for 2 values that you can pass into reduce-like funcs
type PairByte struct {
	// empty
}

// Slice is a set of operations to work with slice
type SliceByte struct {
	Data []byte
}

// Slices is a set of operations to work with slice of slices
type SlicesByte struct {
	Data [][]byte
}

// Any returns true if f returns true for any element in channel
func (c ChannelByte) Any(f func(el byte) bool) bool {
	for el := range c.Data {
		if f(el) {
			return true
		}
	}
	return false
}

// All returns true if f returns true for all elements in channel
func (c ChannelByte) All(f func(el byte) bool) bool {
	for el := range c.Data {
		if !f(el) {
			return false
		}
	}
	return true
}

// ChunkEvery returns channel with slices containing count elements each
func (c ChannelByte) ChunkEvery(count int) chan []byte {
	chunks := make(chan []byte, 1)
	go func() {
		chunk := make([]byte, 0, count)
		i := 0
		for el := range c.Data {
			chunk = append(chunk, el)
			i++
			if i%count == 0 {
				i = 0
				chunks <- chunk
				chunk = make([]byte, 0, count)
			}
		}
		if len(chunk) > 0 {
			chunks <- chunk
		}
		close(chunks)
	}()
	return chunks
}

// Count return count of el occurences in channel.
func (c ChannelByte) Count(el byte) int {
	count := 0
	for val := range c.Data {
		if val == el {
			count++
		}
	}
	return count
}

// Drop drops first n elements from channel c and returns a new channel with the rest.
// It returns channel do be unblocking. If you want array instead, wrap result into TakeAll.
func (c ChannelByte) Drop(n int) chan byte {
	result := make(chan byte, 1)
	go func() {
		i := 0
		for el := range c.Data {
			if i >= n {
				result <- el
			}
			i++
		}
		close(result)
	}()
	return result
}

// Each calls f for every element in the channel
func (c ChannelByte) Each(f func(el byte)) {
	for el := range c.Data {
		f(el)
	}
}

// Filter returns a new channel with elements from input channel
// for which f returns true
func (c ChannelByte) Filter(f func(el byte) bool) chan byte {
	result := make(chan byte, 1)
	go func() {
		for el := range c.Data {
			if f(el) {
				result <- el
			}
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelByte) MapBool(f func(el byte) bool) chan bool {
	result := make(chan bool, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelByte) MapByte(f func(el byte) byte) chan byte {
	result := make(chan byte, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelByte) MapString(f func(el byte) string) chan string {
	result := make(chan string, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelByte) MapFloat32(f func(el byte) float32) chan float32 {
	result := make(chan float32, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelByte) MapFloat64(f func(el byte) float64) chan float64 {
	result := make(chan float64, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelByte) MapInt(f func(el byte) int) chan int {
	result := make(chan int, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelByte) MapInt8(f func(el byte) int8) chan int8 {
	result := make(chan int8, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelByte) MapInt16(f func(el byte) int16) chan int16 {
	result := make(chan int16, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelByte) MapInt32(f func(el byte) int32) chan int32 {
	result := make(chan int32, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelByte) MapInt64(f func(el byte) int64) chan int64 {
	result := make(chan int64, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelByte) MapUint(f func(el byte) uint) chan uint {
	result := make(chan uint, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelByte) MapUint8(f func(el byte) uint8) chan uint8 {
	result := make(chan uint8, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelByte) MapUint16(f func(el byte) uint16) chan uint16 {
	result := make(chan uint16, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelByte) MapUint32(f func(el byte) uint32) chan uint32 {
	result := make(chan uint32, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelByte) MapUint64(f func(el byte) uint64) chan uint64 {
	result := make(chan uint64, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelByte) MapInterface(f func(el byte) interface{}) chan interface{} {
	result := make(chan interface{}, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Max returns the maximal element from channel
func (c ChannelByte) Max() (byte, error) {
	max, ok := <-c.Data
	if !ok {
		return max, ErrEmpty
	}
	for el := range c.Data {
		if el > max {
			max = el
		}
	}
	return max, nil
}

// Min returns the minimal element from channel
func (c ChannelByte) Min() (byte, error) {
	min, ok := <-c.Data
	if !ok {
		return min, ErrEmpty
	}
	for el := range c.Data {
		if el < min {
			min = el
		}
	}
	return min, nil
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelByte) ReduceBool(acc bool, f func(el byte, acc bool) bool) bool {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelByte) ReduceByte(acc byte, f func(el byte, acc byte) byte) byte {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelByte) ReduceString(acc string, f func(el byte, acc string) string) string {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelByte) ReduceFloat32(acc float32, f func(el byte, acc float32) float32) float32 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelByte) ReduceFloat64(acc float64, f func(el byte, acc float64) float64) float64 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelByte) ReduceInt(acc int, f func(el byte, acc int) int) int {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelByte) ReduceInt8(acc int8, f func(el byte, acc int8) int8) int8 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelByte) ReduceInt16(acc int16, f func(el byte, acc int16) int16) int16 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelByte) ReduceInt32(acc int32, f func(el byte, acc int32) int32) int32 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelByte) ReduceInt64(acc int64, f func(el byte, acc int64) int64) int64 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelByte) ReduceUint(acc uint, f func(el byte, acc uint) uint) uint {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelByte) ReduceUint8(acc uint8, f func(el byte, acc uint8) uint8) uint8 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelByte) ReduceUint16(acc uint16, f func(el byte, acc uint16) uint16) uint16 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelByte) ReduceUint32(acc uint32, f func(el byte, acc uint32) uint32) uint32 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelByte) ReduceUint64(acc uint64, f func(el byte, acc uint64) uint64) uint64 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelByte) ReduceInterface(acc interface{}, f func(el byte, acc interface{}) interface{}) interface{} {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelByte) ScanBool(acc bool, f func(el byte, acc bool) bool) chan bool {
	result := make(chan bool, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelByte) ScanByte(acc byte, f func(el byte, acc byte) byte) chan byte {
	result := make(chan byte, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelByte) ScanString(acc string, f func(el byte, acc string) string) chan string {
	result := make(chan string, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelByte) ScanFloat32(acc float32, f func(el byte, acc float32) float32) chan float32 {
	result := make(chan float32, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelByte) ScanFloat64(acc float64, f func(el byte, acc float64) float64) chan float64 {
	result := make(chan float64, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelByte) ScanInt(acc int, f func(el byte, acc int) int) chan int {
	result := make(chan int, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelByte) ScanInt8(acc int8, f func(el byte, acc int8) int8) chan int8 {
	result := make(chan int8, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelByte) ScanInt16(acc int16, f func(el byte, acc int16) int16) chan int16 {
	result := make(chan int16, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelByte) ScanInt32(acc int32, f func(el byte, acc int32) int32) chan int32 {
	result := make(chan int32, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelByte) ScanInt64(acc int64, f func(el byte, acc int64) int64) chan int64 {
	result := make(chan int64, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelByte) ScanUint(acc uint, f func(el byte, acc uint) uint) chan uint {
	result := make(chan uint, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelByte) ScanUint8(acc uint8, f func(el byte, acc uint8) uint8) chan uint8 {
	result := make(chan uint8, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelByte) ScanUint16(acc uint16, f func(el byte, acc uint16) uint16) chan uint16 {
	result := make(chan uint16, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelByte) ScanUint32(acc uint32, f func(el byte, acc uint32) uint32) chan uint32 {
	result := make(chan uint32, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelByte) ScanUint64(acc uint64, f func(el byte, acc uint64) uint64) chan uint64 {
	result := make(chan uint64, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelByte) ScanInterface(acc interface{}, f func(el byte, acc interface{}) interface{}) chan interface{} {
	result := make(chan interface{}, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Sum returns sum of all elements from channel
func (c ChannelByte) Sum() byte {
	var sum byte
	for el := range c.Data {
		sum += el
	}
	return sum
}

// Take takes first count elements from the channel.
func (c ChannelByte) Take(count int) chan byte {
	result := make(chan byte, 1)
	go func() {
		defer close(result)
		if count <= 0 {
			return
		}
		i := 0
		for el := range c.Data {
			result <- el
			i++
			if i == count {
				return
			}
		}
	}()
	return result
}

// Tee returns 2 channels with elements from the input channel
func (c ChannelByte) Tee(count int) []chan byte {
	channels := make([]chan byte, 0, count)
	for i := 0; i < count; i++ {
		channels = append(channels, make(chan byte, 1))
	}
	go func() {
		for el := range c.Data {
			wg := sync.WaitGroup{}
			putInto := func(ch chan byte) {
				defer wg.Done()
				ch <- el
			}
			wg.Add(count)
			for _, ch := range channels {
				putInto(ch)
			}
			wg.Wait()
		}
		for _, ch := range channels {
			close(ch)
		}
	}()
	return channels
}

// ToSlice returns slice with all elements from channel.
func (c ChannelByte) ToSlice() []byte {
	result := make([]byte, 0)
	for val := range c.Data {
		result = append(result, val)
	}
	return result
}

// All returns true if f returns true for all elements in slice
func (s AsyncSliceByte) All(f func(el byte) bool) bool {
	if len(s.Data) == 0 {
		return true
	}

	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int, result chan<- bool, ctx context.Context) {
		defer wg.Done()
		for {
			select {
			case <-ctx.Done():
				return
			case index, ok := <-jobs:
				if !ok {
					return
				}
				if !f(s.Data[index]) {
					result <- false
					return
				}
			}
		}
	}

	ctx, cancel := context.WithCancel(context.Background())
	// when we're returning the result, cancel all workers
	defer cancel()

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	result := make(chan bool, workers)
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs, result, ctx)
	}

	// close the result channel when all workers have done
	go func() {
		wg.Wait()
		close(result)
	}()

	// schedule the jobs: indices to check
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)

	for range result {
		return false
	}
	return true
}

// Any returns true if f returns true for any element from slice
func (s AsyncSliceByte) Any(f func(el byte) bool) bool {
	if len(s.Data) == 0 {
		return false
	}

	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int, result chan<- bool, ctx context.Context) {
		defer wg.Done()
		for {
			select {
			case <-ctx.Done():
				return
			case index, ok := <-jobs:
				if !ok {
					return
				}
				if f(s.Data[index]) {
					result <- true
					return
				}
			}
		}
	}

	ctx, cancel := context.WithCancel(context.Background())
	// when we're returning the result, cancel all workers
	defer cancel()

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	result := make(chan bool, workers)
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs, result, ctx)
	}

	// close the result channel when all workers have done
	go func() {
		wg.Wait()
		close(result)
	}()

	// schedule the jobs: indices to check
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)

	for range result {
		return true
	}
	return false
}

// Each calls f for every element from slice
func (s AsyncSliceByte) Each(f func(el byte)) {
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		defer wg.Done()
		for index := range jobs {
			f(s.Data[index])
		}
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
}

// Filter returns slice of element for which f returns true
func (s AsyncSliceByte) Filter(f func(el byte) bool) []byte {
	resultMap := make([]bool, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			if f(s.Data[index]) {
				resultMap[index] = true
			}
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()

	// return filtered results
	result := make([]byte, 0, len(s.Data))
	for i, el := range s.Data {
		if resultMap[i] {
			result = append(result, el)
		}
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceByte) MapBool(f func(el byte) bool) []bool {
	result := make([]bool, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceByte) MapByte(f func(el byte) byte) []byte {
	result := make([]byte, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceByte) MapString(f func(el byte) string) []string {
	result := make([]string, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceByte) MapFloat32(f func(el byte) float32) []float32 {
	result := make([]float32, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceByte) MapFloat64(f func(el byte) float64) []float64 {
	result := make([]float64, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceByte) MapInt(f func(el byte) int) []int {
	result := make([]int, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceByte) MapInt8(f func(el byte) int8) []int8 {
	result := make([]int8, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceByte) MapInt16(f func(el byte) int16) []int16 {
	result := make([]int16, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceByte) MapInt32(f func(el byte) int32) []int32 {
	result := make([]int32, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceByte) MapInt64(f func(el byte) int64) []int64 {
	result := make([]int64, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceByte) MapUint(f func(el byte) uint) []uint {
	result := make([]uint, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceByte) MapUint8(f func(el byte) uint8) []uint8 {
	result := make([]uint8, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceByte) MapUint16(f func(el byte) uint16) []uint16 {
	result := make([]uint16, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceByte) MapUint32(f func(el byte) uint32) []uint32 {
	result := make([]uint32, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceByte) MapUint64(f func(el byte) uint64) []uint64 {
	result := make([]uint64, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceByte) MapInterface(f func(el byte) interface{}) []interface{} {
	result := make([]interface{}, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Reduce reduces slice to a single value with f
func (s AsyncSliceByte) Reduce(f func(left byte, right byte) byte) byte {
	if len(s.Data) == 0 {
		var tmp byte
		return tmp
	}

	state := make([]byte, len(s.Data))
	state = append(state, s.Data...)
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int, result chan<- byte) {
		for index := range jobs {
			result <- f(state[index], state[index+1])
		}
		wg.Done()
	}

	for len(state) > 1 {
		// calculate workers count
		workers := s.Workers
		if workers == 0 || workers > len(state) {
			workers = len(state)
		}

		// run workers
		jobs := make(chan int, len(state))
		wg.Add(workers)
		result := make(chan byte, 1)
		for i := 0; i < workers; i++ {
			go worker(jobs, result)
		}

		go func() {
			wg.Wait()
			close(result)
		}()

		// add indices into jobs for workers
		for i := 0; i < len(state)-1; i += 2 {
			jobs <- i
		}
		close(jobs)

		// collect new state
		newState := make([]byte, 0, len(state)/2+len(state)%2)
		for el := range result {
			newState = append(newState, el)
		}
		if len(state)%2 == 1 {
			newState = append(newState, state[len(state)-1])
		}
		// put new state as current state after all
		state = newState
	}

	return state[0]
}

// Iterate returns an infinite list of repeated applications of f to val
func (s SequenceByte) Iterate(val byte, f func(val byte) byte) chan byte {
	c := make(chan byte, 1)
	go func() {
		defer close(c)
		for {
			select {
			case <-s.ctx.Done():
				return
			case c <- val:
				val = f(val)
			}
		}
	}()
	return c
}

// Repeat returns channel that produces val infinite times
func (s SequenceByte) Repeat(val byte) chan byte {
	c := make(chan byte, 1)
	go func() {
		defer close(c)
		for {
			select {
			case <-s.ctx.Done():
				return
			case c <- val:
				continue
			}
		}
	}()
	return c
}

// Replicate returns channel that produces val n times
func (s SequenceByte) Replicate(val byte, n int) chan byte {
	c := make(chan byte, 1)
	go func() {
		for i := 0; i < n; i++ {
			c <- val
		}
		close(c)
	}()
	return c
}

// Min returns minimal value
func (PairByte) Min(a byte, b byte) byte {
	if a <= b {
		return a
	}
	return b
}

// Max returns maximal value
func (PairByte) Max(a byte, b byte) byte {
	if a > b {
		return a
	}
	return b
}

// Any returns true if f returns true for any element in arr
func (s SliceByte) Any(f func(el byte) bool) bool {
	for _, el := range s.Data {
		if f(el) {
			return true
		}
	}
	return false
}

// All returns true if f returns true for all elements in arr
func (s SliceByte) All(f func(el byte) bool) bool {
	for _, el := range s.Data {
		if !f(el) {
			return false
		}
	}
	return true
}

// Choice chooses a random element from the slice
func (s SliceByte) Choice() (byte, error) {
	if len(s.Data) == 0 {
		var tmp byte
		return tmp, ErrEmpty
	}

	rand.Seed(time.Now().UnixNano())
	i := rand.Intn(len(s.Data))
	return s.Data[i], nil
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceByte) ChunkByBool(f func(el byte) bool) [][]byte {
	chunks := make([][]byte, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]byte, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]byte, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceByte) ChunkByByte(f func(el byte) byte) [][]byte {
	chunks := make([][]byte, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]byte, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]byte, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceByte) ChunkByString(f func(el byte) string) [][]byte {
	chunks := make([][]byte, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]byte, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]byte, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceByte) ChunkByFloat32(f func(el byte) float32) [][]byte {
	chunks := make([][]byte, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]byte, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]byte, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceByte) ChunkByFloat64(f func(el byte) float64) [][]byte {
	chunks := make([][]byte, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]byte, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]byte, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceByte) ChunkByInt(f func(el byte) int) [][]byte {
	chunks := make([][]byte, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]byte, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]byte, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceByte) ChunkByInt8(f func(el byte) int8) [][]byte {
	chunks := make([][]byte, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]byte, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]byte, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceByte) ChunkByInt16(f func(el byte) int16) [][]byte {
	chunks := make([][]byte, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]byte, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]byte, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceByte) ChunkByInt32(f func(el byte) int32) [][]byte {
	chunks := make([][]byte, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]byte, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]byte, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceByte) ChunkByInt64(f func(el byte) int64) [][]byte {
	chunks := make([][]byte, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]byte, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]byte, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceByte) ChunkByUint(f func(el byte) uint) [][]byte {
	chunks := make([][]byte, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]byte, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]byte, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceByte) ChunkByUint8(f func(el byte) uint8) [][]byte {
	chunks := make([][]byte, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]byte, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]byte, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceByte) ChunkByUint16(f func(el byte) uint16) [][]byte {
	chunks := make([][]byte, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]byte, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]byte, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceByte) ChunkByUint32(f func(el byte) uint32) [][]byte {
	chunks := make([][]byte, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]byte, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]byte, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceByte) ChunkByUint64(f func(el byte) uint64) [][]byte {
	chunks := make([][]byte, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]byte, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]byte, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceByte) ChunkByInterface(f func(el byte) interface{}) [][]byte {
	chunks := make([][]byte, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]byte, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]byte, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkEvery returns slice of slices containing count elements each
func (s SliceByte) ChunkEvery(count int) ([][]byte, error) {
	chunks := make([][]byte, 0)
	if count <= 0 {
		return chunks, ErrNegativeValue
	}
	chunk := make([]byte, 0, count)
	for i, el := range s.Data {
		chunk = append(chunk, el)
		if (i+1)%count == 0 {
			chunks = append(chunks, chunk)
			chunk = make([]byte, 0, count)
		}
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks, nil
}

// Contains returns true if el in arr.
func (s SliceByte) Contains(el byte) bool {
	for _, val := range s.Data {
		if val == el {
			return true
		}
	}
	return false
}

// Count return count of el occurences in arr.
func (s SliceByte) Count(el byte) int {
	count := 0
	for _, val := range s.Data {
		if val == el {
			count++
		}
	}
	return count
}

// CountBy returns how many times f returns true.
func (s SliceByte) CountBy(f func(el byte) bool) int {
	count := 0
	for _, el := range s.Data {
		if f(el) {
			count++
		}
	}
	return count
}

// Cycle is an infinite loop over slice
func (s SliceByte) Cycle() chan byte {
	c := make(chan byte, 1)
	go func() {
		defer close(c)
		if len(s.Data) == 0 {
			return
		}
		for {
			for _, val := range s.Data {
				c <- val
			}
		}
	}()
	return c
}

// Dedup returns a given slice without consecutive duplicated elements
func (s SliceByte) Dedup() []byte {
	if len(s.Data) == 0 {
		return s.Data
	}

	result := make([]byte, 0, len(s.Data))
	prev := s.Data[0]
	result = append(result, prev)
	for _, el := range s.Data[1:] {
		if el != prev {
			result = append(result, el)
			prev = el
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceByte) DedupByBool(f func(el byte) bool) []byte {
	result := make([]byte, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceByte) DedupByByte(f func(el byte) byte) []byte {
	result := make([]byte, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceByte) DedupByString(f func(el byte) string) []byte {
	result := make([]byte, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceByte) DedupByFloat32(f func(el byte) float32) []byte {
	result := make([]byte, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceByte) DedupByFloat64(f func(el byte) float64) []byte {
	result := make([]byte, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceByte) DedupByInt(f func(el byte) int) []byte {
	result := make([]byte, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceByte) DedupByInt8(f func(el byte) int8) []byte {
	result := make([]byte, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceByte) DedupByInt16(f func(el byte) int16) []byte {
	result := make([]byte, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceByte) DedupByInt32(f func(el byte) int32) []byte {
	result := make([]byte, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceByte) DedupByInt64(f func(el byte) int64) []byte {
	result := make([]byte, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceByte) DedupByUint(f func(el byte) uint) []byte {
	result := make([]byte, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceByte) DedupByUint8(f func(el byte) uint8) []byte {
	result := make([]byte, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceByte) DedupByUint16(f func(el byte) uint16) []byte {
	result := make([]byte, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceByte) DedupByUint32(f func(el byte) uint32) []byte {
	result := make([]byte, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceByte) DedupByUint64(f func(el byte) uint64) []byte {
	result := make([]byte, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceByte) DedupByInterface(f func(el byte) interface{}) []byte {
	result := make([]byte, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// Delete deletes the first occurence of the element from the slice
func (s SliceByte) Delete(element byte) []byte {
	result := make([]byte, 0, len(s.Data)-1)
	deleted := false
	for _, el := range s.Data {
		if !deleted && el == element {
			continue
		}
		result = append(result, el)
	}
	return result

}

// DeleteAt returns the slice without elements on given positions
func (s SliceByte) DeleteAt(index int) ([]byte, error) {
	if index >= len(s.Data) {
		return s.Data, ErrOutOfRange
	}

	result := make([]byte, 0, len(s.Data)-1)
	for i, el := range s.Data {
		if i != index {
			result = append(result, el)
		}
	}
	return result, nil
}

// DropEvery returns a slice of every nth element in the enumerable dropped,
// starting with the first element.
func (s SliceByte) DropEvery(nth int) ([]byte, error) {
	if nth <= 0 {
		return s.Data, ErrNonPositiveValue
	}
	result := make([]byte, 0, len(s.Data)/nth)
	for i, el := range s.Data {
		if (i+1)%nth != 0 {
			result = append(result, el)
		}
	}
	return result, nil
}

// DropWhile drops elements from arr while f returns true
func (s SliceByte) DropWhile(f func(arr byte) bool) []byte {
	result := make([]byte, 0, len(s.Data))
	for _, el := range s.Data {
		if !f(el) {
			return result
		}
		result = append(result, el)
	}
	return result
}

// Each calls f for every element from arr
func (s SliceByte) Each(f func(el byte)) {
	for _, el := range s.Data {
		f(el)
	}
}

// Equal returns true if slices are equal
func (s SliceByte) Equal(other []byte) bool {
	if len(s.Data) != len(other) {
		return false
	}
	for i, el := range other {
		if s.Data[i] != el {
			return false
		}
	}
	return true
}

// Filter returns slice of T for which F returned true
func (s SliceByte) Filter(f func(el byte) bool) []byte {
	result := make([]byte, 0, len(s.Data))
	for _, el := range s.Data {
		if f(el) {
			result = append(result, el)
		}
	}
	return result
}

// Find returns the first element for which f returns true
func (s SliceByte) Find(f func(el byte) bool) (byte, error) {
	for _, el := range s.Data {
		if f(el) {
			return el, nil
		}
	}
	var tmp byte
	return tmp, ErrNotFound
}

// FindIndex is like Find, but return element index instead of element itself
func (s SliceByte) FindIndex(f func(el byte) bool) (int, error) {
	for i, el := range s.Data {
		if f(el) {
			return i, nil
		}
	}
	return 0, ErrNotFound
}

// Join concatenates elements of the slice to create a single string.
func (s SliceByte) Join(sep string) string {
	strs := make([]string, 0, len(s.Data))
	for _, el := range s.Data {
		strs = append(strs, string(el))
	}
	return strings.Join(strs, sep)
}

// GroupBy groups element from array by value returned by f
func (s SliceByte) GroupByBool(f func(el byte) bool) map[bool][]byte {
	result := make(map[bool][]byte)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]byte, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceByte) GroupByByte(f func(el byte) byte) map[byte][]byte {
	result := make(map[byte][]byte)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]byte, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceByte) GroupByString(f func(el byte) string) map[string][]byte {
	result := make(map[string][]byte)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]byte, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceByte) GroupByFloat32(f func(el byte) float32) map[float32][]byte {
	result := make(map[float32][]byte)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]byte, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceByte) GroupByFloat64(f func(el byte) float64) map[float64][]byte {
	result := make(map[float64][]byte)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]byte, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceByte) GroupByInt(f func(el byte) int) map[int][]byte {
	result := make(map[int][]byte)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]byte, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceByte) GroupByInt8(f func(el byte) int8) map[int8][]byte {
	result := make(map[int8][]byte)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]byte, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceByte) GroupByInt16(f func(el byte) int16) map[int16][]byte {
	result := make(map[int16][]byte)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]byte, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceByte) GroupByInt32(f func(el byte) int32) map[int32][]byte {
	result := make(map[int32][]byte)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]byte, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceByte) GroupByInt64(f func(el byte) int64) map[int64][]byte {
	result := make(map[int64][]byte)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]byte, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceByte) GroupByUint(f func(el byte) uint) map[uint][]byte {
	result := make(map[uint][]byte)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]byte, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceByte) GroupByUint8(f func(el byte) uint8) map[uint8][]byte {
	result := make(map[uint8][]byte)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]byte, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceByte) GroupByUint16(f func(el byte) uint16) map[uint16][]byte {
	result := make(map[uint16][]byte)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]byte, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceByte) GroupByUint32(f func(el byte) uint32) map[uint32][]byte {
	result := make(map[uint32][]byte)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]byte, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceByte) GroupByUint64(f func(el byte) uint64) map[uint64][]byte {
	result := make(map[uint64][]byte)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]byte, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceByte) GroupByInterface(f func(el byte) interface{}) map[interface{}][]byte {
	result := make(map[interface{}][]byte)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]byte, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// InsertAt returns the slice with element inserted at given index.
func (s SliceByte) InsertAt(index int, element byte) ([]byte, error) {
	result := make([]byte, 0, len(s.Data)+1)

	// insert at the end
	if index == len(s.Data) || index == -1 {
		result = append(result, s.Data...)
		result = append(result, element)
		return result, nil
	}

	if index > len(s.Data) {
		return s.Data, ErrOutOfRange
	}
	if index < 0 {
		return s.Data, ErrNegativeValue
	}

	for i, el := range s.Data {
		if i == index {
			result = append(result, element)
		}
		result = append(result, el)
	}
	return result, nil
}

// Intersperse inserts el between each element of arr
func (s SliceByte) Intersperse(el byte) []byte {
	if len(s.Data) == 0 {
		return s.Data
	}
	result := make([]byte, 0, len(s.Data)*2-1)
	result = append(result, s.Data[0])
	for _, val := range s.Data[1:] {
		result = append(result, el, val)
	}
	return result
}

// Last returns the last element from the slice
func (s SliceByte) Last() (byte, error) {
	if len(s.Data) == 0 {
		var tmp byte
		return tmp, ErrEmpty
	}
	return s.Data[len(s.Data)-1], nil
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceByte) MapBool(f func(el byte) bool) []bool {
	result := make([]bool, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceByte) MapByte(f func(el byte) byte) []byte {
	result := make([]byte, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceByte) MapString(f func(el byte) string) []string {
	result := make([]string, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceByte) MapFloat32(f func(el byte) float32) []float32 {
	result := make([]float32, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceByte) MapFloat64(f func(el byte) float64) []float64 {
	result := make([]float64, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceByte) MapInt(f func(el byte) int) []int {
	result := make([]int, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceByte) MapInt8(f func(el byte) int8) []int8 {
	result := make([]int8, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceByte) MapInt16(f func(el byte) int16) []int16 {
	result := make([]int16, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceByte) MapInt32(f func(el byte) int32) []int32 {
	result := make([]int32, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceByte) MapInt64(f func(el byte) int64) []int64 {
	result := make([]int64, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceByte) MapUint(f func(el byte) uint) []uint {
	result := make([]uint, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceByte) MapUint8(f func(el byte) uint8) []uint8 {
	result := make([]uint8, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceByte) MapUint16(f func(el byte) uint16) []uint16 {
	result := make([]uint16, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceByte) MapUint32(f func(el byte) uint32) []uint32 {
	result := make([]uint32, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceByte) MapUint64(f func(el byte) uint64) []uint64 {
	result := make([]uint64, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceByte) MapInterface(f func(el byte) interface{}) []interface{} {
	result := make([]interface{}, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Max returns the maximal element from arr
func (s SliceByte) Max() (byte, error) {
	if len(s.Data) == 0 {
		var tmp byte
		return tmp, ErrEmpty
	}

	max := s.Data[0]
	for _, el := range s.Data[1:] {
		if el > max {
			max = el
		}
	}
	return max, nil
}

// Min returns the minimal element from arr
func (s SliceByte) Min() (byte, error) {
	if len(s.Data) == 0 {
		var tmp byte
		return tmp, ErrEmpty
	}

	min := s.Data[0]
	for _, el := range s.Data[1:] {
		if el < min {
			min = el
		}
	}
	return min, nil
}

// Permutations returns successive size-length permutations of elements from the slice.
// {1, 2, 3} -> {1, 2}, {1, 3}, {2, 1}, {2, 3}, {3, 1}, {3, 2}
func (s SliceByte) Permutations(size int) chan []byte {
	c := make(chan []byte, 1)
	go func() {
		if len(s.Data) > 0 {
			s.permutations(c, size, []byte{}, s.Data)
		}
		close(c)
	}()
	return c
}

// permutations is a core implementation for Permutations
func (s SliceByte) permutations(c chan []byte, size int, left []byte, right []byte) {
	if len(left) == size || len(right) == 0 {
		c <- left
		return
	}

	for i, el := range right {
		newLeft := make([]byte, 0, len(left)+1)
		newLeft = append(newLeft, left...)
		newLeft = append(newLeft, el)

		newRight := make([]byte, 0, len(right)-1)
		for j, other := range right {
			if j != i {
				newRight = append(newRight, other)
			}
		}
		s.permutations(c, size, newLeft, newRight)
	}
}

// Product returns cortesian product of elements
// {{1, 2}, {3, 4}} -> {1, 3}, {1, 4}, {2, 3}, {2, 4}
func (s SliceByte) Product(repeat int) chan []byte {
	c := make(chan []byte, 1)
	go s.product(c, repeat, []byte{}, 0)
	return c
}

// product is a core implementation for Product
func (s SliceByte) product(c chan []byte, repeat int, left []byte, pos int) {
	// iterate over the last array
	if pos == repeat-1 {
		for _, el := range s.Data {
			result := make([]byte, 0, len(left)+1)
			result = append(result, left...)
			result = append(result, el)
			c <- result
		}
		return
	}

	for _, el := range s.Data {
		result := make([]byte, 0, len(left)+1)
		result = append(result, left...)
		result = append(result, el)
		s.product(c, repeat, result, pos+1)
	}

	if pos == 0 {
		close(c)
	}
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceByte) ReduceBool(acc bool, f func(el byte, acc bool) bool) bool {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceByte) ReduceByte(acc byte, f func(el byte, acc byte) byte) byte {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceByte) ReduceString(acc string, f func(el byte, acc string) string) string {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceByte) ReduceFloat32(acc float32, f func(el byte, acc float32) float32) float32 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceByte) ReduceFloat64(acc float64, f func(el byte, acc float64) float64) float64 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceByte) ReduceInt(acc int, f func(el byte, acc int) int) int {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceByte) ReduceInt8(acc int8, f func(el byte, acc int8) int8) int8 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceByte) ReduceInt16(acc int16, f func(el byte, acc int16) int16) int16 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceByte) ReduceInt32(acc int32, f func(el byte, acc int32) int32) int32 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceByte) ReduceInt64(acc int64, f func(el byte, acc int64) int64) int64 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceByte) ReduceUint(acc uint, f func(el byte, acc uint) uint) uint {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceByte) ReduceUint8(acc uint8, f func(el byte, acc uint8) uint8) uint8 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceByte) ReduceUint16(acc uint16, f func(el byte, acc uint16) uint16) uint16 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceByte) ReduceUint32(acc uint32, f func(el byte, acc uint32) uint32) uint32 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceByte) ReduceUint64(acc uint64, f func(el byte, acc uint64) uint64) uint64 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceByte) ReduceInterface(acc interface{}, f func(el byte, acc interface{}) interface{}) interface{} {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceByte) ReduceWhileBool(acc bool, f func(el byte, acc bool) (bool, error)) (bool, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceByte) ReduceWhileByte(acc byte, f func(el byte, acc byte) (byte, error)) (byte, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceByte) ReduceWhileString(acc string, f func(el byte, acc string) (string, error)) (string, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceByte) ReduceWhileFloat32(acc float32, f func(el byte, acc float32) (float32, error)) (float32, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceByte) ReduceWhileFloat64(acc float64, f func(el byte, acc float64) (float64, error)) (float64, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceByte) ReduceWhileInt(acc int, f func(el byte, acc int) (int, error)) (int, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceByte) ReduceWhileInt8(acc int8, f func(el byte, acc int8) (int8, error)) (int8, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceByte) ReduceWhileInt16(acc int16, f func(el byte, acc int16) (int16, error)) (int16, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceByte) ReduceWhileInt32(acc int32, f func(el byte, acc int32) (int32, error)) (int32, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceByte) ReduceWhileInt64(acc int64, f func(el byte, acc int64) (int64, error)) (int64, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceByte) ReduceWhileUint(acc uint, f func(el byte, acc uint) (uint, error)) (uint, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceByte) ReduceWhileUint8(acc uint8, f func(el byte, acc uint8) (uint8, error)) (uint8, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceByte) ReduceWhileUint16(acc uint16, f func(el byte, acc uint16) (uint16, error)) (uint16, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceByte) ReduceWhileUint32(acc uint32, f func(el byte, acc uint32) (uint32, error)) (uint32, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceByte) ReduceWhileUint64(acc uint64, f func(el byte, acc uint64) (uint64, error)) (uint64, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceByte) ReduceWhileInterface(acc interface{}, f func(el byte, acc interface{}) (interface{}, error)) (interface{}, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// Reverse returns given arr in reversed order
func (s SliceByte) Reverse() []byte {
	if len(s.Data) <= 1 {
		return s.Data
	}
	result := make([]byte, 0, len(s.Data))
	for i := len(s.Data) - 1; i >= 0; i-- {
		result = append(result, s.Data[i])
	}
	return result
}

// Same returns true if all element in arr the same
func (s SliceByte) Same() bool {
	if len(s.Data) <= 1 {
		return true
	}
	for i := 0; i < len(s.Data)-1; i++ {
		if s.Data[i] != s.Data[i+1] {
			return false
		}
	}
	return true
}

// Scan is like Reduce, but returns slice of f results
func (s SliceByte) ScanBool(acc bool, f func(el byte, acc bool) bool) []bool {
	result := make([]bool, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceByte) ScanByte(acc byte, f func(el byte, acc byte) byte) []byte {
	result := make([]byte, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceByte) ScanString(acc string, f func(el byte, acc string) string) []string {
	result := make([]string, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceByte) ScanFloat32(acc float32, f func(el byte, acc float32) float32) []float32 {
	result := make([]float32, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceByte) ScanFloat64(acc float64, f func(el byte, acc float64) float64) []float64 {
	result := make([]float64, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceByte) ScanInt(acc int, f func(el byte, acc int) int) []int {
	result := make([]int, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceByte) ScanInt8(acc int8, f func(el byte, acc int8) int8) []int8 {
	result := make([]int8, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceByte) ScanInt16(acc int16, f func(el byte, acc int16) int16) []int16 {
	result := make([]int16, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceByte) ScanInt32(acc int32, f func(el byte, acc int32) int32) []int32 {
	result := make([]int32, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceByte) ScanInt64(acc int64, f func(el byte, acc int64) int64) []int64 {
	result := make([]int64, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceByte) ScanUint(acc uint, f func(el byte, acc uint) uint) []uint {
	result := make([]uint, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceByte) ScanUint8(acc uint8, f func(el byte, acc uint8) uint8) []uint8 {
	result := make([]uint8, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceByte) ScanUint16(acc uint16, f func(el byte, acc uint16) uint16) []uint16 {
	result := make([]uint16, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceByte) ScanUint32(acc uint32, f func(el byte, acc uint32) uint32) []uint32 {
	result := make([]uint32, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceByte) ScanUint64(acc uint64, f func(el byte, acc uint64) uint64) []uint64 {
	result := make([]uint64, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceByte) ScanInterface(acc interface{}, f func(el byte, acc interface{}) interface{}) []interface{} {
	result := make([]interface{}, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Shuffle in random order arr elements
func (s SliceByte) Shuffle() []byte {
	if len(s.Data) <= 1 {
		return s.Data
	}
	rand.Seed(time.Now().UnixNano())
	swap := func(i, j int) {
		s.Data[i], s.Data[j] = s.Data[j], s.Data[i]
	}
	rand.Shuffle(len(s.Data), swap)
	return s.Data
}

// Sort returns sorted slice
func (s SliceByte) Sort() []byte {
	if len(s.Data) <= 1 {
		return s.Data
	}
	less := func(i int, j int) bool {
		return s.Data[i] < s.Data[j]
	}
	sort.SliceStable(s.Data, less)
	return s.Data
}

// Sorted returns true if slice is sorted
func (s SliceByte) Sorted() bool {
	if len(s.Data) <= 1 {
		return true
	}
	for i := 1; i < len(s.Data); i++ {
		if s.Data[i-1] > s.Data[i] {
			return false
		}
	}
	return true
}

// Split splits arr by sep
func (s SliceByte) Split(sep byte) [][]byte {
	result := make([][]byte, 0)
	curr := make([]byte, 0)
	for _, el := range s.Data {
		if el == sep {
			result = append(result, curr)
		} else {
			curr = append(curr, el)
		}
	}
	result = append(result, curr)
	return result
}

// StartsWith returns true if slice starts with the given prefix slice.
// If prefix is empty, it returns true.
func (s SliceByte) StartsWith(prefix []byte) bool {
	if len(prefix) > len(s.Data) {
		return false
	}
	for i, el := range prefix {
		if el != s.Data[i] {
			return false
		}
	}
	return true
}

// Sum return sum of all elements from arr
func (s SliceByte) Sum() byte {
	var sum byte
	for _, el := range s.Data {
		sum += el
	}
	return sum
}

// TakeEvery returns slice of every nth elements
func (s SliceByte) TakeEvery(nth int) ([]byte, error) {
	if nth <= 0 {
		return s.Data, ErrNonPositiveValue
	}
	result := make([]byte, 0, len(s.Data))
	for i, el := range s.Data {
		if (i+1)%nth == 0 {
			result = append(result, el)
		}
	}
	return result, nil
}

// TakeRandom returns slice of count random elements from the slice
func (s SliceByte) TakeRandom(count int) ([]byte, error) {
	if count > len(s.Data) {
		return nil, ErrOutOfRange
	}
	if count <= 0 {
		return nil, ErrNonPositiveValue
	}

	rand.Seed(time.Now().UnixNano())
	swap := func(i, j int) {
		s.Data[i], s.Data[j] = s.Data[j], s.Data[i]
	}
	rand.Shuffle(len(s.Data), swap)
	return s.Data[:count], nil
}

// TakeWhile takes elements from arr while f returns true
func (s SliceByte) TakeWhile(f func(el byte) bool) []byte {
	result := make([]byte, 0, len(s.Data))
	for _, el := range s.Data {
		if !f(el) {
			return result
		}
		result = append(result, el)
	}
	return result
}

// ToChannel returns channel with elements from the slice
func (s SliceByte) ToChannel() chan byte {
	c := make(chan byte, 1)
	go func() {
		for _, el := range s.Data {
			c <- el
		}
		close(c)
	}()
	return c
}

// Uniq returns arr with only first occurences of every element.
func (s SliceByte) Uniq() []byte {
	if len(s.Data) <= 1 {
		return s.Data
	}
	added := make(map[byte]struct{})
	nothing := struct{}{}
	result := make([]byte, 0, len(s.Data))
	for _, el := range s.Data {
		_, exists := added[el]
		if !exists {
			result = append(result, el)
			added[el] = nothing
		}
	}
	return result

}

// Window makes sliding window for a given slice:
// ({1,2,3}, 2) -> (1,2), (2,3)
func (s SliceByte) Window(size int) ([][]byte, error) {
	if size <= 0 {
		return nil, ErrNonPositiveValue
	}
	result := make([][]byte, 0, len(s.Data)/size)
	for i := 0; i <= len(s.Data)-size; i++ {
		chunk := s.Data[i : i+size]
		result = append(result, chunk)
	}
	return result, nil
}

// Without returns the slice with filtered out element
func (s SliceByte) Without(elements ...byte) []byte {
	result := make([]byte, 0, len(s.Data))
	for _, el := range s.Data {
		allowed := true
		for _, other := range elements {
			if el == other {
				allowed = false
			}
		}
		if allowed {
			result = append(result, el)
		}
	}
	return result
}

// Concat concatenates given slices into a single slice.
func (s SlicesByte) Concat() []byte {
	result := make([]byte, 0)
	for _, arr := range s.Data {
		result = append(result, arr...)
	}
	return result
}

// Product returns cortesian product of elements
// {{1, 2}, {3, 4}} -> {1, 3}, {1, 4}, {2, 3}, {2, 4}
func (s SlicesByte) Product() chan []byte {
	c := make(chan []byte, 1)
	go s.product(c, []byte{}, 0)
	return c
}

// product is a core implementation of Product
func (s SlicesByte) product(c chan []byte, left []byte, pos int) {
	// iterate over the last array
	if pos == len(s.Data)-1 {
		for _, el := range s.Data[pos] {
			result := make([]byte, 0, len(left)+1)
			result = append(result, left...)
			result = append(result, el)
			c <- result
		}
		return
	}

	for _, el := range s.Data[pos] {
		result := make([]byte, 0, len(left)+1)
		result = append(result, left...)
		result = append(result, el)
		s.product(c, result, pos+1)
	}

	if pos == 0 {
		close(c)
	}
}

// Zip returns array of arrays of elements from given arrs
// on the same position
func (s SlicesByte) Zip() [][]byte {
	size := len(s.Data[0])
	for _, arr := range s.Data[1:] {
		if len(arr) > size {
			size = len(arr)
		}
	}

	result := make([][]byte, 0, size)
	for i := 0; i <= size; i++ {
		chunk := make([]byte, 0, len(s.Data))
		for _, arr := range s.Data {
			chunk = append(chunk, arr[i])
		}
		result = append(result, chunk)
	}
	return result
}

// Channel is a set of operations with channel
type ChannelString struct {
	Data chan string
}

// AsyncSlice is a set of operations to work with slice asynchronously
type AsyncSliceString struct {
	Data    []string
	Workers int
}

// Sequence is a set of operations to generate sequences
type SequenceString struct {
	ctx context.Context
}

// Pair is a set of functions for 2 values that you can pass into reduce-like funcs
type PairString struct {
	// empty
}

// Slice is a set of operations to work with slice
type SliceString struct {
	Data []string
}

// Slices is a set of operations to work with slice of slices
type SlicesString struct {
	Data [][]string
}

// Any returns true if f returns true for any element in channel
func (c ChannelString) Any(f func(el string) bool) bool {
	for el := range c.Data {
		if f(el) {
			return true
		}
	}
	return false
}

// All returns true if f returns true for all elements in channel
func (c ChannelString) All(f func(el string) bool) bool {
	for el := range c.Data {
		if !f(el) {
			return false
		}
	}
	return true
}

// ChunkEvery returns channel with slices containing count elements each
func (c ChannelString) ChunkEvery(count int) chan []string {
	chunks := make(chan []string, 1)
	go func() {
		chunk := make([]string, 0, count)
		i := 0
		for el := range c.Data {
			chunk = append(chunk, el)
			i++
			if i%count == 0 {
				i = 0
				chunks <- chunk
				chunk = make([]string, 0, count)
			}
		}
		if len(chunk) > 0 {
			chunks <- chunk
		}
		close(chunks)
	}()
	return chunks
}

// Count return count of el occurences in channel.
func (c ChannelString) Count(el string) int {
	count := 0
	for val := range c.Data {
		if val == el {
			count++
		}
	}
	return count
}

// Drop drops first n elements from channel c and returns a new channel with the rest.
// It returns channel do be unblocking. If you want array instead, wrap result into TakeAll.
func (c ChannelString) Drop(n int) chan string {
	result := make(chan string, 1)
	go func() {
		i := 0
		for el := range c.Data {
			if i >= n {
				result <- el
			}
			i++
		}
		close(result)
	}()
	return result
}

// Each calls f for every element in the channel
func (c ChannelString) Each(f func(el string)) {
	for el := range c.Data {
		f(el)
	}
}

// Filter returns a new channel with elements from input channel
// for which f returns true
func (c ChannelString) Filter(f func(el string) bool) chan string {
	result := make(chan string, 1)
	go func() {
		for el := range c.Data {
			if f(el) {
				result <- el
			}
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelString) MapBool(f func(el string) bool) chan bool {
	result := make(chan bool, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelString) MapByte(f func(el string) byte) chan byte {
	result := make(chan byte, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelString) MapString(f func(el string) string) chan string {
	result := make(chan string, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelString) MapFloat32(f func(el string) float32) chan float32 {
	result := make(chan float32, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelString) MapFloat64(f func(el string) float64) chan float64 {
	result := make(chan float64, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelString) MapInt(f func(el string) int) chan int {
	result := make(chan int, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelString) MapInt8(f func(el string) int8) chan int8 {
	result := make(chan int8, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelString) MapInt16(f func(el string) int16) chan int16 {
	result := make(chan int16, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelString) MapInt32(f func(el string) int32) chan int32 {
	result := make(chan int32, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelString) MapInt64(f func(el string) int64) chan int64 {
	result := make(chan int64, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelString) MapUint(f func(el string) uint) chan uint {
	result := make(chan uint, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelString) MapUint8(f func(el string) uint8) chan uint8 {
	result := make(chan uint8, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelString) MapUint16(f func(el string) uint16) chan uint16 {
	result := make(chan uint16, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelString) MapUint32(f func(el string) uint32) chan uint32 {
	result := make(chan uint32, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelString) MapUint64(f func(el string) uint64) chan uint64 {
	result := make(chan uint64, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelString) MapInterface(f func(el string) interface{}) chan interface{} {
	result := make(chan interface{}, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Max returns the maximal element from channel
func (c ChannelString) Max() (string, error) {
	max, ok := <-c.Data
	if !ok {
		return max, ErrEmpty
	}
	for el := range c.Data {
		if el > max {
			max = el
		}
	}
	return max, nil
}

// Min returns the minimal element from channel
func (c ChannelString) Min() (string, error) {
	min, ok := <-c.Data
	if !ok {
		return min, ErrEmpty
	}
	for el := range c.Data {
		if el < min {
			min = el
		}
	}
	return min, nil
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelString) ReduceBool(acc bool, f func(el string, acc bool) bool) bool {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelString) ReduceByte(acc byte, f func(el string, acc byte) byte) byte {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelString) ReduceString(acc string, f func(el string, acc string) string) string {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelString) ReduceFloat32(acc float32, f func(el string, acc float32) float32) float32 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelString) ReduceFloat64(acc float64, f func(el string, acc float64) float64) float64 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelString) ReduceInt(acc int, f func(el string, acc int) int) int {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelString) ReduceInt8(acc int8, f func(el string, acc int8) int8) int8 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelString) ReduceInt16(acc int16, f func(el string, acc int16) int16) int16 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelString) ReduceInt32(acc int32, f func(el string, acc int32) int32) int32 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelString) ReduceInt64(acc int64, f func(el string, acc int64) int64) int64 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelString) ReduceUint(acc uint, f func(el string, acc uint) uint) uint {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelString) ReduceUint8(acc uint8, f func(el string, acc uint8) uint8) uint8 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelString) ReduceUint16(acc uint16, f func(el string, acc uint16) uint16) uint16 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelString) ReduceUint32(acc uint32, f func(el string, acc uint32) uint32) uint32 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelString) ReduceUint64(acc uint64, f func(el string, acc uint64) uint64) uint64 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelString) ReduceInterface(acc interface{}, f func(el string, acc interface{}) interface{}) interface{} {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelString) ScanBool(acc bool, f func(el string, acc bool) bool) chan bool {
	result := make(chan bool, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelString) ScanByte(acc byte, f func(el string, acc byte) byte) chan byte {
	result := make(chan byte, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelString) ScanString(acc string, f func(el string, acc string) string) chan string {
	result := make(chan string, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelString) ScanFloat32(acc float32, f func(el string, acc float32) float32) chan float32 {
	result := make(chan float32, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelString) ScanFloat64(acc float64, f func(el string, acc float64) float64) chan float64 {
	result := make(chan float64, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelString) ScanInt(acc int, f func(el string, acc int) int) chan int {
	result := make(chan int, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelString) ScanInt8(acc int8, f func(el string, acc int8) int8) chan int8 {
	result := make(chan int8, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelString) ScanInt16(acc int16, f func(el string, acc int16) int16) chan int16 {
	result := make(chan int16, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelString) ScanInt32(acc int32, f func(el string, acc int32) int32) chan int32 {
	result := make(chan int32, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelString) ScanInt64(acc int64, f func(el string, acc int64) int64) chan int64 {
	result := make(chan int64, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelString) ScanUint(acc uint, f func(el string, acc uint) uint) chan uint {
	result := make(chan uint, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelString) ScanUint8(acc uint8, f func(el string, acc uint8) uint8) chan uint8 {
	result := make(chan uint8, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelString) ScanUint16(acc uint16, f func(el string, acc uint16) uint16) chan uint16 {
	result := make(chan uint16, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelString) ScanUint32(acc uint32, f func(el string, acc uint32) uint32) chan uint32 {
	result := make(chan uint32, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelString) ScanUint64(acc uint64, f func(el string, acc uint64) uint64) chan uint64 {
	result := make(chan uint64, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelString) ScanInterface(acc interface{}, f func(el string, acc interface{}) interface{}) chan interface{} {
	result := make(chan interface{}, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Sum returns sum of all elements from channel
func (c ChannelString) Sum() string {
	var sum string
	for el := range c.Data {
		sum += el
	}
	return sum
}

// Take takes first count elements from the channel.
func (c ChannelString) Take(count int) chan string {
	result := make(chan string, 1)
	go func() {
		defer close(result)
		if count <= 0 {
			return
		}
		i := 0
		for el := range c.Data {
			result <- el
			i++
			if i == count {
				return
			}
		}
	}()
	return result
}

// Tee returns 2 channels with elements from the input channel
func (c ChannelString) Tee(count int) []chan string {
	channels := make([]chan string, 0, count)
	for i := 0; i < count; i++ {
		channels = append(channels, make(chan string, 1))
	}
	go func() {
		for el := range c.Data {
			wg := sync.WaitGroup{}
			putInto := func(ch chan string) {
				defer wg.Done()
				ch <- el
			}
			wg.Add(count)
			for _, ch := range channels {
				putInto(ch)
			}
			wg.Wait()
		}
		for _, ch := range channels {
			close(ch)
		}
	}()
	return channels
}

// ToSlice returns slice with all elements from channel.
func (c ChannelString) ToSlice() []string {
	result := make([]string, 0)
	for val := range c.Data {
		result = append(result, val)
	}
	return result
}

// All returns true if f returns true for all elements in slice
func (s AsyncSliceString) All(f func(el string) bool) bool {
	if len(s.Data) == 0 {
		return true
	}

	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int, result chan<- bool, ctx context.Context) {
		defer wg.Done()
		for {
			select {
			case <-ctx.Done():
				return
			case index, ok := <-jobs:
				if !ok {
					return
				}
				if !f(s.Data[index]) {
					result <- false
					return
				}
			}
		}
	}

	ctx, cancel := context.WithCancel(context.Background())
	// when we're returning the result, cancel all workers
	defer cancel()

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	result := make(chan bool, workers)
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs, result, ctx)
	}

	// close the result channel when all workers have done
	go func() {
		wg.Wait()
		close(result)
	}()

	// schedule the jobs: indices to check
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)

	for range result {
		return false
	}
	return true
}

// Any returns true if f returns true for any element from slice
func (s AsyncSliceString) Any(f func(el string) bool) bool {
	if len(s.Data) == 0 {
		return false
	}

	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int, result chan<- bool, ctx context.Context) {
		defer wg.Done()
		for {
			select {
			case <-ctx.Done():
				return
			case index, ok := <-jobs:
				if !ok {
					return
				}
				if f(s.Data[index]) {
					result <- true
					return
				}
			}
		}
	}

	ctx, cancel := context.WithCancel(context.Background())
	// when we're returning the result, cancel all workers
	defer cancel()

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	result := make(chan bool, workers)
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs, result, ctx)
	}

	// close the result channel when all workers have done
	go func() {
		wg.Wait()
		close(result)
	}()

	// schedule the jobs: indices to check
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)

	for range result {
		return true
	}
	return false
}

// Each calls f for every element from slice
func (s AsyncSliceString) Each(f func(el string)) {
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		defer wg.Done()
		for index := range jobs {
			f(s.Data[index])
		}
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
}

// Filter returns slice of element for which f returns true
func (s AsyncSliceString) Filter(f func(el string) bool) []string {
	resultMap := make([]bool, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			if f(s.Data[index]) {
				resultMap[index] = true
			}
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()

	// return filtered results
	result := make([]string, 0, len(s.Data))
	for i, el := range s.Data {
		if resultMap[i] {
			result = append(result, el)
		}
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceString) MapBool(f func(el string) bool) []bool {
	result := make([]bool, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceString) MapByte(f func(el string) byte) []byte {
	result := make([]byte, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceString) MapString(f func(el string) string) []string {
	result := make([]string, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceString) MapFloat32(f func(el string) float32) []float32 {
	result := make([]float32, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceString) MapFloat64(f func(el string) float64) []float64 {
	result := make([]float64, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceString) MapInt(f func(el string) int) []int {
	result := make([]int, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceString) MapInt8(f func(el string) int8) []int8 {
	result := make([]int8, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceString) MapInt16(f func(el string) int16) []int16 {
	result := make([]int16, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceString) MapInt32(f func(el string) int32) []int32 {
	result := make([]int32, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceString) MapInt64(f func(el string) int64) []int64 {
	result := make([]int64, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceString) MapUint(f func(el string) uint) []uint {
	result := make([]uint, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceString) MapUint8(f func(el string) uint8) []uint8 {
	result := make([]uint8, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceString) MapUint16(f func(el string) uint16) []uint16 {
	result := make([]uint16, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceString) MapUint32(f func(el string) uint32) []uint32 {
	result := make([]uint32, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceString) MapUint64(f func(el string) uint64) []uint64 {
	result := make([]uint64, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceString) MapInterface(f func(el string) interface{}) []interface{} {
	result := make([]interface{}, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Reduce reduces slice to a single value with f
func (s AsyncSliceString) Reduce(f func(left string, right string) string) string {
	if len(s.Data) == 0 {
		var tmp string
		return tmp
	}

	state := make([]string, len(s.Data))
	state = append(state, s.Data...)
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int, result chan<- string) {
		for index := range jobs {
			result <- f(state[index], state[index+1])
		}
		wg.Done()
	}

	for len(state) > 1 {
		// calculate workers count
		workers := s.Workers
		if workers == 0 || workers > len(state) {
			workers = len(state)
		}

		// run workers
		jobs := make(chan int, len(state))
		wg.Add(workers)
		result := make(chan string, 1)
		for i := 0; i < workers; i++ {
			go worker(jobs, result)
		}

		go func() {
			wg.Wait()
			close(result)
		}()

		// add indices into jobs for workers
		for i := 0; i < len(state)-1; i += 2 {
			jobs <- i
		}
		close(jobs)

		// collect new state
		newState := make([]string, 0, len(state)/2+len(state)%2)
		for el := range result {
			newState = append(newState, el)
		}
		if len(state)%2 == 1 {
			newState = append(newState, state[len(state)-1])
		}
		// put new state as current state after all
		state = newState
	}

	return state[0]
}

// Iterate returns an infinite list of repeated applications of f to val
func (s SequenceString) Iterate(val string, f func(val string) string) chan string {
	c := make(chan string, 1)
	go func() {
		defer close(c)
		for {
			select {
			case <-s.ctx.Done():
				return
			case c <- val:
				val = f(val)
			}
		}
	}()
	return c
}

// Repeat returns channel that produces val infinite times
func (s SequenceString) Repeat(val string) chan string {
	c := make(chan string, 1)
	go func() {
		defer close(c)
		for {
			select {
			case <-s.ctx.Done():
				return
			case c <- val:
				continue
			}
		}
	}()
	return c
}

// Replicate returns channel that produces val n times
func (s SequenceString) Replicate(val string, n int) chan string {
	c := make(chan string, 1)
	go func() {
		for i := 0; i < n; i++ {
			c <- val
		}
		close(c)
	}()
	return c
}

// Min returns minimal value
func (PairString) Min(a string, b string) string {
	if a <= b {
		return a
	}
	return b
}

// Max returns maximal value
func (PairString) Max(a string, b string) string {
	if a > b {
		return a
	}
	return b
}

// Any returns true if f returns true for any element in arr
func (s SliceString) Any(f func(el string) bool) bool {
	for _, el := range s.Data {
		if f(el) {
			return true
		}
	}
	return false
}

// All returns true if f returns true for all elements in arr
func (s SliceString) All(f func(el string) bool) bool {
	for _, el := range s.Data {
		if !f(el) {
			return false
		}
	}
	return true
}

// Choice chooses a random element from the slice
func (s SliceString) Choice() (string, error) {
	if len(s.Data) == 0 {
		var tmp string
		return tmp, ErrEmpty
	}

	rand.Seed(time.Now().UnixNano())
	i := rand.Intn(len(s.Data))
	return s.Data[i], nil
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceString) ChunkByBool(f func(el string) bool) [][]string {
	chunks := make([][]string, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]string, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]string, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceString) ChunkByByte(f func(el string) byte) [][]string {
	chunks := make([][]string, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]string, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]string, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceString) ChunkByString(f func(el string) string) [][]string {
	chunks := make([][]string, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]string, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]string, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceString) ChunkByFloat32(f func(el string) float32) [][]string {
	chunks := make([][]string, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]string, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]string, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceString) ChunkByFloat64(f func(el string) float64) [][]string {
	chunks := make([][]string, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]string, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]string, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceString) ChunkByInt(f func(el string) int) [][]string {
	chunks := make([][]string, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]string, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]string, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceString) ChunkByInt8(f func(el string) int8) [][]string {
	chunks := make([][]string, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]string, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]string, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceString) ChunkByInt16(f func(el string) int16) [][]string {
	chunks := make([][]string, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]string, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]string, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceString) ChunkByInt32(f func(el string) int32) [][]string {
	chunks := make([][]string, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]string, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]string, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceString) ChunkByInt64(f func(el string) int64) [][]string {
	chunks := make([][]string, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]string, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]string, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceString) ChunkByUint(f func(el string) uint) [][]string {
	chunks := make([][]string, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]string, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]string, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceString) ChunkByUint8(f func(el string) uint8) [][]string {
	chunks := make([][]string, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]string, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]string, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceString) ChunkByUint16(f func(el string) uint16) [][]string {
	chunks := make([][]string, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]string, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]string, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceString) ChunkByUint32(f func(el string) uint32) [][]string {
	chunks := make([][]string, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]string, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]string, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceString) ChunkByUint64(f func(el string) uint64) [][]string {
	chunks := make([][]string, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]string, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]string, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceString) ChunkByInterface(f func(el string) interface{}) [][]string {
	chunks := make([][]string, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]string, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]string, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkEvery returns slice of slices containing count elements each
func (s SliceString) ChunkEvery(count int) ([][]string, error) {
	chunks := make([][]string, 0)
	if count <= 0 {
		return chunks, ErrNegativeValue
	}
	chunk := make([]string, 0, count)
	for i, el := range s.Data {
		chunk = append(chunk, el)
		if (i+1)%count == 0 {
			chunks = append(chunks, chunk)
			chunk = make([]string, 0, count)
		}
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks, nil
}

// Contains returns true if el in arr.
func (s SliceString) Contains(el string) bool {
	for _, val := range s.Data {
		if val == el {
			return true
		}
	}
	return false
}

// Count return count of el occurences in arr.
func (s SliceString) Count(el string) int {
	count := 0
	for _, val := range s.Data {
		if val == el {
			count++
		}
	}
	return count
}

// CountBy returns how many times f returns true.
func (s SliceString) CountBy(f func(el string) bool) int {
	count := 0
	for _, el := range s.Data {
		if f(el) {
			count++
		}
	}
	return count
}

// Cycle is an infinite loop over slice
func (s SliceString) Cycle() chan string {
	c := make(chan string, 1)
	go func() {
		defer close(c)
		if len(s.Data) == 0 {
			return
		}
		for {
			for _, val := range s.Data {
				c <- val
			}
		}
	}()
	return c
}

// Dedup returns a given slice without consecutive duplicated elements
func (s SliceString) Dedup() []string {
	if len(s.Data) == 0 {
		return s.Data
	}

	result := make([]string, 0, len(s.Data))
	prev := s.Data[0]
	result = append(result, prev)
	for _, el := range s.Data[1:] {
		if el != prev {
			result = append(result, el)
			prev = el
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceString) DedupByBool(f func(el string) bool) []string {
	result := make([]string, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceString) DedupByByte(f func(el string) byte) []string {
	result := make([]string, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceString) DedupByString(f func(el string) string) []string {
	result := make([]string, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceString) DedupByFloat32(f func(el string) float32) []string {
	result := make([]string, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceString) DedupByFloat64(f func(el string) float64) []string {
	result := make([]string, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceString) DedupByInt(f func(el string) int) []string {
	result := make([]string, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceString) DedupByInt8(f func(el string) int8) []string {
	result := make([]string, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceString) DedupByInt16(f func(el string) int16) []string {
	result := make([]string, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceString) DedupByInt32(f func(el string) int32) []string {
	result := make([]string, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceString) DedupByInt64(f func(el string) int64) []string {
	result := make([]string, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceString) DedupByUint(f func(el string) uint) []string {
	result := make([]string, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceString) DedupByUint8(f func(el string) uint8) []string {
	result := make([]string, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceString) DedupByUint16(f func(el string) uint16) []string {
	result := make([]string, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceString) DedupByUint32(f func(el string) uint32) []string {
	result := make([]string, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceString) DedupByUint64(f func(el string) uint64) []string {
	result := make([]string, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceString) DedupByInterface(f func(el string) interface{}) []string {
	result := make([]string, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// Delete deletes the first occurence of the element from the slice
func (s SliceString) Delete(element string) []string {
	result := make([]string, 0, len(s.Data)-1)
	deleted := false
	for _, el := range s.Data {
		if !deleted && el == element {
			continue
		}
		result = append(result, el)
	}
	return result

}

// DeleteAt returns the slice without elements on given positions
func (s SliceString) DeleteAt(index int) ([]string, error) {
	if index >= len(s.Data) {
		return s.Data, ErrOutOfRange
	}

	result := make([]string, 0, len(s.Data)-1)
	for i, el := range s.Data {
		if i != index {
			result = append(result, el)
		}
	}
	return result, nil
}

// DropEvery returns a slice of every nth element in the enumerable dropped,
// starting with the first element.
func (s SliceString) DropEvery(nth int) ([]string, error) {
	if nth <= 0 {
		return s.Data, ErrNonPositiveValue
	}
	result := make([]string, 0, len(s.Data)/nth)
	for i, el := range s.Data {
		if (i+1)%nth != 0 {
			result = append(result, el)
		}
	}
	return result, nil
}

// DropWhile drops elements from arr while f returns true
func (s SliceString) DropWhile(f func(arr string) bool) []string {
	result := make([]string, 0, len(s.Data))
	for _, el := range s.Data {
		if !f(el) {
			return result
		}
		result = append(result, el)
	}
	return result
}

// Each calls f for every element from arr
func (s SliceString) Each(f func(el string)) {
	for _, el := range s.Data {
		f(el)
	}
}

// Equal returns true if slices are equal
func (s SliceString) Equal(other []string) bool {
	if len(s.Data) != len(other) {
		return false
	}
	for i, el := range other {
		if s.Data[i] != el {
			return false
		}
	}
	return true
}

// Filter returns slice of T for which F returned true
func (s SliceString) Filter(f func(el string) bool) []string {
	result := make([]string, 0, len(s.Data))
	for _, el := range s.Data {
		if f(el) {
			result = append(result, el)
		}
	}
	return result
}

// Find returns the first element for which f returns true
func (s SliceString) Find(f func(el string) bool) (string, error) {
	for _, el := range s.Data {
		if f(el) {
			return el, nil
		}
	}
	var tmp string
	return tmp, ErrNotFound
}

// FindIndex is like Find, but return element index instead of element itself
func (s SliceString) FindIndex(f func(el string) bool) (int, error) {
	for i, el := range s.Data {
		if f(el) {
			return i, nil
		}
	}
	return 0, ErrNotFound
}

// Join concatenates elements of the slice to create a single string.
func (s SliceString) Join(sep string) string {
	strs := make([]string, 0, len(s.Data))
	for _, el := range s.Data {
		strs = append(strs, string(el))
	}
	return strings.Join(strs, sep)
}

// GroupBy groups element from array by value returned by f
func (s SliceString) GroupByBool(f func(el string) bool) map[bool][]string {
	result := make(map[bool][]string)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]string, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceString) GroupByByte(f func(el string) byte) map[byte][]string {
	result := make(map[byte][]string)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]string, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceString) GroupByString(f func(el string) string) map[string][]string {
	result := make(map[string][]string)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]string, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceString) GroupByFloat32(f func(el string) float32) map[float32][]string {
	result := make(map[float32][]string)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]string, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceString) GroupByFloat64(f func(el string) float64) map[float64][]string {
	result := make(map[float64][]string)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]string, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceString) GroupByInt(f func(el string) int) map[int][]string {
	result := make(map[int][]string)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]string, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceString) GroupByInt8(f func(el string) int8) map[int8][]string {
	result := make(map[int8][]string)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]string, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceString) GroupByInt16(f func(el string) int16) map[int16][]string {
	result := make(map[int16][]string)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]string, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceString) GroupByInt32(f func(el string) int32) map[int32][]string {
	result := make(map[int32][]string)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]string, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceString) GroupByInt64(f func(el string) int64) map[int64][]string {
	result := make(map[int64][]string)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]string, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceString) GroupByUint(f func(el string) uint) map[uint][]string {
	result := make(map[uint][]string)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]string, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceString) GroupByUint8(f func(el string) uint8) map[uint8][]string {
	result := make(map[uint8][]string)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]string, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceString) GroupByUint16(f func(el string) uint16) map[uint16][]string {
	result := make(map[uint16][]string)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]string, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceString) GroupByUint32(f func(el string) uint32) map[uint32][]string {
	result := make(map[uint32][]string)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]string, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceString) GroupByUint64(f func(el string) uint64) map[uint64][]string {
	result := make(map[uint64][]string)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]string, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceString) GroupByInterface(f func(el string) interface{}) map[interface{}][]string {
	result := make(map[interface{}][]string)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]string, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// InsertAt returns the slice with element inserted at given index.
func (s SliceString) InsertAt(index int, element string) ([]string, error) {
	result := make([]string, 0, len(s.Data)+1)

	// insert at the end
	if index == len(s.Data) || index == -1 {
		result = append(result, s.Data...)
		result = append(result, element)
		return result, nil
	}

	if index > len(s.Data) {
		return s.Data, ErrOutOfRange
	}
	if index < 0 {
		return s.Data, ErrNegativeValue
	}

	for i, el := range s.Data {
		if i == index {
			result = append(result, element)
		}
		result = append(result, el)
	}
	return result, nil
}

// Intersperse inserts el between each element of arr
func (s SliceString) Intersperse(el string) []string {
	if len(s.Data) == 0 {
		return s.Data
	}
	result := make([]string, 0, len(s.Data)*2-1)
	result = append(result, s.Data[0])
	for _, val := range s.Data[1:] {
		result = append(result, el, val)
	}
	return result
}

// Last returns the last element from the slice
func (s SliceString) Last() (string, error) {
	if len(s.Data) == 0 {
		var tmp string
		return tmp, ErrEmpty
	}
	return s.Data[len(s.Data)-1], nil
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceString) MapBool(f func(el string) bool) []bool {
	result := make([]bool, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceString) MapByte(f func(el string) byte) []byte {
	result := make([]byte, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceString) MapString(f func(el string) string) []string {
	result := make([]string, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceString) MapFloat32(f func(el string) float32) []float32 {
	result := make([]float32, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceString) MapFloat64(f func(el string) float64) []float64 {
	result := make([]float64, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceString) MapInt(f func(el string) int) []int {
	result := make([]int, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceString) MapInt8(f func(el string) int8) []int8 {
	result := make([]int8, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceString) MapInt16(f func(el string) int16) []int16 {
	result := make([]int16, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceString) MapInt32(f func(el string) int32) []int32 {
	result := make([]int32, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceString) MapInt64(f func(el string) int64) []int64 {
	result := make([]int64, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceString) MapUint(f func(el string) uint) []uint {
	result := make([]uint, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceString) MapUint8(f func(el string) uint8) []uint8 {
	result := make([]uint8, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceString) MapUint16(f func(el string) uint16) []uint16 {
	result := make([]uint16, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceString) MapUint32(f func(el string) uint32) []uint32 {
	result := make([]uint32, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceString) MapUint64(f func(el string) uint64) []uint64 {
	result := make([]uint64, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceString) MapInterface(f func(el string) interface{}) []interface{} {
	result := make([]interface{}, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Max returns the maximal element from arr
func (s SliceString) Max() (string, error) {
	if len(s.Data) == 0 {
		var tmp string
		return tmp, ErrEmpty
	}

	max := s.Data[0]
	for _, el := range s.Data[1:] {
		if el > max {
			max = el
		}
	}
	return max, nil
}

// Min returns the minimal element from arr
func (s SliceString) Min() (string, error) {
	if len(s.Data) == 0 {
		var tmp string
		return tmp, ErrEmpty
	}

	min := s.Data[0]
	for _, el := range s.Data[1:] {
		if el < min {
			min = el
		}
	}
	return min, nil
}

// Permutations returns successive size-length permutations of elements from the slice.
// {1, 2, 3} -> {1, 2}, {1, 3}, {2, 1}, {2, 3}, {3, 1}, {3, 2}
func (s SliceString) Permutations(size int) chan []string {
	c := make(chan []string, 1)
	go func() {
		if len(s.Data) > 0 {
			s.permutations(c, size, []string{}, s.Data)
		}
		close(c)
	}()
	return c
}

// permutations is a core implementation for Permutations
func (s SliceString) permutations(c chan []string, size int, left []string, right []string) {
	if len(left) == size || len(right) == 0 {
		c <- left
		return
	}

	for i, el := range right {
		newLeft := make([]string, 0, len(left)+1)
		newLeft = append(newLeft, left...)
		newLeft = append(newLeft, el)

		newRight := make([]string, 0, len(right)-1)
		for j, other := range right {
			if j != i {
				newRight = append(newRight, other)
			}
		}
		s.permutations(c, size, newLeft, newRight)
	}
}

// Product returns cortesian product of elements
// {{1, 2}, {3, 4}} -> {1, 3}, {1, 4}, {2, 3}, {2, 4}
func (s SliceString) Product(repeat int) chan []string {
	c := make(chan []string, 1)
	go s.product(c, repeat, []string{}, 0)
	return c
}

// product is a core implementation for Product
func (s SliceString) product(c chan []string, repeat int, left []string, pos int) {
	// iterate over the last array
	if pos == repeat-1 {
		for _, el := range s.Data {
			result := make([]string, 0, len(left)+1)
			result = append(result, left...)
			result = append(result, el)
			c <- result
		}
		return
	}

	for _, el := range s.Data {
		result := make([]string, 0, len(left)+1)
		result = append(result, left...)
		result = append(result, el)
		s.product(c, repeat, result, pos+1)
	}

	if pos == 0 {
		close(c)
	}
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceString) ReduceBool(acc bool, f func(el string, acc bool) bool) bool {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceString) ReduceByte(acc byte, f func(el string, acc byte) byte) byte {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceString) ReduceString(acc string, f func(el string, acc string) string) string {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceString) ReduceFloat32(acc float32, f func(el string, acc float32) float32) float32 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceString) ReduceFloat64(acc float64, f func(el string, acc float64) float64) float64 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceString) ReduceInt(acc int, f func(el string, acc int) int) int {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceString) ReduceInt8(acc int8, f func(el string, acc int8) int8) int8 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceString) ReduceInt16(acc int16, f func(el string, acc int16) int16) int16 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceString) ReduceInt32(acc int32, f func(el string, acc int32) int32) int32 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceString) ReduceInt64(acc int64, f func(el string, acc int64) int64) int64 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceString) ReduceUint(acc uint, f func(el string, acc uint) uint) uint {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceString) ReduceUint8(acc uint8, f func(el string, acc uint8) uint8) uint8 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceString) ReduceUint16(acc uint16, f func(el string, acc uint16) uint16) uint16 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceString) ReduceUint32(acc uint32, f func(el string, acc uint32) uint32) uint32 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceString) ReduceUint64(acc uint64, f func(el string, acc uint64) uint64) uint64 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceString) ReduceInterface(acc interface{}, f func(el string, acc interface{}) interface{}) interface{} {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceString) ReduceWhileBool(acc bool, f func(el string, acc bool) (bool, error)) (bool, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceString) ReduceWhileByte(acc byte, f func(el string, acc byte) (byte, error)) (byte, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceString) ReduceWhileString(acc string, f func(el string, acc string) (string, error)) (string, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceString) ReduceWhileFloat32(acc float32, f func(el string, acc float32) (float32, error)) (float32, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceString) ReduceWhileFloat64(acc float64, f func(el string, acc float64) (float64, error)) (float64, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceString) ReduceWhileInt(acc int, f func(el string, acc int) (int, error)) (int, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceString) ReduceWhileInt8(acc int8, f func(el string, acc int8) (int8, error)) (int8, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceString) ReduceWhileInt16(acc int16, f func(el string, acc int16) (int16, error)) (int16, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceString) ReduceWhileInt32(acc int32, f func(el string, acc int32) (int32, error)) (int32, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceString) ReduceWhileInt64(acc int64, f func(el string, acc int64) (int64, error)) (int64, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceString) ReduceWhileUint(acc uint, f func(el string, acc uint) (uint, error)) (uint, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceString) ReduceWhileUint8(acc uint8, f func(el string, acc uint8) (uint8, error)) (uint8, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceString) ReduceWhileUint16(acc uint16, f func(el string, acc uint16) (uint16, error)) (uint16, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceString) ReduceWhileUint32(acc uint32, f func(el string, acc uint32) (uint32, error)) (uint32, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceString) ReduceWhileUint64(acc uint64, f func(el string, acc uint64) (uint64, error)) (uint64, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceString) ReduceWhileInterface(acc interface{}, f func(el string, acc interface{}) (interface{}, error)) (interface{}, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// Reverse returns given arr in reversed order
func (s SliceString) Reverse() []string {
	if len(s.Data) <= 1 {
		return s.Data
	}
	result := make([]string, 0, len(s.Data))
	for i := len(s.Data) - 1; i >= 0; i-- {
		result = append(result, s.Data[i])
	}
	return result
}

// Same returns true if all element in arr the same
func (s SliceString) Same() bool {
	if len(s.Data) <= 1 {
		return true
	}
	for i := 0; i < len(s.Data)-1; i++ {
		if s.Data[i] != s.Data[i+1] {
			return false
		}
	}
	return true
}

// Scan is like Reduce, but returns slice of f results
func (s SliceString) ScanBool(acc bool, f func(el string, acc bool) bool) []bool {
	result := make([]bool, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceString) ScanByte(acc byte, f func(el string, acc byte) byte) []byte {
	result := make([]byte, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceString) ScanString(acc string, f func(el string, acc string) string) []string {
	result := make([]string, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceString) ScanFloat32(acc float32, f func(el string, acc float32) float32) []float32 {
	result := make([]float32, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceString) ScanFloat64(acc float64, f func(el string, acc float64) float64) []float64 {
	result := make([]float64, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceString) ScanInt(acc int, f func(el string, acc int) int) []int {
	result := make([]int, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceString) ScanInt8(acc int8, f func(el string, acc int8) int8) []int8 {
	result := make([]int8, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceString) ScanInt16(acc int16, f func(el string, acc int16) int16) []int16 {
	result := make([]int16, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceString) ScanInt32(acc int32, f func(el string, acc int32) int32) []int32 {
	result := make([]int32, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceString) ScanInt64(acc int64, f func(el string, acc int64) int64) []int64 {
	result := make([]int64, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceString) ScanUint(acc uint, f func(el string, acc uint) uint) []uint {
	result := make([]uint, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceString) ScanUint8(acc uint8, f func(el string, acc uint8) uint8) []uint8 {
	result := make([]uint8, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceString) ScanUint16(acc uint16, f func(el string, acc uint16) uint16) []uint16 {
	result := make([]uint16, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceString) ScanUint32(acc uint32, f func(el string, acc uint32) uint32) []uint32 {
	result := make([]uint32, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceString) ScanUint64(acc uint64, f func(el string, acc uint64) uint64) []uint64 {
	result := make([]uint64, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceString) ScanInterface(acc interface{}, f func(el string, acc interface{}) interface{}) []interface{} {
	result := make([]interface{}, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Shuffle in random order arr elements
func (s SliceString) Shuffle() []string {
	if len(s.Data) <= 1 {
		return s.Data
	}
	rand.Seed(time.Now().UnixNano())
	swap := func(i, j int) {
		s.Data[i], s.Data[j] = s.Data[j], s.Data[i]
	}
	rand.Shuffle(len(s.Data), swap)
	return s.Data
}

// Sort returns sorted slice
func (s SliceString) Sort() []string {
	if len(s.Data) <= 1 {
		return s.Data
	}
	less := func(i int, j int) bool {
		return s.Data[i] < s.Data[j]
	}
	sort.SliceStable(s.Data, less)
	return s.Data
}

// Sorted returns true if slice is sorted
func (s SliceString) Sorted() bool {
	if len(s.Data) <= 1 {
		return true
	}
	for i := 1; i < len(s.Data); i++ {
		if s.Data[i-1] > s.Data[i] {
			return false
		}
	}
	return true
}

// Split splits arr by sep
func (s SliceString) Split(sep string) [][]string {
	result := make([][]string, 0)
	curr := make([]string, 0)
	for _, el := range s.Data {
		if el == sep {
			result = append(result, curr)
		} else {
			curr = append(curr, el)
		}
	}
	result = append(result, curr)
	return result
}

// StartsWith returns true if slice starts with the given prefix slice.
// If prefix is empty, it returns true.
func (s SliceString) StartsWith(prefix []string) bool {
	if len(prefix) > len(s.Data) {
		return false
	}
	for i, el := range prefix {
		if el != s.Data[i] {
			return false
		}
	}
	return true
}

// Sum return sum of all elements from arr
func (s SliceString) Sum() string {
	var sum string
	for _, el := range s.Data {
		sum += el
	}
	return sum
}

// TakeEvery returns slice of every nth elements
func (s SliceString) TakeEvery(nth int) ([]string, error) {
	if nth <= 0 {
		return s.Data, ErrNonPositiveValue
	}
	result := make([]string, 0, len(s.Data))
	for i, el := range s.Data {
		if (i+1)%nth == 0 {
			result = append(result, el)
		}
	}
	return result, nil
}

// TakeRandom returns slice of count random elements from the slice
func (s SliceString) TakeRandom(count int) ([]string, error) {
	if count > len(s.Data) {
		return nil, ErrOutOfRange
	}
	if count <= 0 {
		return nil, ErrNonPositiveValue
	}

	rand.Seed(time.Now().UnixNano())
	swap := func(i, j int) {
		s.Data[i], s.Data[j] = s.Data[j], s.Data[i]
	}
	rand.Shuffle(len(s.Data), swap)
	return s.Data[:count], nil
}

// TakeWhile takes elements from arr while f returns true
func (s SliceString) TakeWhile(f func(el string) bool) []string {
	result := make([]string, 0, len(s.Data))
	for _, el := range s.Data {
		if !f(el) {
			return result
		}
		result = append(result, el)
	}
	return result
}

// ToChannel returns channel with elements from the slice
func (s SliceString) ToChannel() chan string {
	c := make(chan string, 1)
	go func() {
		for _, el := range s.Data {
			c <- el
		}
		close(c)
	}()
	return c
}

// Uniq returns arr with only first occurences of every element.
func (s SliceString) Uniq() []string {
	if len(s.Data) <= 1 {
		return s.Data
	}
	added := make(map[string]struct{})
	nothing := struct{}{}
	result := make([]string, 0, len(s.Data))
	for _, el := range s.Data {
		_, exists := added[el]
		if !exists {
			result = append(result, el)
			added[el] = nothing
		}
	}
	return result

}

// Window makes sliding window for a given slice:
// ({1,2,3}, 2) -> (1,2), (2,3)
func (s SliceString) Window(size int) ([][]string, error) {
	if size <= 0 {
		return nil, ErrNonPositiveValue
	}
	result := make([][]string, 0, len(s.Data)/size)
	for i := 0; i <= len(s.Data)-size; i++ {
		chunk := s.Data[i : i+size]
		result = append(result, chunk)
	}
	return result, nil
}

// Without returns the slice with filtered out element
func (s SliceString) Without(elements ...string) []string {
	result := make([]string, 0, len(s.Data))
	for _, el := range s.Data {
		allowed := true
		for _, other := range elements {
			if el == other {
				allowed = false
			}
		}
		if allowed {
			result = append(result, el)
		}
	}
	return result
}

// Concat concatenates given slices into a single slice.
func (s SlicesString) Concat() []string {
	result := make([]string, 0)
	for _, arr := range s.Data {
		result = append(result, arr...)
	}
	return result
}

// Product returns cortesian product of elements
// {{1, 2}, {3, 4}} -> {1, 3}, {1, 4}, {2, 3}, {2, 4}
func (s SlicesString) Product() chan []string {
	c := make(chan []string, 1)
	go s.product(c, []string{}, 0)
	return c
}

// product is a core implementation of Product
func (s SlicesString) product(c chan []string, left []string, pos int) {
	// iterate over the last array
	if pos == len(s.Data)-1 {
		for _, el := range s.Data[pos] {
			result := make([]string, 0, len(left)+1)
			result = append(result, left...)
			result = append(result, el)
			c <- result
		}
		return
	}

	for _, el := range s.Data[pos] {
		result := make([]string, 0, len(left)+1)
		result = append(result, left...)
		result = append(result, el)
		s.product(c, result, pos+1)
	}

	if pos == 0 {
		close(c)
	}
}

// Zip returns array of arrays of elements from given arrs
// on the same position
func (s SlicesString) Zip() [][]string {
	size := len(s.Data[0])
	for _, arr := range s.Data[1:] {
		if len(arr) > size {
			size = len(arr)
		}
	}

	result := make([][]string, 0, size)
	for i := 0; i <= size; i++ {
		chunk := make([]string, 0, len(s.Data))
		for _, arr := range s.Data {
			chunk = append(chunk, arr[i])
		}
		result = append(result, chunk)
	}
	return result
}

// Channel is a set of operations with channel
type ChannelFloat32 struct {
	Data chan float32
}

// AsyncSlice is a set of operations to work with slice asynchronously
type AsyncSliceFloat32 struct {
	Data    []float32
	Workers int
}

// Sequence is a set of operations to generate sequences
type SequenceFloat32 struct {
	ctx context.Context
}

// Pair is a set of functions for 2 values that you can pass into reduce-like funcs
type PairFloat32 struct {
	// empty
}

// Slice is a set of operations to work with slice
type SliceFloat32 struct {
	Data []float32
}

// Slices is a set of operations to work with slice of slices
type SlicesFloat32 struct {
	Data [][]float32
}

// Any returns true if f returns true for any element in channel
func (c ChannelFloat32) Any(f func(el float32) bool) bool {
	for el := range c.Data {
		if f(el) {
			return true
		}
	}
	return false
}

// All returns true if f returns true for all elements in channel
func (c ChannelFloat32) All(f func(el float32) bool) bool {
	for el := range c.Data {
		if !f(el) {
			return false
		}
	}
	return true
}

// ChunkEvery returns channel with slices containing count elements each
func (c ChannelFloat32) ChunkEvery(count int) chan []float32 {
	chunks := make(chan []float32, 1)
	go func() {
		chunk := make([]float32, 0, count)
		i := 0
		for el := range c.Data {
			chunk = append(chunk, el)
			i++
			if i%count == 0 {
				i = 0
				chunks <- chunk
				chunk = make([]float32, 0, count)
			}
		}
		if len(chunk) > 0 {
			chunks <- chunk
		}
		close(chunks)
	}()
	return chunks
}

// Count return count of el occurences in channel.
func (c ChannelFloat32) Count(el float32) int {
	count := 0
	for val := range c.Data {
		if val == el {
			count++
		}
	}
	return count
}

// Drop drops first n elements from channel c and returns a new channel with the rest.
// It returns channel do be unblocking. If you want array instead, wrap result into TakeAll.
func (c ChannelFloat32) Drop(n int) chan float32 {
	result := make(chan float32, 1)
	go func() {
		i := 0
		for el := range c.Data {
			if i >= n {
				result <- el
			}
			i++
		}
		close(result)
	}()
	return result
}

// Each calls f for every element in the channel
func (c ChannelFloat32) Each(f func(el float32)) {
	for el := range c.Data {
		f(el)
	}
}

// Filter returns a new channel with elements from input channel
// for which f returns true
func (c ChannelFloat32) Filter(f func(el float32) bool) chan float32 {
	result := make(chan float32, 1)
	go func() {
		for el := range c.Data {
			if f(el) {
				result <- el
			}
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelFloat32) MapBool(f func(el float32) bool) chan bool {
	result := make(chan bool, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelFloat32) MapByte(f func(el float32) byte) chan byte {
	result := make(chan byte, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelFloat32) MapString(f func(el float32) string) chan string {
	result := make(chan string, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelFloat32) MapFloat32(f func(el float32) float32) chan float32 {
	result := make(chan float32, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelFloat32) MapFloat64(f func(el float32) float64) chan float64 {
	result := make(chan float64, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelFloat32) MapInt(f func(el float32) int) chan int {
	result := make(chan int, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelFloat32) MapInt8(f func(el float32) int8) chan int8 {
	result := make(chan int8, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelFloat32) MapInt16(f func(el float32) int16) chan int16 {
	result := make(chan int16, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelFloat32) MapInt32(f func(el float32) int32) chan int32 {
	result := make(chan int32, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelFloat32) MapInt64(f func(el float32) int64) chan int64 {
	result := make(chan int64, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelFloat32) MapUint(f func(el float32) uint) chan uint {
	result := make(chan uint, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelFloat32) MapUint8(f func(el float32) uint8) chan uint8 {
	result := make(chan uint8, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelFloat32) MapUint16(f func(el float32) uint16) chan uint16 {
	result := make(chan uint16, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelFloat32) MapUint32(f func(el float32) uint32) chan uint32 {
	result := make(chan uint32, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelFloat32) MapUint64(f func(el float32) uint64) chan uint64 {
	result := make(chan uint64, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelFloat32) MapInterface(f func(el float32) interface{}) chan interface{} {
	result := make(chan interface{}, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Max returns the maximal element from channel
func (c ChannelFloat32) Max() (float32, error) {
	max, ok := <-c.Data
	if !ok {
		return max, ErrEmpty
	}
	for el := range c.Data {
		if el > max {
			max = el
		}
	}
	return max, nil
}

// Min returns the minimal element from channel
func (c ChannelFloat32) Min() (float32, error) {
	min, ok := <-c.Data
	if !ok {
		return min, ErrEmpty
	}
	for el := range c.Data {
		if el < min {
			min = el
		}
	}
	return min, nil
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelFloat32) ReduceBool(acc bool, f func(el float32, acc bool) bool) bool {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelFloat32) ReduceByte(acc byte, f func(el float32, acc byte) byte) byte {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelFloat32) ReduceString(acc string, f func(el float32, acc string) string) string {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelFloat32) ReduceFloat32(acc float32, f func(el float32, acc float32) float32) float32 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelFloat32) ReduceFloat64(acc float64, f func(el float32, acc float64) float64) float64 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelFloat32) ReduceInt(acc int, f func(el float32, acc int) int) int {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelFloat32) ReduceInt8(acc int8, f func(el float32, acc int8) int8) int8 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelFloat32) ReduceInt16(acc int16, f func(el float32, acc int16) int16) int16 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelFloat32) ReduceInt32(acc int32, f func(el float32, acc int32) int32) int32 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelFloat32) ReduceInt64(acc int64, f func(el float32, acc int64) int64) int64 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelFloat32) ReduceUint(acc uint, f func(el float32, acc uint) uint) uint {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelFloat32) ReduceUint8(acc uint8, f func(el float32, acc uint8) uint8) uint8 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelFloat32) ReduceUint16(acc uint16, f func(el float32, acc uint16) uint16) uint16 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelFloat32) ReduceUint32(acc uint32, f func(el float32, acc uint32) uint32) uint32 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelFloat32) ReduceUint64(acc uint64, f func(el float32, acc uint64) uint64) uint64 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelFloat32) ReduceInterface(acc interface{}, f func(el float32, acc interface{}) interface{}) interface{} {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelFloat32) ScanBool(acc bool, f func(el float32, acc bool) bool) chan bool {
	result := make(chan bool, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelFloat32) ScanByte(acc byte, f func(el float32, acc byte) byte) chan byte {
	result := make(chan byte, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelFloat32) ScanString(acc string, f func(el float32, acc string) string) chan string {
	result := make(chan string, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelFloat32) ScanFloat32(acc float32, f func(el float32, acc float32) float32) chan float32 {
	result := make(chan float32, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelFloat32) ScanFloat64(acc float64, f func(el float32, acc float64) float64) chan float64 {
	result := make(chan float64, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelFloat32) ScanInt(acc int, f func(el float32, acc int) int) chan int {
	result := make(chan int, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelFloat32) ScanInt8(acc int8, f func(el float32, acc int8) int8) chan int8 {
	result := make(chan int8, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelFloat32) ScanInt16(acc int16, f func(el float32, acc int16) int16) chan int16 {
	result := make(chan int16, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelFloat32) ScanInt32(acc int32, f func(el float32, acc int32) int32) chan int32 {
	result := make(chan int32, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelFloat32) ScanInt64(acc int64, f func(el float32, acc int64) int64) chan int64 {
	result := make(chan int64, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelFloat32) ScanUint(acc uint, f func(el float32, acc uint) uint) chan uint {
	result := make(chan uint, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelFloat32) ScanUint8(acc uint8, f func(el float32, acc uint8) uint8) chan uint8 {
	result := make(chan uint8, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelFloat32) ScanUint16(acc uint16, f func(el float32, acc uint16) uint16) chan uint16 {
	result := make(chan uint16, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelFloat32) ScanUint32(acc uint32, f func(el float32, acc uint32) uint32) chan uint32 {
	result := make(chan uint32, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelFloat32) ScanUint64(acc uint64, f func(el float32, acc uint64) uint64) chan uint64 {
	result := make(chan uint64, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelFloat32) ScanInterface(acc interface{}, f func(el float32, acc interface{}) interface{}) chan interface{} {
	result := make(chan interface{}, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Sum returns sum of all elements from channel
func (c ChannelFloat32) Sum() float32 {
	var sum float32
	for el := range c.Data {
		sum += el
	}
	return sum
}

// Take takes first count elements from the channel.
func (c ChannelFloat32) Take(count int) chan float32 {
	result := make(chan float32, 1)
	go func() {
		defer close(result)
		if count <= 0 {
			return
		}
		i := 0
		for el := range c.Data {
			result <- el
			i++
			if i == count {
				return
			}
		}
	}()
	return result
}

// Tee returns 2 channels with elements from the input channel
func (c ChannelFloat32) Tee(count int) []chan float32 {
	channels := make([]chan float32, 0, count)
	for i := 0; i < count; i++ {
		channels = append(channels, make(chan float32, 1))
	}
	go func() {
		for el := range c.Data {
			wg := sync.WaitGroup{}
			putInto := func(ch chan float32) {
				defer wg.Done()
				ch <- el
			}
			wg.Add(count)
			for _, ch := range channels {
				putInto(ch)
			}
			wg.Wait()
		}
		for _, ch := range channels {
			close(ch)
		}
	}()
	return channels
}

// ToSlice returns slice with all elements from channel.
func (c ChannelFloat32) ToSlice() []float32 {
	result := make([]float32, 0)
	for val := range c.Data {
		result = append(result, val)
	}
	return result
}

// All returns true if f returns true for all elements in slice
func (s AsyncSliceFloat32) All(f func(el float32) bool) bool {
	if len(s.Data) == 0 {
		return true
	}

	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int, result chan<- bool, ctx context.Context) {
		defer wg.Done()
		for {
			select {
			case <-ctx.Done():
				return
			case index, ok := <-jobs:
				if !ok {
					return
				}
				if !f(s.Data[index]) {
					result <- false
					return
				}
			}
		}
	}

	ctx, cancel := context.WithCancel(context.Background())
	// when we're returning the result, cancel all workers
	defer cancel()

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	result := make(chan bool, workers)
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs, result, ctx)
	}

	// close the result channel when all workers have done
	go func() {
		wg.Wait()
		close(result)
	}()

	// schedule the jobs: indices to check
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)

	for range result {
		return false
	}
	return true
}

// Any returns true if f returns true for any element from slice
func (s AsyncSliceFloat32) Any(f func(el float32) bool) bool {
	if len(s.Data) == 0 {
		return false
	}

	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int, result chan<- bool, ctx context.Context) {
		defer wg.Done()
		for {
			select {
			case <-ctx.Done():
				return
			case index, ok := <-jobs:
				if !ok {
					return
				}
				if f(s.Data[index]) {
					result <- true
					return
				}
			}
		}
	}

	ctx, cancel := context.WithCancel(context.Background())
	// when we're returning the result, cancel all workers
	defer cancel()

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	result := make(chan bool, workers)
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs, result, ctx)
	}

	// close the result channel when all workers have done
	go func() {
		wg.Wait()
		close(result)
	}()

	// schedule the jobs: indices to check
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)

	for range result {
		return true
	}
	return false
}

// Each calls f for every element from slice
func (s AsyncSliceFloat32) Each(f func(el float32)) {
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		defer wg.Done()
		for index := range jobs {
			f(s.Data[index])
		}
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
}

// Filter returns slice of element for which f returns true
func (s AsyncSliceFloat32) Filter(f func(el float32) bool) []float32 {
	resultMap := make([]bool, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			if f(s.Data[index]) {
				resultMap[index] = true
			}
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()

	// return filtered results
	result := make([]float32, 0, len(s.Data))
	for i, el := range s.Data {
		if resultMap[i] {
			result = append(result, el)
		}
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceFloat32) MapBool(f func(el float32) bool) []bool {
	result := make([]bool, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceFloat32) MapByte(f func(el float32) byte) []byte {
	result := make([]byte, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceFloat32) MapString(f func(el float32) string) []string {
	result := make([]string, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceFloat32) MapFloat32(f func(el float32) float32) []float32 {
	result := make([]float32, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceFloat32) MapFloat64(f func(el float32) float64) []float64 {
	result := make([]float64, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceFloat32) MapInt(f func(el float32) int) []int {
	result := make([]int, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceFloat32) MapInt8(f func(el float32) int8) []int8 {
	result := make([]int8, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceFloat32) MapInt16(f func(el float32) int16) []int16 {
	result := make([]int16, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceFloat32) MapInt32(f func(el float32) int32) []int32 {
	result := make([]int32, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceFloat32) MapInt64(f func(el float32) int64) []int64 {
	result := make([]int64, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceFloat32) MapUint(f func(el float32) uint) []uint {
	result := make([]uint, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceFloat32) MapUint8(f func(el float32) uint8) []uint8 {
	result := make([]uint8, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceFloat32) MapUint16(f func(el float32) uint16) []uint16 {
	result := make([]uint16, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceFloat32) MapUint32(f func(el float32) uint32) []uint32 {
	result := make([]uint32, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceFloat32) MapUint64(f func(el float32) uint64) []uint64 {
	result := make([]uint64, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceFloat32) MapInterface(f func(el float32) interface{}) []interface{} {
	result := make([]interface{}, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Reduce reduces slice to a single value with f
func (s AsyncSliceFloat32) Reduce(f func(left float32, right float32) float32) float32 {
	if len(s.Data) == 0 {
		var tmp float32
		return tmp
	}

	state := make([]float32, len(s.Data))
	state = append(state, s.Data...)
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int, result chan<- float32) {
		for index := range jobs {
			result <- f(state[index], state[index+1])
		}
		wg.Done()
	}

	for len(state) > 1 {
		// calculate workers count
		workers := s.Workers
		if workers == 0 || workers > len(state) {
			workers = len(state)
		}

		// run workers
		jobs := make(chan int, len(state))
		wg.Add(workers)
		result := make(chan float32, 1)
		for i := 0; i < workers; i++ {
			go worker(jobs, result)
		}

		go func() {
			wg.Wait()
			close(result)
		}()

		// add indices into jobs for workers
		for i := 0; i < len(state)-1; i += 2 {
			jobs <- i
		}
		close(jobs)

		// collect new state
		newState := make([]float32, 0, len(state)/2+len(state)%2)
		for el := range result {
			newState = append(newState, el)
		}
		if len(state)%2 == 1 {
			newState = append(newState, state[len(state)-1])
		}
		// put new state as current state after all
		state = newState
	}

	return state[0]
}

// Count is like Range, but infinite
func (s SequenceFloat32) Count(start float32, step float32) chan float32 {
	c := make(chan float32, 1)
	go func() {
		defer close(c)
		for {
			select {
			case <-s.ctx.Done():
				return
			case c <- start:
				start += step
			}
		}
	}()
	return c
}

// Exponential generates elements from start with
// multiplication of value on factor on every step
func (s SequenceFloat32) Exponential(start float32, factor float32) chan float32 {
	c := make(chan float32, 1)
	go func() {
		defer close(c)
		for {
			select {
			case <-s.ctx.Done():
				return
			case c <- start:
				start *= factor
			}
		}
	}()
	return c
}

// Iterate returns an infinite list of repeated applications of f to val
func (s SequenceFloat32) Iterate(val float32, f func(val float32) float32) chan float32 {
	c := make(chan float32, 1)
	go func() {
		defer close(c)
		for {
			select {
			case <-s.ctx.Done():
				return
			case c <- val:
				val = f(val)
			}
		}
	}()
	return c
}

// Range generates elements from start to end with given step
func (s SequenceFloat32) Range(start float32, end float32, step float32) chan float32 {
	c := make(chan float32, 1)
	pos := start <= end
	go func() {
		for pos && (start < end) || !pos && (start > end) {
			c <- start
			start += step
		}
		close(c)
	}()
	return c
}

// Repeat returns channel that produces val infinite times
func (s SequenceFloat32) Repeat(val float32) chan float32 {
	c := make(chan float32, 1)
	go func() {
		defer close(c)
		for {
			select {
			case <-s.ctx.Done():
				return
			case c <- val:
				continue
			}
		}
	}()
	return c
}

// Replicate returns channel that produces val n times
func (s SequenceFloat32) Replicate(val float32, n int) chan float32 {
	c := make(chan float32, 1)
	go func() {
		for i := 0; i < n; i++ {
			c <- val
		}
		close(c)
	}()
	return c
}

// Min returns minimal value
func (PairFloat32) Min(a float32, b float32) float32 {
	if a <= b {
		return a
	}
	return b
}

// Max returns maximal value
func (PairFloat32) Max(a float32, b float32) float32 {
	if a > b {
		return a
	}
	return b
}

// Any returns true if f returns true for any element in arr
func (s SliceFloat32) Any(f func(el float32) bool) bool {
	for _, el := range s.Data {
		if f(el) {
			return true
		}
	}
	return false
}

// All returns true if f returns true for all elements in arr
func (s SliceFloat32) All(f func(el float32) bool) bool {
	for _, el := range s.Data {
		if !f(el) {
			return false
		}
	}
	return true
}

// Choice chooses a random element from the slice
func (s SliceFloat32) Choice() (float32, error) {
	if len(s.Data) == 0 {
		var tmp float32
		return tmp, ErrEmpty
	}

	rand.Seed(time.Now().UnixNano())
	i := rand.Intn(len(s.Data))
	return s.Data[i], nil
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceFloat32) ChunkByBool(f func(el float32) bool) [][]float32 {
	chunks := make([][]float32, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]float32, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]float32, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceFloat32) ChunkByByte(f func(el float32) byte) [][]float32 {
	chunks := make([][]float32, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]float32, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]float32, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceFloat32) ChunkByString(f func(el float32) string) [][]float32 {
	chunks := make([][]float32, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]float32, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]float32, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceFloat32) ChunkByFloat32(f func(el float32) float32) [][]float32 {
	chunks := make([][]float32, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]float32, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]float32, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceFloat32) ChunkByFloat64(f func(el float32) float64) [][]float32 {
	chunks := make([][]float32, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]float32, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]float32, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceFloat32) ChunkByInt(f func(el float32) int) [][]float32 {
	chunks := make([][]float32, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]float32, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]float32, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceFloat32) ChunkByInt8(f func(el float32) int8) [][]float32 {
	chunks := make([][]float32, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]float32, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]float32, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceFloat32) ChunkByInt16(f func(el float32) int16) [][]float32 {
	chunks := make([][]float32, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]float32, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]float32, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceFloat32) ChunkByInt32(f func(el float32) int32) [][]float32 {
	chunks := make([][]float32, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]float32, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]float32, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceFloat32) ChunkByInt64(f func(el float32) int64) [][]float32 {
	chunks := make([][]float32, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]float32, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]float32, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceFloat32) ChunkByUint(f func(el float32) uint) [][]float32 {
	chunks := make([][]float32, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]float32, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]float32, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceFloat32) ChunkByUint8(f func(el float32) uint8) [][]float32 {
	chunks := make([][]float32, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]float32, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]float32, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceFloat32) ChunkByUint16(f func(el float32) uint16) [][]float32 {
	chunks := make([][]float32, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]float32, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]float32, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceFloat32) ChunkByUint32(f func(el float32) uint32) [][]float32 {
	chunks := make([][]float32, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]float32, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]float32, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceFloat32) ChunkByUint64(f func(el float32) uint64) [][]float32 {
	chunks := make([][]float32, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]float32, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]float32, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceFloat32) ChunkByInterface(f func(el float32) interface{}) [][]float32 {
	chunks := make([][]float32, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]float32, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]float32, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkEvery returns slice of slices containing count elements each
func (s SliceFloat32) ChunkEvery(count int) ([][]float32, error) {
	chunks := make([][]float32, 0)
	if count <= 0 {
		return chunks, ErrNegativeValue
	}
	chunk := make([]float32, 0, count)
	for i, el := range s.Data {
		chunk = append(chunk, el)
		if (i+1)%count == 0 {
			chunks = append(chunks, chunk)
			chunk = make([]float32, 0, count)
		}
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks, nil
}

// Contains returns true if el in arr.
func (s SliceFloat32) Contains(el float32) bool {
	for _, val := range s.Data {
		if val == el {
			return true
		}
	}
	return false
}

// Count return count of el occurences in arr.
func (s SliceFloat32) Count(el float32) int {
	count := 0
	for _, val := range s.Data {
		if val == el {
			count++
		}
	}
	return count
}

// CountBy returns how many times f returns true.
func (s SliceFloat32) CountBy(f func(el float32) bool) int {
	count := 0
	for _, el := range s.Data {
		if f(el) {
			count++
		}
	}
	return count
}

// Cycle is an infinite loop over slice
func (s SliceFloat32) Cycle() chan float32 {
	c := make(chan float32, 1)
	go func() {
		defer close(c)
		if len(s.Data) == 0 {
			return
		}
		for {
			for _, val := range s.Data {
				c <- val
			}
		}
	}()
	return c
}

// Dedup returns a given slice without consecutive duplicated elements
func (s SliceFloat32) Dedup() []float32 {
	if len(s.Data) == 0 {
		return s.Data
	}

	result := make([]float32, 0, len(s.Data))
	prev := s.Data[0]
	result = append(result, prev)
	for _, el := range s.Data[1:] {
		if el != prev {
			result = append(result, el)
			prev = el
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceFloat32) DedupByBool(f func(el float32) bool) []float32 {
	result := make([]float32, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceFloat32) DedupByByte(f func(el float32) byte) []float32 {
	result := make([]float32, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceFloat32) DedupByString(f func(el float32) string) []float32 {
	result := make([]float32, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceFloat32) DedupByFloat32(f func(el float32) float32) []float32 {
	result := make([]float32, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceFloat32) DedupByFloat64(f func(el float32) float64) []float32 {
	result := make([]float32, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceFloat32) DedupByInt(f func(el float32) int) []float32 {
	result := make([]float32, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceFloat32) DedupByInt8(f func(el float32) int8) []float32 {
	result := make([]float32, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceFloat32) DedupByInt16(f func(el float32) int16) []float32 {
	result := make([]float32, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceFloat32) DedupByInt32(f func(el float32) int32) []float32 {
	result := make([]float32, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceFloat32) DedupByInt64(f func(el float32) int64) []float32 {
	result := make([]float32, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceFloat32) DedupByUint(f func(el float32) uint) []float32 {
	result := make([]float32, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceFloat32) DedupByUint8(f func(el float32) uint8) []float32 {
	result := make([]float32, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceFloat32) DedupByUint16(f func(el float32) uint16) []float32 {
	result := make([]float32, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceFloat32) DedupByUint32(f func(el float32) uint32) []float32 {
	result := make([]float32, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceFloat32) DedupByUint64(f func(el float32) uint64) []float32 {
	result := make([]float32, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceFloat32) DedupByInterface(f func(el float32) interface{}) []float32 {
	result := make([]float32, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// Delete deletes the first occurence of the element from the slice
func (s SliceFloat32) Delete(element float32) []float32 {
	result := make([]float32, 0, len(s.Data)-1)
	deleted := false
	for _, el := range s.Data {
		if !deleted && el == element {
			continue
		}
		result = append(result, el)
	}
	return result

}

// DeleteAt returns the slice without elements on given positions
func (s SliceFloat32) DeleteAt(index int) ([]float32, error) {
	if index >= len(s.Data) {
		return s.Data, ErrOutOfRange
	}

	result := make([]float32, 0, len(s.Data)-1)
	for i, el := range s.Data {
		if i != index {
			result = append(result, el)
		}
	}
	return result, nil
}

// DropEvery returns a slice of every nth element in the enumerable dropped,
// starting with the first element.
func (s SliceFloat32) DropEvery(nth int) ([]float32, error) {
	if nth <= 0 {
		return s.Data, ErrNonPositiveValue
	}
	result := make([]float32, 0, len(s.Data)/nth)
	for i, el := range s.Data {
		if (i+1)%nth != 0 {
			result = append(result, el)
		}
	}
	return result, nil
}

// DropWhile drops elements from arr while f returns true
func (s SliceFloat32) DropWhile(f func(arr float32) bool) []float32 {
	result := make([]float32, 0, len(s.Data))
	for _, el := range s.Data {
		if !f(el) {
			return result
		}
		result = append(result, el)
	}
	return result
}

// Each calls f for every element from arr
func (s SliceFloat32) Each(f func(el float32)) {
	for _, el := range s.Data {
		f(el)
	}
}

// Equal returns true if slices are equal
func (s SliceFloat32) Equal(other []float32) bool {
	if len(s.Data) != len(other) {
		return false
	}
	for i, el := range other {
		if s.Data[i] != el {
			return false
		}
	}
	return true
}

// Filter returns slice of T for which F returned true
func (s SliceFloat32) Filter(f func(el float32) bool) []float32 {
	result := make([]float32, 0, len(s.Data))
	for _, el := range s.Data {
		if f(el) {
			result = append(result, el)
		}
	}
	return result
}

// Find returns the first element for which f returns true
func (s SliceFloat32) Find(f func(el float32) bool) (float32, error) {
	for _, el := range s.Data {
		if f(el) {
			return el, nil
		}
	}
	var tmp float32
	return tmp, ErrNotFound
}

// FindIndex is like Find, but return element index instead of element itself
func (s SliceFloat32) FindIndex(f func(el float32) bool) (int, error) {
	for i, el := range s.Data {
		if f(el) {
			return i, nil
		}
	}
	return 0, ErrNotFound
}

// GroupBy groups element from array by value returned by f
func (s SliceFloat32) GroupByBool(f func(el float32) bool) map[bool][]float32 {
	result := make(map[bool][]float32)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]float32, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceFloat32) GroupByByte(f func(el float32) byte) map[byte][]float32 {
	result := make(map[byte][]float32)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]float32, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceFloat32) GroupByString(f func(el float32) string) map[string][]float32 {
	result := make(map[string][]float32)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]float32, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceFloat32) GroupByFloat32(f func(el float32) float32) map[float32][]float32 {
	result := make(map[float32][]float32)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]float32, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceFloat32) GroupByFloat64(f func(el float32) float64) map[float64][]float32 {
	result := make(map[float64][]float32)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]float32, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceFloat32) GroupByInt(f func(el float32) int) map[int][]float32 {
	result := make(map[int][]float32)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]float32, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceFloat32) GroupByInt8(f func(el float32) int8) map[int8][]float32 {
	result := make(map[int8][]float32)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]float32, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceFloat32) GroupByInt16(f func(el float32) int16) map[int16][]float32 {
	result := make(map[int16][]float32)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]float32, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceFloat32) GroupByInt32(f func(el float32) int32) map[int32][]float32 {
	result := make(map[int32][]float32)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]float32, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceFloat32) GroupByInt64(f func(el float32) int64) map[int64][]float32 {
	result := make(map[int64][]float32)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]float32, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceFloat32) GroupByUint(f func(el float32) uint) map[uint][]float32 {
	result := make(map[uint][]float32)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]float32, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceFloat32) GroupByUint8(f func(el float32) uint8) map[uint8][]float32 {
	result := make(map[uint8][]float32)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]float32, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceFloat32) GroupByUint16(f func(el float32) uint16) map[uint16][]float32 {
	result := make(map[uint16][]float32)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]float32, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceFloat32) GroupByUint32(f func(el float32) uint32) map[uint32][]float32 {
	result := make(map[uint32][]float32)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]float32, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceFloat32) GroupByUint64(f func(el float32) uint64) map[uint64][]float32 {
	result := make(map[uint64][]float32)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]float32, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceFloat32) GroupByInterface(f func(el float32) interface{}) map[interface{}][]float32 {
	result := make(map[interface{}][]float32)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]float32, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// InsertAt returns the slice with element inserted at given index.
func (s SliceFloat32) InsertAt(index int, element float32) ([]float32, error) {
	result := make([]float32, 0, len(s.Data)+1)

	// insert at the end
	if index == len(s.Data) || index == -1 {
		result = append(result, s.Data...)
		result = append(result, element)
		return result, nil
	}

	if index > len(s.Data) {
		return s.Data, ErrOutOfRange
	}
	if index < 0 {
		return s.Data, ErrNegativeValue
	}

	for i, el := range s.Data {
		if i == index {
			result = append(result, element)
		}
		result = append(result, el)
	}
	return result, nil
}

// Intersperse inserts el between each element of arr
func (s SliceFloat32) Intersperse(el float32) []float32 {
	if len(s.Data) == 0 {
		return s.Data
	}
	result := make([]float32, 0, len(s.Data)*2-1)
	result = append(result, s.Data[0])
	for _, val := range s.Data[1:] {
		result = append(result, el, val)
	}
	return result
}

// Last returns the last element from the slice
func (s SliceFloat32) Last() (float32, error) {
	if len(s.Data) == 0 {
		var tmp float32
		return tmp, ErrEmpty
	}
	return s.Data[len(s.Data)-1], nil
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceFloat32) MapBool(f func(el float32) bool) []bool {
	result := make([]bool, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceFloat32) MapByte(f func(el float32) byte) []byte {
	result := make([]byte, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceFloat32) MapString(f func(el float32) string) []string {
	result := make([]string, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceFloat32) MapFloat32(f func(el float32) float32) []float32 {
	result := make([]float32, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceFloat32) MapFloat64(f func(el float32) float64) []float64 {
	result := make([]float64, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceFloat32) MapInt(f func(el float32) int) []int {
	result := make([]int, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceFloat32) MapInt8(f func(el float32) int8) []int8 {
	result := make([]int8, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceFloat32) MapInt16(f func(el float32) int16) []int16 {
	result := make([]int16, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceFloat32) MapInt32(f func(el float32) int32) []int32 {
	result := make([]int32, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceFloat32) MapInt64(f func(el float32) int64) []int64 {
	result := make([]int64, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceFloat32) MapUint(f func(el float32) uint) []uint {
	result := make([]uint, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceFloat32) MapUint8(f func(el float32) uint8) []uint8 {
	result := make([]uint8, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceFloat32) MapUint16(f func(el float32) uint16) []uint16 {
	result := make([]uint16, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceFloat32) MapUint32(f func(el float32) uint32) []uint32 {
	result := make([]uint32, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceFloat32) MapUint64(f func(el float32) uint64) []uint64 {
	result := make([]uint64, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceFloat32) MapInterface(f func(el float32) interface{}) []interface{} {
	result := make([]interface{}, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Max returns the maximal element from arr
func (s SliceFloat32) Max() (float32, error) {
	if len(s.Data) == 0 {
		var tmp float32
		return tmp, ErrEmpty
	}

	max := s.Data[0]
	for _, el := range s.Data[1:] {
		if el > max {
			max = el
		}
	}
	return max, nil
}

// Min returns the minimal element from arr
func (s SliceFloat32) Min() (float32, error) {
	if len(s.Data) == 0 {
		var tmp float32
		return tmp, ErrEmpty
	}

	min := s.Data[0]
	for _, el := range s.Data[1:] {
		if el < min {
			min = el
		}
	}
	return min, nil
}

// Permutations returns successive size-length permutations of elements from the slice.
// {1, 2, 3} -> {1, 2}, {1, 3}, {2, 1}, {2, 3}, {3, 1}, {3, 2}
func (s SliceFloat32) Permutations(size int) chan []float32 {
	c := make(chan []float32, 1)
	go func() {
		if len(s.Data) > 0 {
			s.permutations(c, size, []float32{}, s.Data)
		}
		close(c)
	}()
	return c
}

// permutations is a core implementation for Permutations
func (s SliceFloat32) permutations(c chan []float32, size int, left []float32, right []float32) {
	if len(left) == size || len(right) == 0 {
		c <- left
		return
	}

	for i, el := range right {
		newLeft := make([]float32, 0, len(left)+1)
		newLeft = append(newLeft, left...)
		newLeft = append(newLeft, el)

		newRight := make([]float32, 0, len(right)-1)
		for j, other := range right {
			if j != i {
				newRight = append(newRight, other)
			}
		}
		s.permutations(c, size, newLeft, newRight)
	}
}

// Product returns cortesian product of elements
// {{1, 2}, {3, 4}} -> {1, 3}, {1, 4}, {2, 3}, {2, 4}
func (s SliceFloat32) Product(repeat int) chan []float32 {
	c := make(chan []float32, 1)
	go s.product(c, repeat, []float32{}, 0)
	return c
}

// product is a core implementation for Product
func (s SliceFloat32) product(c chan []float32, repeat int, left []float32, pos int) {
	// iterate over the last array
	if pos == repeat-1 {
		for _, el := range s.Data {
			result := make([]float32, 0, len(left)+1)
			result = append(result, left...)
			result = append(result, el)
			c <- result
		}
		return
	}

	for _, el := range s.Data {
		result := make([]float32, 0, len(left)+1)
		result = append(result, left...)
		result = append(result, el)
		s.product(c, repeat, result, pos+1)
	}

	if pos == 0 {
		close(c)
	}
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceFloat32) ReduceBool(acc bool, f func(el float32, acc bool) bool) bool {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceFloat32) ReduceByte(acc byte, f func(el float32, acc byte) byte) byte {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceFloat32) ReduceString(acc string, f func(el float32, acc string) string) string {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceFloat32) ReduceFloat32(acc float32, f func(el float32, acc float32) float32) float32 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceFloat32) ReduceFloat64(acc float64, f func(el float32, acc float64) float64) float64 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceFloat32) ReduceInt(acc int, f func(el float32, acc int) int) int {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceFloat32) ReduceInt8(acc int8, f func(el float32, acc int8) int8) int8 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceFloat32) ReduceInt16(acc int16, f func(el float32, acc int16) int16) int16 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceFloat32) ReduceInt32(acc int32, f func(el float32, acc int32) int32) int32 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceFloat32) ReduceInt64(acc int64, f func(el float32, acc int64) int64) int64 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceFloat32) ReduceUint(acc uint, f func(el float32, acc uint) uint) uint {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceFloat32) ReduceUint8(acc uint8, f func(el float32, acc uint8) uint8) uint8 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceFloat32) ReduceUint16(acc uint16, f func(el float32, acc uint16) uint16) uint16 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceFloat32) ReduceUint32(acc uint32, f func(el float32, acc uint32) uint32) uint32 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceFloat32) ReduceUint64(acc uint64, f func(el float32, acc uint64) uint64) uint64 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceFloat32) ReduceInterface(acc interface{}, f func(el float32, acc interface{}) interface{}) interface{} {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceFloat32) ReduceWhileBool(acc bool, f func(el float32, acc bool) (bool, error)) (bool, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceFloat32) ReduceWhileByte(acc byte, f func(el float32, acc byte) (byte, error)) (byte, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceFloat32) ReduceWhileString(acc string, f func(el float32, acc string) (string, error)) (string, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceFloat32) ReduceWhileFloat32(acc float32, f func(el float32, acc float32) (float32, error)) (float32, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceFloat32) ReduceWhileFloat64(acc float64, f func(el float32, acc float64) (float64, error)) (float64, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceFloat32) ReduceWhileInt(acc int, f func(el float32, acc int) (int, error)) (int, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceFloat32) ReduceWhileInt8(acc int8, f func(el float32, acc int8) (int8, error)) (int8, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceFloat32) ReduceWhileInt16(acc int16, f func(el float32, acc int16) (int16, error)) (int16, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceFloat32) ReduceWhileInt32(acc int32, f func(el float32, acc int32) (int32, error)) (int32, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceFloat32) ReduceWhileInt64(acc int64, f func(el float32, acc int64) (int64, error)) (int64, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceFloat32) ReduceWhileUint(acc uint, f func(el float32, acc uint) (uint, error)) (uint, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceFloat32) ReduceWhileUint8(acc uint8, f func(el float32, acc uint8) (uint8, error)) (uint8, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceFloat32) ReduceWhileUint16(acc uint16, f func(el float32, acc uint16) (uint16, error)) (uint16, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceFloat32) ReduceWhileUint32(acc uint32, f func(el float32, acc uint32) (uint32, error)) (uint32, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceFloat32) ReduceWhileUint64(acc uint64, f func(el float32, acc uint64) (uint64, error)) (uint64, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceFloat32) ReduceWhileInterface(acc interface{}, f func(el float32, acc interface{}) (interface{}, error)) (interface{}, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// Reverse returns given arr in reversed order
func (s SliceFloat32) Reverse() []float32 {
	if len(s.Data) <= 1 {
		return s.Data
	}
	result := make([]float32, 0, len(s.Data))
	for i := len(s.Data) - 1; i >= 0; i-- {
		result = append(result, s.Data[i])
	}
	return result
}

// Same returns true if all element in arr the same
func (s SliceFloat32) Same() bool {
	if len(s.Data) <= 1 {
		return true
	}
	for i := 0; i < len(s.Data)-1; i++ {
		if s.Data[i] != s.Data[i+1] {
			return false
		}
	}
	return true
}

// Scan is like Reduce, but returns slice of f results
func (s SliceFloat32) ScanBool(acc bool, f func(el float32, acc bool) bool) []bool {
	result := make([]bool, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceFloat32) ScanByte(acc byte, f func(el float32, acc byte) byte) []byte {
	result := make([]byte, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceFloat32) ScanString(acc string, f func(el float32, acc string) string) []string {
	result := make([]string, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceFloat32) ScanFloat32(acc float32, f func(el float32, acc float32) float32) []float32 {
	result := make([]float32, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceFloat32) ScanFloat64(acc float64, f func(el float32, acc float64) float64) []float64 {
	result := make([]float64, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceFloat32) ScanInt(acc int, f func(el float32, acc int) int) []int {
	result := make([]int, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceFloat32) ScanInt8(acc int8, f func(el float32, acc int8) int8) []int8 {
	result := make([]int8, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceFloat32) ScanInt16(acc int16, f func(el float32, acc int16) int16) []int16 {
	result := make([]int16, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceFloat32) ScanInt32(acc int32, f func(el float32, acc int32) int32) []int32 {
	result := make([]int32, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceFloat32) ScanInt64(acc int64, f func(el float32, acc int64) int64) []int64 {
	result := make([]int64, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceFloat32) ScanUint(acc uint, f func(el float32, acc uint) uint) []uint {
	result := make([]uint, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceFloat32) ScanUint8(acc uint8, f func(el float32, acc uint8) uint8) []uint8 {
	result := make([]uint8, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceFloat32) ScanUint16(acc uint16, f func(el float32, acc uint16) uint16) []uint16 {
	result := make([]uint16, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceFloat32) ScanUint32(acc uint32, f func(el float32, acc uint32) uint32) []uint32 {
	result := make([]uint32, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceFloat32) ScanUint64(acc uint64, f func(el float32, acc uint64) uint64) []uint64 {
	result := make([]uint64, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceFloat32) ScanInterface(acc interface{}, f func(el float32, acc interface{}) interface{}) []interface{} {
	result := make([]interface{}, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Shuffle in random order arr elements
func (s SliceFloat32) Shuffle() []float32 {
	if len(s.Data) <= 1 {
		return s.Data
	}
	rand.Seed(time.Now().UnixNano())
	swap := func(i, j int) {
		s.Data[i], s.Data[j] = s.Data[j], s.Data[i]
	}
	rand.Shuffle(len(s.Data), swap)
	return s.Data
}

// Sort returns sorted slice
func (s SliceFloat32) Sort() []float32 {
	if len(s.Data) <= 1 {
		return s.Data
	}
	less := func(i int, j int) bool {
		return s.Data[i] < s.Data[j]
	}
	sort.SliceStable(s.Data, less)
	return s.Data
}

// Sorted returns true if slice is sorted
func (s SliceFloat32) Sorted() bool {
	if len(s.Data) <= 1 {
		return true
	}
	for i := 1; i < len(s.Data); i++ {
		if s.Data[i-1] > s.Data[i] {
			return false
		}
	}
	return true
}

// Split splits arr by sep
func (s SliceFloat32) Split(sep float32) [][]float32 {
	result := make([][]float32, 0)
	curr := make([]float32, 0)
	for _, el := range s.Data {
		if el == sep {
			result = append(result, curr)
		} else {
			curr = append(curr, el)
		}
	}
	result = append(result, curr)
	return result
}

// StartsWith returns true if slice starts with the given prefix slice.
// If prefix is empty, it returns true.
func (s SliceFloat32) StartsWith(prefix []float32) bool {
	if len(prefix) > len(s.Data) {
		return false
	}
	for i, el := range prefix {
		if el != s.Data[i] {
			return false
		}
	}
	return true
}

// Sum return sum of all elements from arr
func (s SliceFloat32) Sum() float32 {
	var sum float32
	for _, el := range s.Data {
		sum += el
	}
	return sum
}

// TakeEvery returns slice of every nth elements
func (s SliceFloat32) TakeEvery(nth int) ([]float32, error) {
	if nth <= 0 {
		return s.Data, ErrNonPositiveValue
	}
	result := make([]float32, 0, len(s.Data))
	for i, el := range s.Data {
		if (i+1)%nth == 0 {
			result = append(result, el)
		}
	}
	return result, nil
}

// TakeRandom returns slice of count random elements from the slice
func (s SliceFloat32) TakeRandom(count int) ([]float32, error) {
	if count > len(s.Data) {
		return nil, ErrOutOfRange
	}
	if count <= 0 {
		return nil, ErrNonPositiveValue
	}

	rand.Seed(time.Now().UnixNano())
	swap := func(i, j int) {
		s.Data[i], s.Data[j] = s.Data[j], s.Data[i]
	}
	rand.Shuffle(len(s.Data), swap)
	return s.Data[:count], nil
}

// TakeWhile takes elements from arr while f returns true
func (s SliceFloat32) TakeWhile(f func(el float32) bool) []float32 {
	result := make([]float32, 0, len(s.Data))
	for _, el := range s.Data {
		if !f(el) {
			return result
		}
		result = append(result, el)
	}
	return result
}

// ToChannel returns channel with elements from the slice
func (s SliceFloat32) ToChannel() chan float32 {
	c := make(chan float32, 1)
	go func() {
		for _, el := range s.Data {
			c <- el
		}
		close(c)
	}()
	return c
}

// Uniq returns arr with only first occurences of every element.
func (s SliceFloat32) Uniq() []float32 {
	if len(s.Data) <= 1 {
		return s.Data
	}
	added := make(map[float32]struct{})
	nothing := struct{}{}
	result := make([]float32, 0, len(s.Data))
	for _, el := range s.Data {
		_, exists := added[el]
		if !exists {
			result = append(result, el)
			added[el] = nothing
		}
	}
	return result

}

// Window makes sliding window for a given slice:
// ({1,2,3}, 2) -> (1,2), (2,3)
func (s SliceFloat32) Window(size int) ([][]float32, error) {
	if size <= 0 {
		return nil, ErrNonPositiveValue
	}
	result := make([][]float32, 0, len(s.Data)/size)
	for i := 0; i <= len(s.Data)-size; i++ {
		chunk := s.Data[i : i+size]
		result = append(result, chunk)
	}
	return result, nil
}

// Without returns the slice with filtered out element
func (s SliceFloat32) Without(elements ...float32) []float32 {
	result := make([]float32, 0, len(s.Data))
	for _, el := range s.Data {
		allowed := true
		for _, other := range elements {
			if el == other {
				allowed = false
			}
		}
		if allowed {
			result = append(result, el)
		}
	}
	return result
}

// Concat concatenates given slices into a single slice.
func (s SlicesFloat32) Concat() []float32 {
	result := make([]float32, 0)
	for _, arr := range s.Data {
		result = append(result, arr...)
	}
	return result
}

// Product returns cortesian product of elements
// {{1, 2}, {3, 4}} -> {1, 3}, {1, 4}, {2, 3}, {2, 4}
func (s SlicesFloat32) Product() chan []float32 {
	c := make(chan []float32, 1)
	go s.product(c, []float32{}, 0)
	return c
}

// product is a core implementation of Product
func (s SlicesFloat32) product(c chan []float32, left []float32, pos int) {
	// iterate over the last array
	if pos == len(s.Data)-1 {
		for _, el := range s.Data[pos] {
			result := make([]float32, 0, len(left)+1)
			result = append(result, left...)
			result = append(result, el)
			c <- result
		}
		return
	}

	for _, el := range s.Data[pos] {
		result := make([]float32, 0, len(left)+1)
		result = append(result, left...)
		result = append(result, el)
		s.product(c, result, pos+1)
	}

	if pos == 0 {
		close(c)
	}
}

// Zip returns array of arrays of elements from given arrs
// on the same position
func (s SlicesFloat32) Zip() [][]float32 {
	size := len(s.Data[0])
	for _, arr := range s.Data[1:] {
		if len(arr) > size {
			size = len(arr)
		}
	}

	result := make([][]float32, 0, size)
	for i := 0; i <= size; i++ {
		chunk := make([]float32, 0, len(s.Data))
		for _, arr := range s.Data {
			chunk = append(chunk, arr[i])
		}
		result = append(result, chunk)
	}
	return result
}

// Channel is a set of operations with channel
type ChannelFloat64 struct {
	Data chan float64
}

// AsyncSlice is a set of operations to work with slice asynchronously
type AsyncSliceFloat64 struct {
	Data    []float64
	Workers int
}

// Sequence is a set of operations to generate sequences
type SequenceFloat64 struct {
	ctx context.Context
}

// Pair is a set of functions for 2 values that you can pass into reduce-like funcs
type PairFloat64 struct {
	// empty
}

// Slice is a set of operations to work with slice
type SliceFloat64 struct {
	Data []float64
}

// Slices is a set of operations to work with slice of slices
type SlicesFloat64 struct {
	Data [][]float64
}

// Any returns true if f returns true for any element in channel
func (c ChannelFloat64) Any(f func(el float64) bool) bool {
	for el := range c.Data {
		if f(el) {
			return true
		}
	}
	return false
}

// All returns true if f returns true for all elements in channel
func (c ChannelFloat64) All(f func(el float64) bool) bool {
	for el := range c.Data {
		if !f(el) {
			return false
		}
	}
	return true
}

// ChunkEvery returns channel with slices containing count elements each
func (c ChannelFloat64) ChunkEvery(count int) chan []float64 {
	chunks := make(chan []float64, 1)
	go func() {
		chunk := make([]float64, 0, count)
		i := 0
		for el := range c.Data {
			chunk = append(chunk, el)
			i++
			if i%count == 0 {
				i = 0
				chunks <- chunk
				chunk = make([]float64, 0, count)
			}
		}
		if len(chunk) > 0 {
			chunks <- chunk
		}
		close(chunks)
	}()
	return chunks
}

// Count return count of el occurences in channel.
func (c ChannelFloat64) Count(el float64) int {
	count := 0
	for val := range c.Data {
		if val == el {
			count++
		}
	}
	return count
}

// Drop drops first n elements from channel c and returns a new channel with the rest.
// It returns channel do be unblocking. If you want array instead, wrap result into TakeAll.
func (c ChannelFloat64) Drop(n int) chan float64 {
	result := make(chan float64, 1)
	go func() {
		i := 0
		for el := range c.Data {
			if i >= n {
				result <- el
			}
			i++
		}
		close(result)
	}()
	return result
}

// Each calls f for every element in the channel
func (c ChannelFloat64) Each(f func(el float64)) {
	for el := range c.Data {
		f(el)
	}
}

// Filter returns a new channel with elements from input channel
// for which f returns true
func (c ChannelFloat64) Filter(f func(el float64) bool) chan float64 {
	result := make(chan float64, 1)
	go func() {
		for el := range c.Data {
			if f(el) {
				result <- el
			}
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelFloat64) MapBool(f func(el float64) bool) chan bool {
	result := make(chan bool, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelFloat64) MapByte(f func(el float64) byte) chan byte {
	result := make(chan byte, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelFloat64) MapString(f func(el float64) string) chan string {
	result := make(chan string, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelFloat64) MapFloat32(f func(el float64) float32) chan float32 {
	result := make(chan float32, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelFloat64) MapFloat64(f func(el float64) float64) chan float64 {
	result := make(chan float64, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelFloat64) MapInt(f func(el float64) int) chan int {
	result := make(chan int, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelFloat64) MapInt8(f func(el float64) int8) chan int8 {
	result := make(chan int8, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelFloat64) MapInt16(f func(el float64) int16) chan int16 {
	result := make(chan int16, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelFloat64) MapInt32(f func(el float64) int32) chan int32 {
	result := make(chan int32, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelFloat64) MapInt64(f func(el float64) int64) chan int64 {
	result := make(chan int64, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelFloat64) MapUint(f func(el float64) uint) chan uint {
	result := make(chan uint, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelFloat64) MapUint8(f func(el float64) uint8) chan uint8 {
	result := make(chan uint8, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelFloat64) MapUint16(f func(el float64) uint16) chan uint16 {
	result := make(chan uint16, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelFloat64) MapUint32(f func(el float64) uint32) chan uint32 {
	result := make(chan uint32, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelFloat64) MapUint64(f func(el float64) uint64) chan uint64 {
	result := make(chan uint64, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelFloat64) MapInterface(f func(el float64) interface{}) chan interface{} {
	result := make(chan interface{}, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Max returns the maximal element from channel
func (c ChannelFloat64) Max() (float64, error) {
	max, ok := <-c.Data
	if !ok {
		return max, ErrEmpty
	}
	for el := range c.Data {
		if el > max {
			max = el
		}
	}
	return max, nil
}

// Min returns the minimal element from channel
func (c ChannelFloat64) Min() (float64, error) {
	min, ok := <-c.Data
	if !ok {
		return min, ErrEmpty
	}
	for el := range c.Data {
		if el < min {
			min = el
		}
	}
	return min, nil
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelFloat64) ReduceBool(acc bool, f func(el float64, acc bool) bool) bool {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelFloat64) ReduceByte(acc byte, f func(el float64, acc byte) byte) byte {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelFloat64) ReduceString(acc string, f func(el float64, acc string) string) string {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelFloat64) ReduceFloat32(acc float32, f func(el float64, acc float32) float32) float32 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelFloat64) ReduceFloat64(acc float64, f func(el float64, acc float64) float64) float64 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelFloat64) ReduceInt(acc int, f func(el float64, acc int) int) int {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelFloat64) ReduceInt8(acc int8, f func(el float64, acc int8) int8) int8 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelFloat64) ReduceInt16(acc int16, f func(el float64, acc int16) int16) int16 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelFloat64) ReduceInt32(acc int32, f func(el float64, acc int32) int32) int32 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelFloat64) ReduceInt64(acc int64, f func(el float64, acc int64) int64) int64 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelFloat64) ReduceUint(acc uint, f func(el float64, acc uint) uint) uint {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelFloat64) ReduceUint8(acc uint8, f func(el float64, acc uint8) uint8) uint8 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelFloat64) ReduceUint16(acc uint16, f func(el float64, acc uint16) uint16) uint16 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelFloat64) ReduceUint32(acc uint32, f func(el float64, acc uint32) uint32) uint32 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelFloat64) ReduceUint64(acc uint64, f func(el float64, acc uint64) uint64) uint64 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelFloat64) ReduceInterface(acc interface{}, f func(el float64, acc interface{}) interface{}) interface{} {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelFloat64) ScanBool(acc bool, f func(el float64, acc bool) bool) chan bool {
	result := make(chan bool, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelFloat64) ScanByte(acc byte, f func(el float64, acc byte) byte) chan byte {
	result := make(chan byte, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelFloat64) ScanString(acc string, f func(el float64, acc string) string) chan string {
	result := make(chan string, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelFloat64) ScanFloat32(acc float32, f func(el float64, acc float32) float32) chan float32 {
	result := make(chan float32, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelFloat64) ScanFloat64(acc float64, f func(el float64, acc float64) float64) chan float64 {
	result := make(chan float64, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelFloat64) ScanInt(acc int, f func(el float64, acc int) int) chan int {
	result := make(chan int, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelFloat64) ScanInt8(acc int8, f func(el float64, acc int8) int8) chan int8 {
	result := make(chan int8, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelFloat64) ScanInt16(acc int16, f func(el float64, acc int16) int16) chan int16 {
	result := make(chan int16, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelFloat64) ScanInt32(acc int32, f func(el float64, acc int32) int32) chan int32 {
	result := make(chan int32, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelFloat64) ScanInt64(acc int64, f func(el float64, acc int64) int64) chan int64 {
	result := make(chan int64, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelFloat64) ScanUint(acc uint, f func(el float64, acc uint) uint) chan uint {
	result := make(chan uint, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelFloat64) ScanUint8(acc uint8, f func(el float64, acc uint8) uint8) chan uint8 {
	result := make(chan uint8, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelFloat64) ScanUint16(acc uint16, f func(el float64, acc uint16) uint16) chan uint16 {
	result := make(chan uint16, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelFloat64) ScanUint32(acc uint32, f func(el float64, acc uint32) uint32) chan uint32 {
	result := make(chan uint32, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelFloat64) ScanUint64(acc uint64, f func(el float64, acc uint64) uint64) chan uint64 {
	result := make(chan uint64, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelFloat64) ScanInterface(acc interface{}, f func(el float64, acc interface{}) interface{}) chan interface{} {
	result := make(chan interface{}, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Sum returns sum of all elements from channel
func (c ChannelFloat64) Sum() float64 {
	var sum float64
	for el := range c.Data {
		sum += el
	}
	return sum
}

// Take takes first count elements from the channel.
func (c ChannelFloat64) Take(count int) chan float64 {
	result := make(chan float64, 1)
	go func() {
		defer close(result)
		if count <= 0 {
			return
		}
		i := 0
		for el := range c.Data {
			result <- el
			i++
			if i == count {
				return
			}
		}
	}()
	return result
}

// Tee returns 2 channels with elements from the input channel
func (c ChannelFloat64) Tee(count int) []chan float64 {
	channels := make([]chan float64, 0, count)
	for i := 0; i < count; i++ {
		channels = append(channels, make(chan float64, 1))
	}
	go func() {
		for el := range c.Data {
			wg := sync.WaitGroup{}
			putInto := func(ch chan float64) {
				defer wg.Done()
				ch <- el
			}
			wg.Add(count)
			for _, ch := range channels {
				putInto(ch)
			}
			wg.Wait()
		}
		for _, ch := range channels {
			close(ch)
		}
	}()
	return channels
}

// ToSlice returns slice with all elements from channel.
func (c ChannelFloat64) ToSlice() []float64 {
	result := make([]float64, 0)
	for val := range c.Data {
		result = append(result, val)
	}
	return result
}

// All returns true if f returns true for all elements in slice
func (s AsyncSliceFloat64) All(f func(el float64) bool) bool {
	if len(s.Data) == 0 {
		return true
	}

	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int, result chan<- bool, ctx context.Context) {
		defer wg.Done()
		for {
			select {
			case <-ctx.Done():
				return
			case index, ok := <-jobs:
				if !ok {
					return
				}
				if !f(s.Data[index]) {
					result <- false
					return
				}
			}
		}
	}

	ctx, cancel := context.WithCancel(context.Background())
	// when we're returning the result, cancel all workers
	defer cancel()

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	result := make(chan bool, workers)
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs, result, ctx)
	}

	// close the result channel when all workers have done
	go func() {
		wg.Wait()
		close(result)
	}()

	// schedule the jobs: indices to check
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)

	for range result {
		return false
	}
	return true
}

// Any returns true if f returns true for any element from slice
func (s AsyncSliceFloat64) Any(f func(el float64) bool) bool {
	if len(s.Data) == 0 {
		return false
	}

	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int, result chan<- bool, ctx context.Context) {
		defer wg.Done()
		for {
			select {
			case <-ctx.Done():
				return
			case index, ok := <-jobs:
				if !ok {
					return
				}
				if f(s.Data[index]) {
					result <- true
					return
				}
			}
		}
	}

	ctx, cancel := context.WithCancel(context.Background())
	// when we're returning the result, cancel all workers
	defer cancel()

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	result := make(chan bool, workers)
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs, result, ctx)
	}

	// close the result channel when all workers have done
	go func() {
		wg.Wait()
		close(result)
	}()

	// schedule the jobs: indices to check
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)

	for range result {
		return true
	}
	return false
}

// Each calls f for every element from slice
func (s AsyncSliceFloat64) Each(f func(el float64)) {
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		defer wg.Done()
		for index := range jobs {
			f(s.Data[index])
		}
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
}

// Filter returns slice of element for which f returns true
func (s AsyncSliceFloat64) Filter(f func(el float64) bool) []float64 {
	resultMap := make([]bool, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			if f(s.Data[index]) {
				resultMap[index] = true
			}
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()

	// return filtered results
	result := make([]float64, 0, len(s.Data))
	for i, el := range s.Data {
		if resultMap[i] {
			result = append(result, el)
		}
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceFloat64) MapBool(f func(el float64) bool) []bool {
	result := make([]bool, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceFloat64) MapByte(f func(el float64) byte) []byte {
	result := make([]byte, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceFloat64) MapString(f func(el float64) string) []string {
	result := make([]string, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceFloat64) MapFloat32(f func(el float64) float32) []float32 {
	result := make([]float32, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceFloat64) MapFloat64(f func(el float64) float64) []float64 {
	result := make([]float64, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceFloat64) MapInt(f func(el float64) int) []int {
	result := make([]int, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceFloat64) MapInt8(f func(el float64) int8) []int8 {
	result := make([]int8, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceFloat64) MapInt16(f func(el float64) int16) []int16 {
	result := make([]int16, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceFloat64) MapInt32(f func(el float64) int32) []int32 {
	result := make([]int32, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceFloat64) MapInt64(f func(el float64) int64) []int64 {
	result := make([]int64, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceFloat64) MapUint(f func(el float64) uint) []uint {
	result := make([]uint, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceFloat64) MapUint8(f func(el float64) uint8) []uint8 {
	result := make([]uint8, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceFloat64) MapUint16(f func(el float64) uint16) []uint16 {
	result := make([]uint16, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceFloat64) MapUint32(f func(el float64) uint32) []uint32 {
	result := make([]uint32, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceFloat64) MapUint64(f func(el float64) uint64) []uint64 {
	result := make([]uint64, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceFloat64) MapInterface(f func(el float64) interface{}) []interface{} {
	result := make([]interface{}, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Reduce reduces slice to a single value with f
func (s AsyncSliceFloat64) Reduce(f func(left float64, right float64) float64) float64 {
	if len(s.Data) == 0 {
		var tmp float64
		return tmp
	}

	state := make([]float64, len(s.Data))
	state = append(state, s.Data...)
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int, result chan<- float64) {
		for index := range jobs {
			result <- f(state[index], state[index+1])
		}
		wg.Done()
	}

	for len(state) > 1 {
		// calculate workers count
		workers := s.Workers
		if workers == 0 || workers > len(state) {
			workers = len(state)
		}

		// run workers
		jobs := make(chan int, len(state))
		wg.Add(workers)
		result := make(chan float64, 1)
		for i := 0; i < workers; i++ {
			go worker(jobs, result)
		}

		go func() {
			wg.Wait()
			close(result)
		}()

		// add indices into jobs for workers
		for i := 0; i < len(state)-1; i += 2 {
			jobs <- i
		}
		close(jobs)

		// collect new state
		newState := make([]float64, 0, len(state)/2+len(state)%2)
		for el := range result {
			newState = append(newState, el)
		}
		if len(state)%2 == 1 {
			newState = append(newState, state[len(state)-1])
		}
		// put new state as current state after all
		state = newState
	}

	return state[0]
}

// Count is like Range, but infinite
func (s SequenceFloat64) Count(start float64, step float64) chan float64 {
	c := make(chan float64, 1)
	go func() {
		defer close(c)
		for {
			select {
			case <-s.ctx.Done():
				return
			case c <- start:
				start += step
			}
		}
	}()
	return c
}

// Exponential generates elements from start with
// multiplication of value on factor on every step
func (s SequenceFloat64) Exponential(start float64, factor float64) chan float64 {
	c := make(chan float64, 1)
	go func() {
		defer close(c)
		for {
			select {
			case <-s.ctx.Done():
				return
			case c <- start:
				start *= factor
			}
		}
	}()
	return c
}

// Iterate returns an infinite list of repeated applications of f to val
func (s SequenceFloat64) Iterate(val float64, f func(val float64) float64) chan float64 {
	c := make(chan float64, 1)
	go func() {
		defer close(c)
		for {
			select {
			case <-s.ctx.Done():
				return
			case c <- val:
				val = f(val)
			}
		}
	}()
	return c
}

// Range generates elements from start to end with given step
func (s SequenceFloat64) Range(start float64, end float64, step float64) chan float64 {
	c := make(chan float64, 1)
	pos := start <= end
	go func() {
		for pos && (start < end) || !pos && (start > end) {
			c <- start
			start += step
		}
		close(c)
	}()
	return c
}

// Repeat returns channel that produces val infinite times
func (s SequenceFloat64) Repeat(val float64) chan float64 {
	c := make(chan float64, 1)
	go func() {
		defer close(c)
		for {
			select {
			case <-s.ctx.Done():
				return
			case c <- val:
				continue
			}
		}
	}()
	return c
}

// Replicate returns channel that produces val n times
func (s SequenceFloat64) Replicate(val float64, n int) chan float64 {
	c := make(chan float64, 1)
	go func() {
		for i := 0; i < n; i++ {
			c <- val
		}
		close(c)
	}()
	return c
}

// Min returns minimal value
func (PairFloat64) Min(a float64, b float64) float64 {
	if a <= b {
		return a
	}
	return b
}

// Max returns maximal value
func (PairFloat64) Max(a float64, b float64) float64 {
	if a > b {
		return a
	}
	return b
}

// Any returns true if f returns true for any element in arr
func (s SliceFloat64) Any(f func(el float64) bool) bool {
	for _, el := range s.Data {
		if f(el) {
			return true
		}
	}
	return false
}

// All returns true if f returns true for all elements in arr
func (s SliceFloat64) All(f func(el float64) bool) bool {
	for _, el := range s.Data {
		if !f(el) {
			return false
		}
	}
	return true
}

// Choice chooses a random element from the slice
func (s SliceFloat64) Choice() (float64, error) {
	if len(s.Data) == 0 {
		var tmp float64
		return tmp, ErrEmpty
	}

	rand.Seed(time.Now().UnixNano())
	i := rand.Intn(len(s.Data))
	return s.Data[i], nil
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceFloat64) ChunkByBool(f func(el float64) bool) [][]float64 {
	chunks := make([][]float64, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]float64, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]float64, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceFloat64) ChunkByByte(f func(el float64) byte) [][]float64 {
	chunks := make([][]float64, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]float64, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]float64, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceFloat64) ChunkByString(f func(el float64) string) [][]float64 {
	chunks := make([][]float64, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]float64, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]float64, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceFloat64) ChunkByFloat32(f func(el float64) float32) [][]float64 {
	chunks := make([][]float64, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]float64, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]float64, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceFloat64) ChunkByFloat64(f func(el float64) float64) [][]float64 {
	chunks := make([][]float64, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]float64, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]float64, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceFloat64) ChunkByInt(f func(el float64) int) [][]float64 {
	chunks := make([][]float64, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]float64, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]float64, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceFloat64) ChunkByInt8(f func(el float64) int8) [][]float64 {
	chunks := make([][]float64, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]float64, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]float64, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceFloat64) ChunkByInt16(f func(el float64) int16) [][]float64 {
	chunks := make([][]float64, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]float64, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]float64, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceFloat64) ChunkByInt32(f func(el float64) int32) [][]float64 {
	chunks := make([][]float64, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]float64, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]float64, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceFloat64) ChunkByInt64(f func(el float64) int64) [][]float64 {
	chunks := make([][]float64, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]float64, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]float64, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceFloat64) ChunkByUint(f func(el float64) uint) [][]float64 {
	chunks := make([][]float64, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]float64, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]float64, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceFloat64) ChunkByUint8(f func(el float64) uint8) [][]float64 {
	chunks := make([][]float64, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]float64, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]float64, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceFloat64) ChunkByUint16(f func(el float64) uint16) [][]float64 {
	chunks := make([][]float64, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]float64, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]float64, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceFloat64) ChunkByUint32(f func(el float64) uint32) [][]float64 {
	chunks := make([][]float64, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]float64, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]float64, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceFloat64) ChunkByUint64(f func(el float64) uint64) [][]float64 {
	chunks := make([][]float64, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]float64, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]float64, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceFloat64) ChunkByInterface(f func(el float64) interface{}) [][]float64 {
	chunks := make([][]float64, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]float64, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]float64, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkEvery returns slice of slices containing count elements each
func (s SliceFloat64) ChunkEvery(count int) ([][]float64, error) {
	chunks := make([][]float64, 0)
	if count <= 0 {
		return chunks, ErrNegativeValue
	}
	chunk := make([]float64, 0, count)
	for i, el := range s.Data {
		chunk = append(chunk, el)
		if (i+1)%count == 0 {
			chunks = append(chunks, chunk)
			chunk = make([]float64, 0, count)
		}
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks, nil
}

// Contains returns true if el in arr.
func (s SliceFloat64) Contains(el float64) bool {
	for _, val := range s.Data {
		if val == el {
			return true
		}
	}
	return false
}

// Count return count of el occurences in arr.
func (s SliceFloat64) Count(el float64) int {
	count := 0
	for _, val := range s.Data {
		if val == el {
			count++
		}
	}
	return count
}

// CountBy returns how many times f returns true.
func (s SliceFloat64) CountBy(f func(el float64) bool) int {
	count := 0
	for _, el := range s.Data {
		if f(el) {
			count++
		}
	}
	return count
}

// Cycle is an infinite loop over slice
func (s SliceFloat64) Cycle() chan float64 {
	c := make(chan float64, 1)
	go func() {
		defer close(c)
		if len(s.Data) == 0 {
			return
		}
		for {
			for _, val := range s.Data {
				c <- val
			}
		}
	}()
	return c
}

// Dedup returns a given slice without consecutive duplicated elements
func (s SliceFloat64) Dedup() []float64 {
	if len(s.Data) == 0 {
		return s.Data
	}

	result := make([]float64, 0, len(s.Data))
	prev := s.Data[0]
	result = append(result, prev)
	for _, el := range s.Data[1:] {
		if el != prev {
			result = append(result, el)
			prev = el
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceFloat64) DedupByBool(f func(el float64) bool) []float64 {
	result := make([]float64, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceFloat64) DedupByByte(f func(el float64) byte) []float64 {
	result := make([]float64, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceFloat64) DedupByString(f func(el float64) string) []float64 {
	result := make([]float64, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceFloat64) DedupByFloat32(f func(el float64) float32) []float64 {
	result := make([]float64, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceFloat64) DedupByFloat64(f func(el float64) float64) []float64 {
	result := make([]float64, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceFloat64) DedupByInt(f func(el float64) int) []float64 {
	result := make([]float64, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceFloat64) DedupByInt8(f func(el float64) int8) []float64 {
	result := make([]float64, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceFloat64) DedupByInt16(f func(el float64) int16) []float64 {
	result := make([]float64, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceFloat64) DedupByInt32(f func(el float64) int32) []float64 {
	result := make([]float64, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceFloat64) DedupByInt64(f func(el float64) int64) []float64 {
	result := make([]float64, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceFloat64) DedupByUint(f func(el float64) uint) []float64 {
	result := make([]float64, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceFloat64) DedupByUint8(f func(el float64) uint8) []float64 {
	result := make([]float64, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceFloat64) DedupByUint16(f func(el float64) uint16) []float64 {
	result := make([]float64, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceFloat64) DedupByUint32(f func(el float64) uint32) []float64 {
	result := make([]float64, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceFloat64) DedupByUint64(f func(el float64) uint64) []float64 {
	result := make([]float64, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceFloat64) DedupByInterface(f func(el float64) interface{}) []float64 {
	result := make([]float64, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// Delete deletes the first occurence of the element from the slice
func (s SliceFloat64) Delete(element float64) []float64 {
	result := make([]float64, 0, len(s.Data)-1)
	deleted := false
	for _, el := range s.Data {
		if !deleted && el == element {
			continue
		}
		result = append(result, el)
	}
	return result

}

// DeleteAt returns the slice without elements on given positions
func (s SliceFloat64) DeleteAt(index int) ([]float64, error) {
	if index >= len(s.Data) {
		return s.Data, ErrOutOfRange
	}

	result := make([]float64, 0, len(s.Data)-1)
	for i, el := range s.Data {
		if i != index {
			result = append(result, el)
		}
	}
	return result, nil
}

// DropEvery returns a slice of every nth element in the enumerable dropped,
// starting with the first element.
func (s SliceFloat64) DropEvery(nth int) ([]float64, error) {
	if nth <= 0 {
		return s.Data, ErrNonPositiveValue
	}
	result := make([]float64, 0, len(s.Data)/nth)
	for i, el := range s.Data {
		if (i+1)%nth != 0 {
			result = append(result, el)
		}
	}
	return result, nil
}

// DropWhile drops elements from arr while f returns true
func (s SliceFloat64) DropWhile(f func(arr float64) bool) []float64 {
	result := make([]float64, 0, len(s.Data))
	for _, el := range s.Data {
		if !f(el) {
			return result
		}
		result = append(result, el)
	}
	return result
}

// Each calls f for every element from arr
func (s SliceFloat64) Each(f func(el float64)) {
	for _, el := range s.Data {
		f(el)
	}
}

// Equal returns true if slices are equal
func (s SliceFloat64) Equal(other []float64) bool {
	if len(s.Data) != len(other) {
		return false
	}
	for i, el := range other {
		if s.Data[i] != el {
			return false
		}
	}
	return true
}

// Filter returns slice of T for which F returned true
func (s SliceFloat64) Filter(f func(el float64) bool) []float64 {
	result := make([]float64, 0, len(s.Data))
	for _, el := range s.Data {
		if f(el) {
			result = append(result, el)
		}
	}
	return result
}

// Find returns the first element for which f returns true
func (s SliceFloat64) Find(f func(el float64) bool) (float64, error) {
	for _, el := range s.Data {
		if f(el) {
			return el, nil
		}
	}
	var tmp float64
	return tmp, ErrNotFound
}

// FindIndex is like Find, but return element index instead of element itself
func (s SliceFloat64) FindIndex(f func(el float64) bool) (int, error) {
	for i, el := range s.Data {
		if f(el) {
			return i, nil
		}
	}
	return 0, ErrNotFound
}

// GroupBy groups element from array by value returned by f
func (s SliceFloat64) GroupByBool(f func(el float64) bool) map[bool][]float64 {
	result := make(map[bool][]float64)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]float64, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceFloat64) GroupByByte(f func(el float64) byte) map[byte][]float64 {
	result := make(map[byte][]float64)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]float64, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceFloat64) GroupByString(f func(el float64) string) map[string][]float64 {
	result := make(map[string][]float64)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]float64, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceFloat64) GroupByFloat32(f func(el float64) float32) map[float32][]float64 {
	result := make(map[float32][]float64)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]float64, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceFloat64) GroupByFloat64(f func(el float64) float64) map[float64][]float64 {
	result := make(map[float64][]float64)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]float64, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceFloat64) GroupByInt(f func(el float64) int) map[int][]float64 {
	result := make(map[int][]float64)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]float64, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceFloat64) GroupByInt8(f func(el float64) int8) map[int8][]float64 {
	result := make(map[int8][]float64)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]float64, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceFloat64) GroupByInt16(f func(el float64) int16) map[int16][]float64 {
	result := make(map[int16][]float64)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]float64, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceFloat64) GroupByInt32(f func(el float64) int32) map[int32][]float64 {
	result := make(map[int32][]float64)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]float64, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceFloat64) GroupByInt64(f func(el float64) int64) map[int64][]float64 {
	result := make(map[int64][]float64)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]float64, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceFloat64) GroupByUint(f func(el float64) uint) map[uint][]float64 {
	result := make(map[uint][]float64)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]float64, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceFloat64) GroupByUint8(f func(el float64) uint8) map[uint8][]float64 {
	result := make(map[uint8][]float64)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]float64, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceFloat64) GroupByUint16(f func(el float64) uint16) map[uint16][]float64 {
	result := make(map[uint16][]float64)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]float64, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceFloat64) GroupByUint32(f func(el float64) uint32) map[uint32][]float64 {
	result := make(map[uint32][]float64)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]float64, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceFloat64) GroupByUint64(f func(el float64) uint64) map[uint64][]float64 {
	result := make(map[uint64][]float64)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]float64, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceFloat64) GroupByInterface(f func(el float64) interface{}) map[interface{}][]float64 {
	result := make(map[interface{}][]float64)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]float64, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// InsertAt returns the slice with element inserted at given index.
func (s SliceFloat64) InsertAt(index int, element float64) ([]float64, error) {
	result := make([]float64, 0, len(s.Data)+1)

	// insert at the end
	if index == len(s.Data) || index == -1 {
		result = append(result, s.Data...)
		result = append(result, element)
		return result, nil
	}

	if index > len(s.Data) {
		return s.Data, ErrOutOfRange
	}
	if index < 0 {
		return s.Data, ErrNegativeValue
	}

	for i, el := range s.Data {
		if i == index {
			result = append(result, element)
		}
		result = append(result, el)
	}
	return result, nil
}

// Intersperse inserts el between each element of arr
func (s SliceFloat64) Intersperse(el float64) []float64 {
	if len(s.Data) == 0 {
		return s.Data
	}
	result := make([]float64, 0, len(s.Data)*2-1)
	result = append(result, s.Data[0])
	for _, val := range s.Data[1:] {
		result = append(result, el, val)
	}
	return result
}

// Last returns the last element from the slice
func (s SliceFloat64) Last() (float64, error) {
	if len(s.Data) == 0 {
		var tmp float64
		return tmp, ErrEmpty
	}
	return s.Data[len(s.Data)-1], nil
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceFloat64) MapBool(f func(el float64) bool) []bool {
	result := make([]bool, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceFloat64) MapByte(f func(el float64) byte) []byte {
	result := make([]byte, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceFloat64) MapString(f func(el float64) string) []string {
	result := make([]string, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceFloat64) MapFloat32(f func(el float64) float32) []float32 {
	result := make([]float32, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceFloat64) MapFloat64(f func(el float64) float64) []float64 {
	result := make([]float64, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceFloat64) MapInt(f func(el float64) int) []int {
	result := make([]int, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceFloat64) MapInt8(f func(el float64) int8) []int8 {
	result := make([]int8, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceFloat64) MapInt16(f func(el float64) int16) []int16 {
	result := make([]int16, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceFloat64) MapInt32(f func(el float64) int32) []int32 {
	result := make([]int32, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceFloat64) MapInt64(f func(el float64) int64) []int64 {
	result := make([]int64, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceFloat64) MapUint(f func(el float64) uint) []uint {
	result := make([]uint, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceFloat64) MapUint8(f func(el float64) uint8) []uint8 {
	result := make([]uint8, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceFloat64) MapUint16(f func(el float64) uint16) []uint16 {
	result := make([]uint16, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceFloat64) MapUint32(f func(el float64) uint32) []uint32 {
	result := make([]uint32, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceFloat64) MapUint64(f func(el float64) uint64) []uint64 {
	result := make([]uint64, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceFloat64) MapInterface(f func(el float64) interface{}) []interface{} {
	result := make([]interface{}, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Max returns the maximal element from arr
func (s SliceFloat64) Max() (float64, error) {
	if len(s.Data) == 0 {
		var tmp float64
		return tmp, ErrEmpty
	}

	max := s.Data[0]
	for _, el := range s.Data[1:] {
		if el > max {
			max = el
		}
	}
	return max, nil
}

// Min returns the minimal element from arr
func (s SliceFloat64) Min() (float64, error) {
	if len(s.Data) == 0 {
		var tmp float64
		return tmp, ErrEmpty
	}

	min := s.Data[0]
	for _, el := range s.Data[1:] {
		if el < min {
			min = el
		}
	}
	return min, nil
}

// Permutations returns successive size-length permutations of elements from the slice.
// {1, 2, 3} -> {1, 2}, {1, 3}, {2, 1}, {2, 3}, {3, 1}, {3, 2}
func (s SliceFloat64) Permutations(size int) chan []float64 {
	c := make(chan []float64, 1)
	go func() {
		if len(s.Data) > 0 {
			s.permutations(c, size, []float64{}, s.Data)
		}
		close(c)
	}()
	return c
}

// permutations is a core implementation for Permutations
func (s SliceFloat64) permutations(c chan []float64, size int, left []float64, right []float64) {
	if len(left) == size || len(right) == 0 {
		c <- left
		return
	}

	for i, el := range right {
		newLeft := make([]float64, 0, len(left)+1)
		newLeft = append(newLeft, left...)
		newLeft = append(newLeft, el)

		newRight := make([]float64, 0, len(right)-1)
		for j, other := range right {
			if j != i {
				newRight = append(newRight, other)
			}
		}
		s.permutations(c, size, newLeft, newRight)
	}
}

// Product returns cortesian product of elements
// {{1, 2}, {3, 4}} -> {1, 3}, {1, 4}, {2, 3}, {2, 4}
func (s SliceFloat64) Product(repeat int) chan []float64 {
	c := make(chan []float64, 1)
	go s.product(c, repeat, []float64{}, 0)
	return c
}

// product is a core implementation for Product
func (s SliceFloat64) product(c chan []float64, repeat int, left []float64, pos int) {
	// iterate over the last array
	if pos == repeat-1 {
		for _, el := range s.Data {
			result := make([]float64, 0, len(left)+1)
			result = append(result, left...)
			result = append(result, el)
			c <- result
		}
		return
	}

	for _, el := range s.Data {
		result := make([]float64, 0, len(left)+1)
		result = append(result, left...)
		result = append(result, el)
		s.product(c, repeat, result, pos+1)
	}

	if pos == 0 {
		close(c)
	}
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceFloat64) ReduceBool(acc bool, f func(el float64, acc bool) bool) bool {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceFloat64) ReduceByte(acc byte, f func(el float64, acc byte) byte) byte {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceFloat64) ReduceString(acc string, f func(el float64, acc string) string) string {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceFloat64) ReduceFloat32(acc float32, f func(el float64, acc float32) float32) float32 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceFloat64) ReduceFloat64(acc float64, f func(el float64, acc float64) float64) float64 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceFloat64) ReduceInt(acc int, f func(el float64, acc int) int) int {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceFloat64) ReduceInt8(acc int8, f func(el float64, acc int8) int8) int8 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceFloat64) ReduceInt16(acc int16, f func(el float64, acc int16) int16) int16 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceFloat64) ReduceInt32(acc int32, f func(el float64, acc int32) int32) int32 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceFloat64) ReduceInt64(acc int64, f func(el float64, acc int64) int64) int64 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceFloat64) ReduceUint(acc uint, f func(el float64, acc uint) uint) uint {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceFloat64) ReduceUint8(acc uint8, f func(el float64, acc uint8) uint8) uint8 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceFloat64) ReduceUint16(acc uint16, f func(el float64, acc uint16) uint16) uint16 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceFloat64) ReduceUint32(acc uint32, f func(el float64, acc uint32) uint32) uint32 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceFloat64) ReduceUint64(acc uint64, f func(el float64, acc uint64) uint64) uint64 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceFloat64) ReduceInterface(acc interface{}, f func(el float64, acc interface{}) interface{}) interface{} {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceFloat64) ReduceWhileBool(acc bool, f func(el float64, acc bool) (bool, error)) (bool, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceFloat64) ReduceWhileByte(acc byte, f func(el float64, acc byte) (byte, error)) (byte, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceFloat64) ReduceWhileString(acc string, f func(el float64, acc string) (string, error)) (string, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceFloat64) ReduceWhileFloat32(acc float32, f func(el float64, acc float32) (float32, error)) (float32, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceFloat64) ReduceWhileFloat64(acc float64, f func(el float64, acc float64) (float64, error)) (float64, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceFloat64) ReduceWhileInt(acc int, f func(el float64, acc int) (int, error)) (int, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceFloat64) ReduceWhileInt8(acc int8, f func(el float64, acc int8) (int8, error)) (int8, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceFloat64) ReduceWhileInt16(acc int16, f func(el float64, acc int16) (int16, error)) (int16, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceFloat64) ReduceWhileInt32(acc int32, f func(el float64, acc int32) (int32, error)) (int32, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceFloat64) ReduceWhileInt64(acc int64, f func(el float64, acc int64) (int64, error)) (int64, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceFloat64) ReduceWhileUint(acc uint, f func(el float64, acc uint) (uint, error)) (uint, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceFloat64) ReduceWhileUint8(acc uint8, f func(el float64, acc uint8) (uint8, error)) (uint8, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceFloat64) ReduceWhileUint16(acc uint16, f func(el float64, acc uint16) (uint16, error)) (uint16, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceFloat64) ReduceWhileUint32(acc uint32, f func(el float64, acc uint32) (uint32, error)) (uint32, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceFloat64) ReduceWhileUint64(acc uint64, f func(el float64, acc uint64) (uint64, error)) (uint64, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceFloat64) ReduceWhileInterface(acc interface{}, f func(el float64, acc interface{}) (interface{}, error)) (interface{}, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// Reverse returns given arr in reversed order
func (s SliceFloat64) Reverse() []float64 {
	if len(s.Data) <= 1 {
		return s.Data
	}
	result := make([]float64, 0, len(s.Data))
	for i := len(s.Data) - 1; i >= 0; i-- {
		result = append(result, s.Data[i])
	}
	return result
}

// Same returns true if all element in arr the same
func (s SliceFloat64) Same() bool {
	if len(s.Data) <= 1 {
		return true
	}
	for i := 0; i < len(s.Data)-1; i++ {
		if s.Data[i] != s.Data[i+1] {
			return false
		}
	}
	return true
}

// Scan is like Reduce, but returns slice of f results
func (s SliceFloat64) ScanBool(acc bool, f func(el float64, acc bool) bool) []bool {
	result := make([]bool, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceFloat64) ScanByte(acc byte, f func(el float64, acc byte) byte) []byte {
	result := make([]byte, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceFloat64) ScanString(acc string, f func(el float64, acc string) string) []string {
	result := make([]string, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceFloat64) ScanFloat32(acc float32, f func(el float64, acc float32) float32) []float32 {
	result := make([]float32, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceFloat64) ScanFloat64(acc float64, f func(el float64, acc float64) float64) []float64 {
	result := make([]float64, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceFloat64) ScanInt(acc int, f func(el float64, acc int) int) []int {
	result := make([]int, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceFloat64) ScanInt8(acc int8, f func(el float64, acc int8) int8) []int8 {
	result := make([]int8, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceFloat64) ScanInt16(acc int16, f func(el float64, acc int16) int16) []int16 {
	result := make([]int16, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceFloat64) ScanInt32(acc int32, f func(el float64, acc int32) int32) []int32 {
	result := make([]int32, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceFloat64) ScanInt64(acc int64, f func(el float64, acc int64) int64) []int64 {
	result := make([]int64, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceFloat64) ScanUint(acc uint, f func(el float64, acc uint) uint) []uint {
	result := make([]uint, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceFloat64) ScanUint8(acc uint8, f func(el float64, acc uint8) uint8) []uint8 {
	result := make([]uint8, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceFloat64) ScanUint16(acc uint16, f func(el float64, acc uint16) uint16) []uint16 {
	result := make([]uint16, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceFloat64) ScanUint32(acc uint32, f func(el float64, acc uint32) uint32) []uint32 {
	result := make([]uint32, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceFloat64) ScanUint64(acc uint64, f func(el float64, acc uint64) uint64) []uint64 {
	result := make([]uint64, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceFloat64) ScanInterface(acc interface{}, f func(el float64, acc interface{}) interface{}) []interface{} {
	result := make([]interface{}, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Shuffle in random order arr elements
func (s SliceFloat64) Shuffle() []float64 {
	if len(s.Data) <= 1 {
		return s.Data
	}
	rand.Seed(time.Now().UnixNano())
	swap := func(i, j int) {
		s.Data[i], s.Data[j] = s.Data[j], s.Data[i]
	}
	rand.Shuffle(len(s.Data), swap)
	return s.Data
}

// Sort returns sorted slice
func (s SliceFloat64) Sort() []float64 {
	if len(s.Data) <= 1 {
		return s.Data
	}
	less := func(i int, j int) bool {
		return s.Data[i] < s.Data[j]
	}
	sort.SliceStable(s.Data, less)
	return s.Data
}

// Sorted returns true if slice is sorted
func (s SliceFloat64) Sorted() bool {
	if len(s.Data) <= 1 {
		return true
	}
	for i := 1; i < len(s.Data); i++ {
		if s.Data[i-1] > s.Data[i] {
			return false
		}
	}
	return true
}

// Split splits arr by sep
func (s SliceFloat64) Split(sep float64) [][]float64 {
	result := make([][]float64, 0)
	curr := make([]float64, 0)
	for _, el := range s.Data {
		if el == sep {
			result = append(result, curr)
		} else {
			curr = append(curr, el)
		}
	}
	result = append(result, curr)
	return result
}

// StartsWith returns true if slice starts with the given prefix slice.
// If prefix is empty, it returns true.
func (s SliceFloat64) StartsWith(prefix []float64) bool {
	if len(prefix) > len(s.Data) {
		return false
	}
	for i, el := range prefix {
		if el != s.Data[i] {
			return false
		}
	}
	return true
}

// Sum return sum of all elements from arr
func (s SliceFloat64) Sum() float64 {
	var sum float64
	for _, el := range s.Data {
		sum += el
	}
	return sum
}

// TakeEvery returns slice of every nth elements
func (s SliceFloat64) TakeEvery(nth int) ([]float64, error) {
	if nth <= 0 {
		return s.Data, ErrNonPositiveValue
	}
	result := make([]float64, 0, len(s.Data))
	for i, el := range s.Data {
		if (i+1)%nth == 0 {
			result = append(result, el)
		}
	}
	return result, nil
}

// TakeRandom returns slice of count random elements from the slice
func (s SliceFloat64) TakeRandom(count int) ([]float64, error) {
	if count > len(s.Data) {
		return nil, ErrOutOfRange
	}
	if count <= 0 {
		return nil, ErrNonPositiveValue
	}

	rand.Seed(time.Now().UnixNano())
	swap := func(i, j int) {
		s.Data[i], s.Data[j] = s.Data[j], s.Data[i]
	}
	rand.Shuffle(len(s.Data), swap)
	return s.Data[:count], nil
}

// TakeWhile takes elements from arr while f returns true
func (s SliceFloat64) TakeWhile(f func(el float64) bool) []float64 {
	result := make([]float64, 0, len(s.Data))
	for _, el := range s.Data {
		if !f(el) {
			return result
		}
		result = append(result, el)
	}
	return result
}

// ToChannel returns channel with elements from the slice
func (s SliceFloat64) ToChannel() chan float64 {
	c := make(chan float64, 1)
	go func() {
		for _, el := range s.Data {
			c <- el
		}
		close(c)
	}()
	return c
}

// Uniq returns arr with only first occurences of every element.
func (s SliceFloat64) Uniq() []float64 {
	if len(s.Data) <= 1 {
		return s.Data
	}
	added := make(map[float64]struct{})
	nothing := struct{}{}
	result := make([]float64, 0, len(s.Data))
	for _, el := range s.Data {
		_, exists := added[el]
		if !exists {
			result = append(result, el)
			added[el] = nothing
		}
	}
	return result

}

// Window makes sliding window for a given slice:
// ({1,2,3}, 2) -> (1,2), (2,3)
func (s SliceFloat64) Window(size int) ([][]float64, error) {
	if size <= 0 {
		return nil, ErrNonPositiveValue
	}
	result := make([][]float64, 0, len(s.Data)/size)
	for i := 0; i <= len(s.Data)-size; i++ {
		chunk := s.Data[i : i+size]
		result = append(result, chunk)
	}
	return result, nil
}

// Without returns the slice with filtered out element
func (s SliceFloat64) Without(elements ...float64) []float64 {
	result := make([]float64, 0, len(s.Data))
	for _, el := range s.Data {
		allowed := true
		for _, other := range elements {
			if el == other {
				allowed = false
			}
		}
		if allowed {
			result = append(result, el)
		}
	}
	return result
}

// Concat concatenates given slices into a single slice.
func (s SlicesFloat64) Concat() []float64 {
	result := make([]float64, 0)
	for _, arr := range s.Data {
		result = append(result, arr...)
	}
	return result
}

// Product returns cortesian product of elements
// {{1, 2}, {3, 4}} -> {1, 3}, {1, 4}, {2, 3}, {2, 4}
func (s SlicesFloat64) Product() chan []float64 {
	c := make(chan []float64, 1)
	go s.product(c, []float64{}, 0)
	return c
}

// product is a core implementation of Product
func (s SlicesFloat64) product(c chan []float64, left []float64, pos int) {
	// iterate over the last array
	if pos == len(s.Data)-1 {
		for _, el := range s.Data[pos] {
			result := make([]float64, 0, len(left)+1)
			result = append(result, left...)
			result = append(result, el)
			c <- result
		}
		return
	}

	for _, el := range s.Data[pos] {
		result := make([]float64, 0, len(left)+1)
		result = append(result, left...)
		result = append(result, el)
		s.product(c, result, pos+1)
	}

	if pos == 0 {
		close(c)
	}
}

// Zip returns array of arrays of elements from given arrs
// on the same position
func (s SlicesFloat64) Zip() [][]float64 {
	size := len(s.Data[0])
	for _, arr := range s.Data[1:] {
		if len(arr) > size {
			size = len(arr)
		}
	}

	result := make([][]float64, 0, size)
	for i := 0; i <= size; i++ {
		chunk := make([]float64, 0, len(s.Data))
		for _, arr := range s.Data {
			chunk = append(chunk, arr[i])
		}
		result = append(result, chunk)
	}
	return result
}

// Channel is a set of operations with channel
type ChannelInt struct {
	Data chan int
}

// AsyncSlice is a set of operations to work with slice asynchronously
type AsyncSliceInt struct {
	Data    []int
	Workers int
}

// Sequence is a set of operations to generate sequences
type SequenceInt struct {
	ctx context.Context
}

// Pair is a set of functions for 2 values that you can pass into reduce-like funcs
type PairInt struct {
	// empty
}

// Slice is a set of operations to work with slice
type SliceInt struct {
	Data []int
}

// Slices is a set of operations to work with slice of slices
type SlicesInt struct {
	Data [][]int
}

// Any returns true if f returns true for any element in channel
func (c ChannelInt) Any(f func(el int) bool) bool {
	for el := range c.Data {
		if f(el) {
			return true
		}
	}
	return false
}

// All returns true if f returns true for all elements in channel
func (c ChannelInt) All(f func(el int) bool) bool {
	for el := range c.Data {
		if !f(el) {
			return false
		}
	}
	return true
}

// ChunkEvery returns channel with slices containing count elements each
func (c ChannelInt) ChunkEvery(count int) chan []int {
	chunks := make(chan []int, 1)
	go func() {
		chunk := make([]int, 0, count)
		i := 0
		for el := range c.Data {
			chunk = append(chunk, el)
			i++
			if i%count == 0 {
				i = 0
				chunks <- chunk
				chunk = make([]int, 0, count)
			}
		}
		if len(chunk) > 0 {
			chunks <- chunk
		}
		close(chunks)
	}()
	return chunks
}

// Count return count of el occurences in channel.
func (c ChannelInt) Count(el int) int {
	count := 0
	for val := range c.Data {
		if val == el {
			count++
		}
	}
	return count
}

// Drop drops first n elements from channel c and returns a new channel with the rest.
// It returns channel do be unblocking. If you want array instead, wrap result into TakeAll.
func (c ChannelInt) Drop(n int) chan int {
	result := make(chan int, 1)
	go func() {
		i := 0
		for el := range c.Data {
			if i >= n {
				result <- el
			}
			i++
		}
		close(result)
	}()
	return result
}

// Each calls f for every element in the channel
func (c ChannelInt) Each(f func(el int)) {
	for el := range c.Data {
		f(el)
	}
}

// Filter returns a new channel with elements from input channel
// for which f returns true
func (c ChannelInt) Filter(f func(el int) bool) chan int {
	result := make(chan int, 1)
	go func() {
		for el := range c.Data {
			if f(el) {
				result <- el
			}
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt) MapBool(f func(el int) bool) chan bool {
	result := make(chan bool, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt) MapByte(f func(el int) byte) chan byte {
	result := make(chan byte, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt) MapString(f func(el int) string) chan string {
	result := make(chan string, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt) MapFloat32(f func(el int) float32) chan float32 {
	result := make(chan float32, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt) MapFloat64(f func(el int) float64) chan float64 {
	result := make(chan float64, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt) MapInt(f func(el int) int) chan int {
	result := make(chan int, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt) MapInt8(f func(el int) int8) chan int8 {
	result := make(chan int8, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt) MapInt16(f func(el int) int16) chan int16 {
	result := make(chan int16, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt) MapInt32(f func(el int) int32) chan int32 {
	result := make(chan int32, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt) MapInt64(f func(el int) int64) chan int64 {
	result := make(chan int64, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt) MapUint(f func(el int) uint) chan uint {
	result := make(chan uint, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt) MapUint8(f func(el int) uint8) chan uint8 {
	result := make(chan uint8, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt) MapUint16(f func(el int) uint16) chan uint16 {
	result := make(chan uint16, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt) MapUint32(f func(el int) uint32) chan uint32 {
	result := make(chan uint32, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt) MapUint64(f func(el int) uint64) chan uint64 {
	result := make(chan uint64, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt) MapInterface(f func(el int) interface{}) chan interface{} {
	result := make(chan interface{}, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Max returns the maximal element from channel
func (c ChannelInt) Max() (int, error) {
	max, ok := <-c.Data
	if !ok {
		return max, ErrEmpty
	}
	for el := range c.Data {
		if el > max {
			max = el
		}
	}
	return max, nil
}

// Min returns the minimal element from channel
func (c ChannelInt) Min() (int, error) {
	min, ok := <-c.Data
	if !ok {
		return min, ErrEmpty
	}
	for el := range c.Data {
		if el < min {
			min = el
		}
	}
	return min, nil
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt) ReduceBool(acc bool, f func(el int, acc bool) bool) bool {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt) ReduceByte(acc byte, f func(el int, acc byte) byte) byte {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt) ReduceString(acc string, f func(el int, acc string) string) string {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt) ReduceFloat32(acc float32, f func(el int, acc float32) float32) float32 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt) ReduceFloat64(acc float64, f func(el int, acc float64) float64) float64 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt) ReduceInt(acc int, f func(el int, acc int) int) int {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt) ReduceInt8(acc int8, f func(el int, acc int8) int8) int8 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt) ReduceInt16(acc int16, f func(el int, acc int16) int16) int16 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt) ReduceInt32(acc int32, f func(el int, acc int32) int32) int32 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt) ReduceInt64(acc int64, f func(el int, acc int64) int64) int64 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt) ReduceUint(acc uint, f func(el int, acc uint) uint) uint {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt) ReduceUint8(acc uint8, f func(el int, acc uint8) uint8) uint8 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt) ReduceUint16(acc uint16, f func(el int, acc uint16) uint16) uint16 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt) ReduceUint32(acc uint32, f func(el int, acc uint32) uint32) uint32 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt) ReduceUint64(acc uint64, f func(el int, acc uint64) uint64) uint64 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt) ReduceInterface(acc interface{}, f func(el int, acc interface{}) interface{}) interface{} {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt) ScanBool(acc bool, f func(el int, acc bool) bool) chan bool {
	result := make(chan bool, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt) ScanByte(acc byte, f func(el int, acc byte) byte) chan byte {
	result := make(chan byte, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt) ScanString(acc string, f func(el int, acc string) string) chan string {
	result := make(chan string, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt) ScanFloat32(acc float32, f func(el int, acc float32) float32) chan float32 {
	result := make(chan float32, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt) ScanFloat64(acc float64, f func(el int, acc float64) float64) chan float64 {
	result := make(chan float64, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt) ScanInt(acc int, f func(el int, acc int) int) chan int {
	result := make(chan int, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt) ScanInt8(acc int8, f func(el int, acc int8) int8) chan int8 {
	result := make(chan int8, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt) ScanInt16(acc int16, f func(el int, acc int16) int16) chan int16 {
	result := make(chan int16, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt) ScanInt32(acc int32, f func(el int, acc int32) int32) chan int32 {
	result := make(chan int32, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt) ScanInt64(acc int64, f func(el int, acc int64) int64) chan int64 {
	result := make(chan int64, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt) ScanUint(acc uint, f func(el int, acc uint) uint) chan uint {
	result := make(chan uint, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt) ScanUint8(acc uint8, f func(el int, acc uint8) uint8) chan uint8 {
	result := make(chan uint8, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt) ScanUint16(acc uint16, f func(el int, acc uint16) uint16) chan uint16 {
	result := make(chan uint16, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt) ScanUint32(acc uint32, f func(el int, acc uint32) uint32) chan uint32 {
	result := make(chan uint32, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt) ScanUint64(acc uint64, f func(el int, acc uint64) uint64) chan uint64 {
	result := make(chan uint64, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt) ScanInterface(acc interface{}, f func(el int, acc interface{}) interface{}) chan interface{} {
	result := make(chan interface{}, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Sum returns sum of all elements from channel
func (c ChannelInt) Sum() int {
	var sum int
	for el := range c.Data {
		sum += el
	}
	return sum
}

// Take takes first count elements from the channel.
func (c ChannelInt) Take(count int) chan int {
	result := make(chan int, 1)
	go func() {
		defer close(result)
		if count <= 0 {
			return
		}
		i := 0
		for el := range c.Data {
			result <- el
			i++
			if i == count {
				return
			}
		}
	}()
	return result
}

// Tee returns 2 channels with elements from the input channel
func (c ChannelInt) Tee(count int) []chan int {
	channels := make([]chan int, 0, count)
	for i := 0; i < count; i++ {
		channels = append(channels, make(chan int, 1))
	}
	go func() {
		for el := range c.Data {
			wg := sync.WaitGroup{}
			putInto := func(ch chan int) {
				defer wg.Done()
				ch <- el
			}
			wg.Add(count)
			for _, ch := range channels {
				putInto(ch)
			}
			wg.Wait()
		}
		for _, ch := range channels {
			close(ch)
		}
	}()
	return channels
}

// ToSlice returns slice with all elements from channel.
func (c ChannelInt) ToSlice() []int {
	result := make([]int, 0)
	for val := range c.Data {
		result = append(result, val)
	}
	return result
}

// All returns true if f returns true for all elements in slice
func (s AsyncSliceInt) All(f func(el int) bool) bool {
	if len(s.Data) == 0 {
		return true
	}

	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int, result chan<- bool, ctx context.Context) {
		defer wg.Done()
		for {
			select {
			case <-ctx.Done():
				return
			case index, ok := <-jobs:
				if !ok {
					return
				}
				if !f(s.Data[index]) {
					result <- false
					return
				}
			}
		}
	}

	ctx, cancel := context.WithCancel(context.Background())
	// when we're returning the result, cancel all workers
	defer cancel()

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	result := make(chan bool, workers)
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs, result, ctx)
	}

	// close the result channel when all workers have done
	go func() {
		wg.Wait()
		close(result)
	}()

	// schedule the jobs: indices to check
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)

	for range result {
		return false
	}
	return true
}

// Any returns true if f returns true for any element from slice
func (s AsyncSliceInt) Any(f func(el int) bool) bool {
	if len(s.Data) == 0 {
		return false
	}

	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int, result chan<- bool, ctx context.Context) {
		defer wg.Done()
		for {
			select {
			case <-ctx.Done():
				return
			case index, ok := <-jobs:
				if !ok {
					return
				}
				if f(s.Data[index]) {
					result <- true
					return
				}
			}
		}
	}

	ctx, cancel := context.WithCancel(context.Background())
	// when we're returning the result, cancel all workers
	defer cancel()

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	result := make(chan bool, workers)
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs, result, ctx)
	}

	// close the result channel when all workers have done
	go func() {
		wg.Wait()
		close(result)
	}()

	// schedule the jobs: indices to check
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)

	for range result {
		return true
	}
	return false
}

// Each calls f for every element from slice
func (s AsyncSliceInt) Each(f func(el int)) {
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		defer wg.Done()
		for index := range jobs {
			f(s.Data[index])
		}
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
}

// Filter returns slice of element for which f returns true
func (s AsyncSliceInt) Filter(f func(el int) bool) []int {
	resultMap := make([]bool, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			if f(s.Data[index]) {
				resultMap[index] = true
			}
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()

	// return filtered results
	result := make([]int, 0, len(s.Data))
	for i, el := range s.Data {
		if resultMap[i] {
			result = append(result, el)
		}
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt) MapBool(f func(el int) bool) []bool {
	result := make([]bool, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt) MapByte(f func(el int) byte) []byte {
	result := make([]byte, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt) MapString(f func(el int) string) []string {
	result := make([]string, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt) MapFloat32(f func(el int) float32) []float32 {
	result := make([]float32, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt) MapFloat64(f func(el int) float64) []float64 {
	result := make([]float64, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt) MapInt(f func(el int) int) []int {
	result := make([]int, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt) MapInt8(f func(el int) int8) []int8 {
	result := make([]int8, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt) MapInt16(f func(el int) int16) []int16 {
	result := make([]int16, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt) MapInt32(f func(el int) int32) []int32 {
	result := make([]int32, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt) MapInt64(f func(el int) int64) []int64 {
	result := make([]int64, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt) MapUint(f func(el int) uint) []uint {
	result := make([]uint, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt) MapUint8(f func(el int) uint8) []uint8 {
	result := make([]uint8, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt) MapUint16(f func(el int) uint16) []uint16 {
	result := make([]uint16, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt) MapUint32(f func(el int) uint32) []uint32 {
	result := make([]uint32, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt) MapUint64(f func(el int) uint64) []uint64 {
	result := make([]uint64, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt) MapInterface(f func(el int) interface{}) []interface{} {
	result := make([]interface{}, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Reduce reduces slice to a single value with f
func (s AsyncSliceInt) Reduce(f func(left int, right int) int) int {
	if len(s.Data) == 0 {
		var tmp int
		return tmp
	}

	state := make([]int, len(s.Data))
	state = append(state, s.Data...)
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int, result chan<- int) {
		for index := range jobs {
			result <- f(state[index], state[index+1])
		}
		wg.Done()
	}

	for len(state) > 1 {
		// calculate workers count
		workers := s.Workers
		if workers == 0 || workers > len(state) {
			workers = len(state)
		}

		// run workers
		jobs := make(chan int, len(state))
		wg.Add(workers)
		result := make(chan int, 1)
		for i := 0; i < workers; i++ {
			go worker(jobs, result)
		}

		go func() {
			wg.Wait()
			close(result)
		}()

		// add indices into jobs for workers
		for i := 0; i < len(state)-1; i += 2 {
			jobs <- i
		}
		close(jobs)

		// collect new state
		newState := make([]int, 0, len(state)/2+len(state)%2)
		for el := range result {
			newState = append(newState, el)
		}
		if len(state)%2 == 1 {
			newState = append(newState, state[len(state)-1])
		}
		// put new state as current state after all
		state = newState
	}

	return state[0]
}

// Count is like Range, but infinite
func (s SequenceInt) Count(start int, step int) chan int {
	c := make(chan int, 1)
	go func() {
		defer close(c)
		for {
			select {
			case <-s.ctx.Done():
				return
			case c <- start:
				start += step
			}
		}
	}()
	return c
}

// Exponential generates elements from start with
// multiplication of value on factor on every step
func (s SequenceInt) Exponential(start int, factor int) chan int {
	c := make(chan int, 1)
	go func() {
		defer close(c)
		for {
			select {
			case <-s.ctx.Done():
				return
			case c <- start:
				start *= factor
			}
		}
	}()
	return c
}

// Iterate returns an infinite list of repeated applications of f to val
func (s SequenceInt) Iterate(val int, f func(val int) int) chan int {
	c := make(chan int, 1)
	go func() {
		defer close(c)
		for {
			select {
			case <-s.ctx.Done():
				return
			case c <- val:
				val = f(val)
			}
		}
	}()
	return c
}

// Range generates elements from start to end with given step
func (s SequenceInt) Range(start int, end int, step int) chan int {
	c := make(chan int, 1)
	pos := start <= end
	go func() {
		for pos && (start < end) || !pos && (start > end) {
			c <- start
			start += step
		}
		close(c)
	}()
	return c
}

// Repeat returns channel that produces val infinite times
func (s SequenceInt) Repeat(val int) chan int {
	c := make(chan int, 1)
	go func() {
		defer close(c)
		for {
			select {
			case <-s.ctx.Done():
				return
			case c <- val:
				continue
			}
		}
	}()
	return c
}

// Replicate returns channel that produces val n times
func (s SequenceInt) Replicate(val int, n int) chan int {
	c := make(chan int, 1)
	go func() {
		for i := 0; i < n; i++ {
			c <- val
		}
		close(c)
	}()
	return c
}

// Min returns minimal value
func (PairInt) Min(a int, b int) int {
	if a <= b {
		return a
	}
	return b
}

// Max returns maximal value
func (PairInt) Max(a int, b int) int {
	if a > b {
		return a
	}
	return b
}

// Any returns true if f returns true for any element in arr
func (s SliceInt) Any(f func(el int) bool) bool {
	for _, el := range s.Data {
		if f(el) {
			return true
		}
	}
	return false
}

// All returns true if f returns true for all elements in arr
func (s SliceInt) All(f func(el int) bool) bool {
	for _, el := range s.Data {
		if !f(el) {
			return false
		}
	}
	return true
}

// Choice chooses a random element from the slice
func (s SliceInt) Choice() (int, error) {
	if len(s.Data) == 0 {
		var tmp int
		return tmp, ErrEmpty
	}

	rand.Seed(time.Now().UnixNano())
	i := rand.Intn(len(s.Data))
	return s.Data[i], nil
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt) ChunkByBool(f func(el int) bool) [][]int {
	chunks := make([][]int, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt) ChunkByByte(f func(el int) byte) [][]int {
	chunks := make([][]int, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt) ChunkByString(f func(el int) string) [][]int {
	chunks := make([][]int, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt) ChunkByFloat32(f func(el int) float32) [][]int {
	chunks := make([][]int, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt) ChunkByFloat64(f func(el int) float64) [][]int {
	chunks := make([][]int, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt) ChunkByInt(f func(el int) int) [][]int {
	chunks := make([][]int, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt) ChunkByInt8(f func(el int) int8) [][]int {
	chunks := make([][]int, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt) ChunkByInt16(f func(el int) int16) [][]int {
	chunks := make([][]int, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt) ChunkByInt32(f func(el int) int32) [][]int {
	chunks := make([][]int, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt) ChunkByInt64(f func(el int) int64) [][]int {
	chunks := make([][]int, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt) ChunkByUint(f func(el int) uint) [][]int {
	chunks := make([][]int, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt) ChunkByUint8(f func(el int) uint8) [][]int {
	chunks := make([][]int, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt) ChunkByUint16(f func(el int) uint16) [][]int {
	chunks := make([][]int, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt) ChunkByUint32(f func(el int) uint32) [][]int {
	chunks := make([][]int, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt) ChunkByUint64(f func(el int) uint64) [][]int {
	chunks := make([][]int, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt) ChunkByInterface(f func(el int) interface{}) [][]int {
	chunks := make([][]int, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkEvery returns slice of slices containing count elements each
func (s SliceInt) ChunkEvery(count int) ([][]int, error) {
	chunks := make([][]int, 0)
	if count <= 0 {
		return chunks, ErrNegativeValue
	}
	chunk := make([]int, 0, count)
	for i, el := range s.Data {
		chunk = append(chunk, el)
		if (i+1)%count == 0 {
			chunks = append(chunks, chunk)
			chunk = make([]int, 0, count)
		}
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks, nil
}

// Contains returns true if el in arr.
func (s SliceInt) Contains(el int) bool {
	for _, val := range s.Data {
		if val == el {
			return true
		}
	}
	return false
}

// Count return count of el occurences in arr.
func (s SliceInt) Count(el int) int {
	count := 0
	for _, val := range s.Data {
		if val == el {
			count++
		}
	}
	return count
}

// CountBy returns how many times f returns true.
func (s SliceInt) CountBy(f func(el int) bool) int {
	count := 0
	for _, el := range s.Data {
		if f(el) {
			count++
		}
	}
	return count
}

// Cycle is an infinite loop over slice
func (s SliceInt) Cycle() chan int {
	c := make(chan int, 1)
	go func() {
		defer close(c)
		if len(s.Data) == 0 {
			return
		}
		for {
			for _, val := range s.Data {
				c <- val
			}
		}
	}()
	return c
}

// Dedup returns a given slice without consecutive duplicated elements
func (s SliceInt) Dedup() []int {
	if len(s.Data) == 0 {
		return s.Data
	}

	result := make([]int, 0, len(s.Data))
	prev := s.Data[0]
	result = append(result, prev)
	for _, el := range s.Data[1:] {
		if el != prev {
			result = append(result, el)
			prev = el
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt) DedupByBool(f func(el int) bool) []int {
	result := make([]int, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt) DedupByByte(f func(el int) byte) []int {
	result := make([]int, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt) DedupByString(f func(el int) string) []int {
	result := make([]int, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt) DedupByFloat32(f func(el int) float32) []int {
	result := make([]int, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt) DedupByFloat64(f func(el int) float64) []int {
	result := make([]int, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt) DedupByInt(f func(el int) int) []int {
	result := make([]int, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt) DedupByInt8(f func(el int) int8) []int {
	result := make([]int, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt) DedupByInt16(f func(el int) int16) []int {
	result := make([]int, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt) DedupByInt32(f func(el int) int32) []int {
	result := make([]int, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt) DedupByInt64(f func(el int) int64) []int {
	result := make([]int, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt) DedupByUint(f func(el int) uint) []int {
	result := make([]int, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt) DedupByUint8(f func(el int) uint8) []int {
	result := make([]int, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt) DedupByUint16(f func(el int) uint16) []int {
	result := make([]int, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt) DedupByUint32(f func(el int) uint32) []int {
	result := make([]int, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt) DedupByUint64(f func(el int) uint64) []int {
	result := make([]int, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt) DedupByInterface(f func(el int) interface{}) []int {
	result := make([]int, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// Delete deletes the first occurence of the element from the slice
func (s SliceInt) Delete(element int) []int {
	result := make([]int, 0, len(s.Data)-1)
	deleted := false
	for _, el := range s.Data {
		if !deleted && el == element {
			continue
		}
		result = append(result, el)
	}
	return result

}

// DeleteAt returns the slice without elements on given positions
func (s SliceInt) DeleteAt(index int) ([]int, error) {
	if index >= len(s.Data) {
		return s.Data, ErrOutOfRange
	}

	result := make([]int, 0, len(s.Data)-1)
	for i, el := range s.Data {
		if i != index {
			result = append(result, el)
		}
	}
	return result, nil
}

// DropEvery returns a slice of every nth element in the enumerable dropped,
// starting with the first element.
func (s SliceInt) DropEvery(nth int) ([]int, error) {
	if nth <= 0 {
		return s.Data, ErrNonPositiveValue
	}
	result := make([]int, 0, len(s.Data)/nth)
	for i, el := range s.Data {
		if (i+1)%nth != 0 {
			result = append(result, el)
		}
	}
	return result, nil
}

// DropWhile drops elements from arr while f returns true
func (s SliceInt) DropWhile(f func(arr int) bool) []int {
	result := make([]int, 0, len(s.Data))
	for _, el := range s.Data {
		if !f(el) {
			return result
		}
		result = append(result, el)
	}
	return result
}

// Each calls f for every element from arr
func (s SliceInt) Each(f func(el int)) {
	for _, el := range s.Data {
		f(el)
	}
}

// Equal returns true if slices are equal
func (s SliceInt) Equal(other []int) bool {
	if len(s.Data) != len(other) {
		return false
	}
	for i, el := range other {
		if s.Data[i] != el {
			return false
		}
	}
	return true
}

// Filter returns slice of T for which F returned true
func (s SliceInt) Filter(f func(el int) bool) []int {
	result := make([]int, 0, len(s.Data))
	for _, el := range s.Data {
		if f(el) {
			result = append(result, el)
		}
	}
	return result
}

// Find returns the first element for which f returns true
func (s SliceInt) Find(f func(el int) bool) (int, error) {
	for _, el := range s.Data {
		if f(el) {
			return el, nil
		}
	}
	var tmp int
	return tmp, ErrNotFound
}

// FindIndex is like Find, but return element index instead of element itself
func (s SliceInt) FindIndex(f func(el int) bool) (int, error) {
	for i, el := range s.Data {
		if f(el) {
			return i, nil
		}
	}
	return 0, ErrNotFound
}

// Join concatenates elements of the slice to create a single string.
func (s SliceInt) Join(sep string) string {
	strs := make([]string, 0, len(s.Data))
	for _, el := range s.Data {
		strs = append(strs, string(el))
	}
	return strings.Join(strs, sep)
}

// GroupBy groups element from array by value returned by f
func (s SliceInt) GroupByBool(f func(el int) bool) map[bool][]int {
	result := make(map[bool][]int)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt) GroupByByte(f func(el int) byte) map[byte][]int {
	result := make(map[byte][]int)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt) GroupByString(f func(el int) string) map[string][]int {
	result := make(map[string][]int)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt) GroupByFloat32(f func(el int) float32) map[float32][]int {
	result := make(map[float32][]int)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt) GroupByFloat64(f func(el int) float64) map[float64][]int {
	result := make(map[float64][]int)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt) GroupByInt(f func(el int) int) map[int][]int {
	result := make(map[int][]int)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt) GroupByInt8(f func(el int) int8) map[int8][]int {
	result := make(map[int8][]int)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt) GroupByInt16(f func(el int) int16) map[int16][]int {
	result := make(map[int16][]int)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt) GroupByInt32(f func(el int) int32) map[int32][]int {
	result := make(map[int32][]int)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt) GroupByInt64(f func(el int) int64) map[int64][]int {
	result := make(map[int64][]int)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt) GroupByUint(f func(el int) uint) map[uint][]int {
	result := make(map[uint][]int)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt) GroupByUint8(f func(el int) uint8) map[uint8][]int {
	result := make(map[uint8][]int)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt) GroupByUint16(f func(el int) uint16) map[uint16][]int {
	result := make(map[uint16][]int)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt) GroupByUint32(f func(el int) uint32) map[uint32][]int {
	result := make(map[uint32][]int)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt) GroupByUint64(f func(el int) uint64) map[uint64][]int {
	result := make(map[uint64][]int)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt) GroupByInterface(f func(el int) interface{}) map[interface{}][]int {
	result := make(map[interface{}][]int)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// InsertAt returns the slice with element inserted at given index.
func (s SliceInt) InsertAt(index int, element int) ([]int, error) {
	result := make([]int, 0, len(s.Data)+1)

	// insert at the end
	if index == len(s.Data) || index == -1 {
		result = append(result, s.Data...)
		result = append(result, element)
		return result, nil
	}

	if index > len(s.Data) {
		return s.Data, ErrOutOfRange
	}
	if index < 0 {
		return s.Data, ErrNegativeValue
	}

	for i, el := range s.Data {
		if i == index {
			result = append(result, element)
		}
		result = append(result, el)
	}
	return result, nil
}

// Intersperse inserts el between each element of arr
func (s SliceInt) Intersperse(el int) []int {
	if len(s.Data) == 0 {
		return s.Data
	}
	result := make([]int, 0, len(s.Data)*2-1)
	result = append(result, s.Data[0])
	for _, val := range s.Data[1:] {
		result = append(result, el, val)
	}
	return result
}

// Last returns the last element from the slice
func (s SliceInt) Last() (int, error) {
	if len(s.Data) == 0 {
		var tmp int
		return tmp, ErrEmpty
	}
	return s.Data[len(s.Data)-1], nil
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt) MapBool(f func(el int) bool) []bool {
	result := make([]bool, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt) MapByte(f func(el int) byte) []byte {
	result := make([]byte, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt) MapString(f func(el int) string) []string {
	result := make([]string, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt) MapFloat32(f func(el int) float32) []float32 {
	result := make([]float32, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt) MapFloat64(f func(el int) float64) []float64 {
	result := make([]float64, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt) MapInt(f func(el int) int) []int {
	result := make([]int, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt) MapInt8(f func(el int) int8) []int8 {
	result := make([]int8, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt) MapInt16(f func(el int) int16) []int16 {
	result := make([]int16, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt) MapInt32(f func(el int) int32) []int32 {
	result := make([]int32, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt) MapInt64(f func(el int) int64) []int64 {
	result := make([]int64, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt) MapUint(f func(el int) uint) []uint {
	result := make([]uint, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt) MapUint8(f func(el int) uint8) []uint8 {
	result := make([]uint8, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt) MapUint16(f func(el int) uint16) []uint16 {
	result := make([]uint16, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt) MapUint32(f func(el int) uint32) []uint32 {
	result := make([]uint32, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt) MapUint64(f func(el int) uint64) []uint64 {
	result := make([]uint64, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt) MapInterface(f func(el int) interface{}) []interface{} {
	result := make([]interface{}, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Max returns the maximal element from arr
func (s SliceInt) Max() (int, error) {
	if len(s.Data) == 0 {
		var tmp int
		return tmp, ErrEmpty
	}

	max := s.Data[0]
	for _, el := range s.Data[1:] {
		if el > max {
			max = el
		}
	}
	return max, nil
}

// Min returns the minimal element from arr
func (s SliceInt) Min() (int, error) {
	if len(s.Data) == 0 {
		var tmp int
		return tmp, ErrEmpty
	}

	min := s.Data[0]
	for _, el := range s.Data[1:] {
		if el < min {
			min = el
		}
	}
	return min, nil
}

// Permutations returns successive size-length permutations of elements from the slice.
// {1, 2, 3} -> {1, 2}, {1, 3}, {2, 1}, {2, 3}, {3, 1}, {3, 2}
func (s SliceInt) Permutations(size int) chan []int {
	c := make(chan []int, 1)
	go func() {
		if len(s.Data) > 0 {
			s.permutations(c, size, []int{}, s.Data)
		}
		close(c)
	}()
	return c
}

// permutations is a core implementation for Permutations
func (s SliceInt) permutations(c chan []int, size int, left []int, right []int) {
	if len(left) == size || len(right) == 0 {
		c <- left
		return
	}

	for i, el := range right {
		newLeft := make([]int, 0, len(left)+1)
		newLeft = append(newLeft, left...)
		newLeft = append(newLeft, el)

		newRight := make([]int, 0, len(right)-1)
		for j, other := range right {
			if j != i {
				newRight = append(newRight, other)
			}
		}
		s.permutations(c, size, newLeft, newRight)
	}
}

// Product returns cortesian product of elements
// {{1, 2}, {3, 4}} -> {1, 3}, {1, 4}, {2, 3}, {2, 4}
func (s SliceInt) Product(repeat int) chan []int {
	c := make(chan []int, 1)
	go s.product(c, repeat, []int{}, 0)
	return c
}

// product is a core implementation for Product
func (s SliceInt) product(c chan []int, repeat int, left []int, pos int) {
	// iterate over the last array
	if pos == repeat-1 {
		for _, el := range s.Data {
			result := make([]int, 0, len(left)+1)
			result = append(result, left...)
			result = append(result, el)
			c <- result
		}
		return
	}

	for _, el := range s.Data {
		result := make([]int, 0, len(left)+1)
		result = append(result, left...)
		result = append(result, el)
		s.product(c, repeat, result, pos+1)
	}

	if pos == 0 {
		close(c)
	}
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt) ReduceBool(acc bool, f func(el int, acc bool) bool) bool {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt) ReduceByte(acc byte, f func(el int, acc byte) byte) byte {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt) ReduceString(acc string, f func(el int, acc string) string) string {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt) ReduceFloat32(acc float32, f func(el int, acc float32) float32) float32 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt) ReduceFloat64(acc float64, f func(el int, acc float64) float64) float64 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt) ReduceInt(acc int, f func(el int, acc int) int) int {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt) ReduceInt8(acc int8, f func(el int, acc int8) int8) int8 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt) ReduceInt16(acc int16, f func(el int, acc int16) int16) int16 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt) ReduceInt32(acc int32, f func(el int, acc int32) int32) int32 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt) ReduceInt64(acc int64, f func(el int, acc int64) int64) int64 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt) ReduceUint(acc uint, f func(el int, acc uint) uint) uint {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt) ReduceUint8(acc uint8, f func(el int, acc uint8) uint8) uint8 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt) ReduceUint16(acc uint16, f func(el int, acc uint16) uint16) uint16 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt) ReduceUint32(acc uint32, f func(el int, acc uint32) uint32) uint32 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt) ReduceUint64(acc uint64, f func(el int, acc uint64) uint64) uint64 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt) ReduceInterface(acc interface{}, f func(el int, acc interface{}) interface{}) interface{} {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt) ReduceWhileBool(acc bool, f func(el int, acc bool) (bool, error)) (bool, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt) ReduceWhileByte(acc byte, f func(el int, acc byte) (byte, error)) (byte, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt) ReduceWhileString(acc string, f func(el int, acc string) (string, error)) (string, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt) ReduceWhileFloat32(acc float32, f func(el int, acc float32) (float32, error)) (float32, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt) ReduceWhileFloat64(acc float64, f func(el int, acc float64) (float64, error)) (float64, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt) ReduceWhileInt(acc int, f func(el int, acc int) (int, error)) (int, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt) ReduceWhileInt8(acc int8, f func(el int, acc int8) (int8, error)) (int8, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt) ReduceWhileInt16(acc int16, f func(el int, acc int16) (int16, error)) (int16, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt) ReduceWhileInt32(acc int32, f func(el int, acc int32) (int32, error)) (int32, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt) ReduceWhileInt64(acc int64, f func(el int, acc int64) (int64, error)) (int64, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt) ReduceWhileUint(acc uint, f func(el int, acc uint) (uint, error)) (uint, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt) ReduceWhileUint8(acc uint8, f func(el int, acc uint8) (uint8, error)) (uint8, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt) ReduceWhileUint16(acc uint16, f func(el int, acc uint16) (uint16, error)) (uint16, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt) ReduceWhileUint32(acc uint32, f func(el int, acc uint32) (uint32, error)) (uint32, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt) ReduceWhileUint64(acc uint64, f func(el int, acc uint64) (uint64, error)) (uint64, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt) ReduceWhileInterface(acc interface{}, f func(el int, acc interface{}) (interface{}, error)) (interface{}, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// Reverse returns given arr in reversed order
func (s SliceInt) Reverse() []int {
	if len(s.Data) <= 1 {
		return s.Data
	}
	result := make([]int, 0, len(s.Data))
	for i := len(s.Data) - 1; i >= 0; i-- {
		result = append(result, s.Data[i])
	}
	return result
}

// Same returns true if all element in arr the same
func (s SliceInt) Same() bool {
	if len(s.Data) <= 1 {
		return true
	}
	for i := 0; i < len(s.Data)-1; i++ {
		if s.Data[i] != s.Data[i+1] {
			return false
		}
	}
	return true
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt) ScanBool(acc bool, f func(el int, acc bool) bool) []bool {
	result := make([]bool, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt) ScanByte(acc byte, f func(el int, acc byte) byte) []byte {
	result := make([]byte, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt) ScanString(acc string, f func(el int, acc string) string) []string {
	result := make([]string, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt) ScanFloat32(acc float32, f func(el int, acc float32) float32) []float32 {
	result := make([]float32, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt) ScanFloat64(acc float64, f func(el int, acc float64) float64) []float64 {
	result := make([]float64, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt) ScanInt(acc int, f func(el int, acc int) int) []int {
	result := make([]int, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt) ScanInt8(acc int8, f func(el int, acc int8) int8) []int8 {
	result := make([]int8, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt) ScanInt16(acc int16, f func(el int, acc int16) int16) []int16 {
	result := make([]int16, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt) ScanInt32(acc int32, f func(el int, acc int32) int32) []int32 {
	result := make([]int32, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt) ScanInt64(acc int64, f func(el int, acc int64) int64) []int64 {
	result := make([]int64, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt) ScanUint(acc uint, f func(el int, acc uint) uint) []uint {
	result := make([]uint, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt) ScanUint8(acc uint8, f func(el int, acc uint8) uint8) []uint8 {
	result := make([]uint8, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt) ScanUint16(acc uint16, f func(el int, acc uint16) uint16) []uint16 {
	result := make([]uint16, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt) ScanUint32(acc uint32, f func(el int, acc uint32) uint32) []uint32 {
	result := make([]uint32, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt) ScanUint64(acc uint64, f func(el int, acc uint64) uint64) []uint64 {
	result := make([]uint64, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt) ScanInterface(acc interface{}, f func(el int, acc interface{}) interface{}) []interface{} {
	result := make([]interface{}, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Shuffle in random order arr elements
func (s SliceInt) Shuffle() []int {
	if len(s.Data) <= 1 {
		return s.Data
	}
	rand.Seed(time.Now().UnixNano())
	swap := func(i, j int) {
		s.Data[i], s.Data[j] = s.Data[j], s.Data[i]
	}
	rand.Shuffle(len(s.Data), swap)
	return s.Data
}

// Sort returns sorted slice
func (s SliceInt) Sort() []int {
	if len(s.Data) <= 1 {
		return s.Data
	}
	less := func(i int, j int) bool {
		return s.Data[i] < s.Data[j]
	}
	sort.SliceStable(s.Data, less)
	return s.Data
}

// Sorted returns true if slice is sorted
func (s SliceInt) Sorted() bool {
	if len(s.Data) <= 1 {
		return true
	}
	for i := 1; i < len(s.Data); i++ {
		if s.Data[i-1] > s.Data[i] {
			return false
		}
	}
	return true
}

// Split splits arr by sep
func (s SliceInt) Split(sep int) [][]int {
	result := make([][]int, 0)
	curr := make([]int, 0)
	for _, el := range s.Data {
		if el == sep {
			result = append(result, curr)
		} else {
			curr = append(curr, el)
		}
	}
	result = append(result, curr)
	return result
}

// StartsWith returns true if slice starts with the given prefix slice.
// If prefix is empty, it returns true.
func (s SliceInt) StartsWith(prefix []int) bool {
	if len(prefix) > len(s.Data) {
		return false
	}
	for i, el := range prefix {
		if el != s.Data[i] {
			return false
		}
	}
	return true
}

// Sum return sum of all elements from arr
func (s SliceInt) Sum() int {
	var sum int
	for _, el := range s.Data {
		sum += el
	}
	return sum
}

// TakeEvery returns slice of every nth elements
func (s SliceInt) TakeEvery(nth int) ([]int, error) {
	if nth <= 0 {
		return s.Data, ErrNonPositiveValue
	}
	result := make([]int, 0, len(s.Data))
	for i, el := range s.Data {
		if (i+1)%nth == 0 {
			result = append(result, el)
		}
	}
	return result, nil
}

// TakeRandom returns slice of count random elements from the slice
func (s SliceInt) TakeRandom(count int) ([]int, error) {
	if count > len(s.Data) {
		return nil, ErrOutOfRange
	}
	if count <= 0 {
		return nil, ErrNonPositiveValue
	}

	rand.Seed(time.Now().UnixNano())
	swap := func(i, j int) {
		s.Data[i], s.Data[j] = s.Data[j], s.Data[i]
	}
	rand.Shuffle(len(s.Data), swap)
	return s.Data[:count], nil
}

// TakeWhile takes elements from arr while f returns true
func (s SliceInt) TakeWhile(f func(el int) bool) []int {
	result := make([]int, 0, len(s.Data))
	for _, el := range s.Data {
		if !f(el) {
			return result
		}
		result = append(result, el)
	}
	return result
}

// ToChannel returns channel with elements from the slice
func (s SliceInt) ToChannel() chan int {
	c := make(chan int, 1)
	go func() {
		for _, el := range s.Data {
			c <- el
		}
		close(c)
	}()
	return c
}

// Uniq returns arr with only first occurences of every element.
func (s SliceInt) Uniq() []int {
	if len(s.Data) <= 1 {
		return s.Data
	}
	added := make(map[int]struct{})
	nothing := struct{}{}
	result := make([]int, 0, len(s.Data))
	for _, el := range s.Data {
		_, exists := added[el]
		if !exists {
			result = append(result, el)
			added[el] = nothing
		}
	}
	return result

}

// Window makes sliding window for a given slice:
// ({1,2,3}, 2) -> (1,2), (2,3)
func (s SliceInt) Window(size int) ([][]int, error) {
	if size <= 0 {
		return nil, ErrNonPositiveValue
	}
	result := make([][]int, 0, len(s.Data)/size)
	for i := 0; i <= len(s.Data)-size; i++ {
		chunk := s.Data[i : i+size]
		result = append(result, chunk)
	}
	return result, nil
}

// Without returns the slice with filtered out element
func (s SliceInt) Without(elements ...int) []int {
	result := make([]int, 0, len(s.Data))
	for _, el := range s.Data {
		allowed := true
		for _, other := range elements {
			if el == other {
				allowed = false
			}
		}
		if allowed {
			result = append(result, el)
		}
	}
	return result
}

// Concat concatenates given slices into a single slice.
func (s SlicesInt) Concat() []int {
	result := make([]int, 0)
	for _, arr := range s.Data {
		result = append(result, arr...)
	}
	return result
}

// Product returns cortesian product of elements
// {{1, 2}, {3, 4}} -> {1, 3}, {1, 4}, {2, 3}, {2, 4}
func (s SlicesInt) Product() chan []int {
	c := make(chan []int, 1)
	go s.product(c, []int{}, 0)
	return c
}

// product is a core implementation of Product
func (s SlicesInt) product(c chan []int, left []int, pos int) {
	// iterate over the last array
	if pos == len(s.Data)-1 {
		for _, el := range s.Data[pos] {
			result := make([]int, 0, len(left)+1)
			result = append(result, left...)
			result = append(result, el)
			c <- result
		}
		return
	}

	for _, el := range s.Data[pos] {
		result := make([]int, 0, len(left)+1)
		result = append(result, left...)
		result = append(result, el)
		s.product(c, result, pos+1)
	}

	if pos == 0 {
		close(c)
	}
}

// Zip returns array of arrays of elements from given arrs
// on the same position
func (s SlicesInt) Zip() [][]int {
	size := len(s.Data[0])
	for _, arr := range s.Data[1:] {
		if len(arr) > size {
			size = len(arr)
		}
	}

	result := make([][]int, 0, size)
	for i := 0; i <= size; i++ {
		chunk := make([]int, 0, len(s.Data))
		for _, arr := range s.Data {
			chunk = append(chunk, arr[i])
		}
		result = append(result, chunk)
	}
	return result
}

// Channel is a set of operations with channel
type ChannelInt8 struct {
	Data chan int8
}

// AsyncSlice is a set of operations to work with slice asynchronously
type AsyncSliceInt8 struct {
	Data    []int8
	Workers int
}

// Sequence is a set of operations to generate sequences
type SequenceInt8 struct {
	ctx context.Context
}

// Pair is a set of functions for 2 values that you can pass into reduce-like funcs
type PairInt8 struct {
	// empty
}

// Slice is a set of operations to work with slice
type SliceInt8 struct {
	Data []int8
}

// Slices is a set of operations to work with slice of slices
type SlicesInt8 struct {
	Data [][]int8
}

// Any returns true if f returns true for any element in channel
func (c ChannelInt8) Any(f func(el int8) bool) bool {
	for el := range c.Data {
		if f(el) {
			return true
		}
	}
	return false
}

// All returns true if f returns true for all elements in channel
func (c ChannelInt8) All(f func(el int8) bool) bool {
	for el := range c.Data {
		if !f(el) {
			return false
		}
	}
	return true
}

// ChunkEvery returns channel with slices containing count elements each
func (c ChannelInt8) ChunkEvery(count int) chan []int8 {
	chunks := make(chan []int8, 1)
	go func() {
		chunk := make([]int8, 0, count)
		i := 0
		for el := range c.Data {
			chunk = append(chunk, el)
			i++
			if i%count == 0 {
				i = 0
				chunks <- chunk
				chunk = make([]int8, 0, count)
			}
		}
		if len(chunk) > 0 {
			chunks <- chunk
		}
		close(chunks)
	}()
	return chunks
}

// Count return count of el occurences in channel.
func (c ChannelInt8) Count(el int8) int {
	count := 0
	for val := range c.Data {
		if val == el {
			count++
		}
	}
	return count
}

// Drop drops first n elements from channel c and returns a new channel with the rest.
// It returns channel do be unblocking. If you want array instead, wrap result into TakeAll.
func (c ChannelInt8) Drop(n int) chan int8 {
	result := make(chan int8, 1)
	go func() {
		i := 0
		for el := range c.Data {
			if i >= n {
				result <- el
			}
			i++
		}
		close(result)
	}()
	return result
}

// Each calls f for every element in the channel
func (c ChannelInt8) Each(f func(el int8)) {
	for el := range c.Data {
		f(el)
	}
}

// Filter returns a new channel with elements from input channel
// for which f returns true
func (c ChannelInt8) Filter(f func(el int8) bool) chan int8 {
	result := make(chan int8, 1)
	go func() {
		for el := range c.Data {
			if f(el) {
				result <- el
			}
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt8) MapBool(f func(el int8) bool) chan bool {
	result := make(chan bool, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt8) MapByte(f func(el int8) byte) chan byte {
	result := make(chan byte, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt8) MapString(f func(el int8) string) chan string {
	result := make(chan string, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt8) MapFloat32(f func(el int8) float32) chan float32 {
	result := make(chan float32, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt8) MapFloat64(f func(el int8) float64) chan float64 {
	result := make(chan float64, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt8) MapInt(f func(el int8) int) chan int {
	result := make(chan int, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt8) MapInt8(f func(el int8) int8) chan int8 {
	result := make(chan int8, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt8) MapInt16(f func(el int8) int16) chan int16 {
	result := make(chan int16, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt8) MapInt32(f func(el int8) int32) chan int32 {
	result := make(chan int32, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt8) MapInt64(f func(el int8) int64) chan int64 {
	result := make(chan int64, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt8) MapUint(f func(el int8) uint) chan uint {
	result := make(chan uint, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt8) MapUint8(f func(el int8) uint8) chan uint8 {
	result := make(chan uint8, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt8) MapUint16(f func(el int8) uint16) chan uint16 {
	result := make(chan uint16, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt8) MapUint32(f func(el int8) uint32) chan uint32 {
	result := make(chan uint32, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt8) MapUint64(f func(el int8) uint64) chan uint64 {
	result := make(chan uint64, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt8) MapInterface(f func(el int8) interface{}) chan interface{} {
	result := make(chan interface{}, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Max returns the maximal element from channel
func (c ChannelInt8) Max() (int8, error) {
	max, ok := <-c.Data
	if !ok {
		return max, ErrEmpty
	}
	for el := range c.Data {
		if el > max {
			max = el
		}
	}
	return max, nil
}

// Min returns the minimal element from channel
func (c ChannelInt8) Min() (int8, error) {
	min, ok := <-c.Data
	if !ok {
		return min, ErrEmpty
	}
	for el := range c.Data {
		if el < min {
			min = el
		}
	}
	return min, nil
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt8) ReduceBool(acc bool, f func(el int8, acc bool) bool) bool {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt8) ReduceByte(acc byte, f func(el int8, acc byte) byte) byte {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt8) ReduceString(acc string, f func(el int8, acc string) string) string {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt8) ReduceFloat32(acc float32, f func(el int8, acc float32) float32) float32 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt8) ReduceFloat64(acc float64, f func(el int8, acc float64) float64) float64 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt8) ReduceInt(acc int, f func(el int8, acc int) int) int {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt8) ReduceInt8(acc int8, f func(el int8, acc int8) int8) int8 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt8) ReduceInt16(acc int16, f func(el int8, acc int16) int16) int16 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt8) ReduceInt32(acc int32, f func(el int8, acc int32) int32) int32 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt8) ReduceInt64(acc int64, f func(el int8, acc int64) int64) int64 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt8) ReduceUint(acc uint, f func(el int8, acc uint) uint) uint {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt8) ReduceUint8(acc uint8, f func(el int8, acc uint8) uint8) uint8 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt8) ReduceUint16(acc uint16, f func(el int8, acc uint16) uint16) uint16 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt8) ReduceUint32(acc uint32, f func(el int8, acc uint32) uint32) uint32 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt8) ReduceUint64(acc uint64, f func(el int8, acc uint64) uint64) uint64 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt8) ReduceInterface(acc interface{}, f func(el int8, acc interface{}) interface{}) interface{} {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt8) ScanBool(acc bool, f func(el int8, acc bool) bool) chan bool {
	result := make(chan bool, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt8) ScanByte(acc byte, f func(el int8, acc byte) byte) chan byte {
	result := make(chan byte, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt8) ScanString(acc string, f func(el int8, acc string) string) chan string {
	result := make(chan string, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt8) ScanFloat32(acc float32, f func(el int8, acc float32) float32) chan float32 {
	result := make(chan float32, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt8) ScanFloat64(acc float64, f func(el int8, acc float64) float64) chan float64 {
	result := make(chan float64, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt8) ScanInt(acc int, f func(el int8, acc int) int) chan int {
	result := make(chan int, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt8) ScanInt8(acc int8, f func(el int8, acc int8) int8) chan int8 {
	result := make(chan int8, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt8) ScanInt16(acc int16, f func(el int8, acc int16) int16) chan int16 {
	result := make(chan int16, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt8) ScanInt32(acc int32, f func(el int8, acc int32) int32) chan int32 {
	result := make(chan int32, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt8) ScanInt64(acc int64, f func(el int8, acc int64) int64) chan int64 {
	result := make(chan int64, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt8) ScanUint(acc uint, f func(el int8, acc uint) uint) chan uint {
	result := make(chan uint, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt8) ScanUint8(acc uint8, f func(el int8, acc uint8) uint8) chan uint8 {
	result := make(chan uint8, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt8) ScanUint16(acc uint16, f func(el int8, acc uint16) uint16) chan uint16 {
	result := make(chan uint16, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt8) ScanUint32(acc uint32, f func(el int8, acc uint32) uint32) chan uint32 {
	result := make(chan uint32, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt8) ScanUint64(acc uint64, f func(el int8, acc uint64) uint64) chan uint64 {
	result := make(chan uint64, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt8) ScanInterface(acc interface{}, f func(el int8, acc interface{}) interface{}) chan interface{} {
	result := make(chan interface{}, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Sum returns sum of all elements from channel
func (c ChannelInt8) Sum() int8 {
	var sum int8
	for el := range c.Data {
		sum += el
	}
	return sum
}

// Take takes first count elements from the channel.
func (c ChannelInt8) Take(count int) chan int8 {
	result := make(chan int8, 1)
	go func() {
		defer close(result)
		if count <= 0 {
			return
		}
		i := 0
		for el := range c.Data {
			result <- el
			i++
			if i == count {
				return
			}
		}
	}()
	return result
}

// Tee returns 2 channels with elements from the input channel
func (c ChannelInt8) Tee(count int) []chan int8 {
	channels := make([]chan int8, 0, count)
	for i := 0; i < count; i++ {
		channels = append(channels, make(chan int8, 1))
	}
	go func() {
		for el := range c.Data {
			wg := sync.WaitGroup{}
			putInto := func(ch chan int8) {
				defer wg.Done()
				ch <- el
			}
			wg.Add(count)
			for _, ch := range channels {
				putInto(ch)
			}
			wg.Wait()
		}
		for _, ch := range channels {
			close(ch)
		}
	}()
	return channels
}

// ToSlice returns slice with all elements from channel.
func (c ChannelInt8) ToSlice() []int8 {
	result := make([]int8, 0)
	for val := range c.Data {
		result = append(result, val)
	}
	return result
}

// All returns true if f returns true for all elements in slice
func (s AsyncSliceInt8) All(f func(el int8) bool) bool {
	if len(s.Data) == 0 {
		return true
	}

	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int, result chan<- bool, ctx context.Context) {
		defer wg.Done()
		for {
			select {
			case <-ctx.Done():
				return
			case index, ok := <-jobs:
				if !ok {
					return
				}
				if !f(s.Data[index]) {
					result <- false
					return
				}
			}
		}
	}

	ctx, cancel := context.WithCancel(context.Background())
	// when we're returning the result, cancel all workers
	defer cancel()

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	result := make(chan bool, workers)
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs, result, ctx)
	}

	// close the result channel when all workers have done
	go func() {
		wg.Wait()
		close(result)
	}()

	// schedule the jobs: indices to check
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)

	for range result {
		return false
	}
	return true
}

// Any returns true if f returns true for any element from slice
func (s AsyncSliceInt8) Any(f func(el int8) bool) bool {
	if len(s.Data) == 0 {
		return false
	}

	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int, result chan<- bool, ctx context.Context) {
		defer wg.Done()
		for {
			select {
			case <-ctx.Done():
				return
			case index, ok := <-jobs:
				if !ok {
					return
				}
				if f(s.Data[index]) {
					result <- true
					return
				}
			}
		}
	}

	ctx, cancel := context.WithCancel(context.Background())
	// when we're returning the result, cancel all workers
	defer cancel()

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	result := make(chan bool, workers)
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs, result, ctx)
	}

	// close the result channel when all workers have done
	go func() {
		wg.Wait()
		close(result)
	}()

	// schedule the jobs: indices to check
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)

	for range result {
		return true
	}
	return false
}

// Each calls f for every element from slice
func (s AsyncSliceInt8) Each(f func(el int8)) {
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		defer wg.Done()
		for index := range jobs {
			f(s.Data[index])
		}
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
}

// Filter returns slice of element for which f returns true
func (s AsyncSliceInt8) Filter(f func(el int8) bool) []int8 {
	resultMap := make([]bool, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			if f(s.Data[index]) {
				resultMap[index] = true
			}
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()

	// return filtered results
	result := make([]int8, 0, len(s.Data))
	for i, el := range s.Data {
		if resultMap[i] {
			result = append(result, el)
		}
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt8) MapBool(f func(el int8) bool) []bool {
	result := make([]bool, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt8) MapByte(f func(el int8) byte) []byte {
	result := make([]byte, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt8) MapString(f func(el int8) string) []string {
	result := make([]string, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt8) MapFloat32(f func(el int8) float32) []float32 {
	result := make([]float32, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt8) MapFloat64(f func(el int8) float64) []float64 {
	result := make([]float64, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt8) MapInt(f func(el int8) int) []int {
	result := make([]int, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt8) MapInt8(f func(el int8) int8) []int8 {
	result := make([]int8, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt8) MapInt16(f func(el int8) int16) []int16 {
	result := make([]int16, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt8) MapInt32(f func(el int8) int32) []int32 {
	result := make([]int32, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt8) MapInt64(f func(el int8) int64) []int64 {
	result := make([]int64, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt8) MapUint(f func(el int8) uint) []uint {
	result := make([]uint, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt8) MapUint8(f func(el int8) uint8) []uint8 {
	result := make([]uint8, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt8) MapUint16(f func(el int8) uint16) []uint16 {
	result := make([]uint16, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt8) MapUint32(f func(el int8) uint32) []uint32 {
	result := make([]uint32, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt8) MapUint64(f func(el int8) uint64) []uint64 {
	result := make([]uint64, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt8) MapInterface(f func(el int8) interface{}) []interface{} {
	result := make([]interface{}, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Reduce reduces slice to a single value with f
func (s AsyncSliceInt8) Reduce(f func(left int8, right int8) int8) int8 {
	if len(s.Data) == 0 {
		var tmp int8
		return tmp
	}

	state := make([]int8, len(s.Data))
	state = append(state, s.Data...)
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int, result chan<- int8) {
		for index := range jobs {
			result <- f(state[index], state[index+1])
		}
		wg.Done()
	}

	for len(state) > 1 {
		// calculate workers count
		workers := s.Workers
		if workers == 0 || workers > len(state) {
			workers = len(state)
		}

		// run workers
		jobs := make(chan int, len(state))
		wg.Add(workers)
		result := make(chan int8, 1)
		for i := 0; i < workers; i++ {
			go worker(jobs, result)
		}

		go func() {
			wg.Wait()
			close(result)
		}()

		// add indices into jobs for workers
		for i := 0; i < len(state)-1; i += 2 {
			jobs <- i
		}
		close(jobs)

		// collect new state
		newState := make([]int8, 0, len(state)/2+len(state)%2)
		for el := range result {
			newState = append(newState, el)
		}
		if len(state)%2 == 1 {
			newState = append(newState, state[len(state)-1])
		}
		// put new state as current state after all
		state = newState
	}

	return state[0]
}

// Count is like Range, but infinite
func (s SequenceInt8) Count(start int8, step int8) chan int8 {
	c := make(chan int8, 1)
	go func() {
		defer close(c)
		for {
			select {
			case <-s.ctx.Done():
				return
			case c <- start:
				start += step
			}
		}
	}()
	return c
}

// Exponential generates elements from start with
// multiplication of value on factor on every step
func (s SequenceInt8) Exponential(start int8, factor int8) chan int8 {
	c := make(chan int8, 1)
	go func() {
		defer close(c)
		for {
			select {
			case <-s.ctx.Done():
				return
			case c <- start:
				start *= factor
			}
		}
	}()
	return c
}

// Iterate returns an infinite list of repeated applications of f to val
func (s SequenceInt8) Iterate(val int8, f func(val int8) int8) chan int8 {
	c := make(chan int8, 1)
	go func() {
		defer close(c)
		for {
			select {
			case <-s.ctx.Done():
				return
			case c <- val:
				val = f(val)
			}
		}
	}()
	return c
}

// Range generates elements from start to end with given step
func (s SequenceInt8) Range(start int8, end int8, step int8) chan int8 {
	c := make(chan int8, 1)
	pos := start <= end
	go func() {
		for pos && (start < end) || !pos && (start > end) {
			c <- start
			start += step
		}
		close(c)
	}()
	return c
}

// Repeat returns channel that produces val infinite times
func (s SequenceInt8) Repeat(val int8) chan int8 {
	c := make(chan int8, 1)
	go func() {
		defer close(c)
		for {
			select {
			case <-s.ctx.Done():
				return
			case c <- val:
				continue
			}
		}
	}()
	return c
}

// Replicate returns channel that produces val n times
func (s SequenceInt8) Replicate(val int8, n int) chan int8 {
	c := make(chan int8, 1)
	go func() {
		for i := 0; i < n; i++ {
			c <- val
		}
		close(c)
	}()
	return c
}

// Min returns minimal value
func (PairInt8) Min(a int8, b int8) int8 {
	if a <= b {
		return a
	}
	return b
}

// Max returns maximal value
func (PairInt8) Max(a int8, b int8) int8 {
	if a > b {
		return a
	}
	return b
}

// Any returns true if f returns true for any element in arr
func (s SliceInt8) Any(f func(el int8) bool) bool {
	for _, el := range s.Data {
		if f(el) {
			return true
		}
	}
	return false
}

// All returns true if f returns true for all elements in arr
func (s SliceInt8) All(f func(el int8) bool) bool {
	for _, el := range s.Data {
		if !f(el) {
			return false
		}
	}
	return true
}

// Choice chooses a random element from the slice
func (s SliceInt8) Choice() (int8, error) {
	if len(s.Data) == 0 {
		var tmp int8
		return tmp, ErrEmpty
	}

	rand.Seed(time.Now().UnixNano())
	i := rand.Intn(len(s.Data))
	return s.Data[i], nil
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt8) ChunkByBool(f func(el int8) bool) [][]int8 {
	chunks := make([][]int8, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int8, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int8, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt8) ChunkByByte(f func(el int8) byte) [][]int8 {
	chunks := make([][]int8, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int8, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int8, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt8) ChunkByString(f func(el int8) string) [][]int8 {
	chunks := make([][]int8, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int8, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int8, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt8) ChunkByFloat32(f func(el int8) float32) [][]int8 {
	chunks := make([][]int8, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int8, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int8, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt8) ChunkByFloat64(f func(el int8) float64) [][]int8 {
	chunks := make([][]int8, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int8, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int8, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt8) ChunkByInt(f func(el int8) int) [][]int8 {
	chunks := make([][]int8, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int8, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int8, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt8) ChunkByInt8(f func(el int8) int8) [][]int8 {
	chunks := make([][]int8, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int8, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int8, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt8) ChunkByInt16(f func(el int8) int16) [][]int8 {
	chunks := make([][]int8, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int8, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int8, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt8) ChunkByInt32(f func(el int8) int32) [][]int8 {
	chunks := make([][]int8, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int8, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int8, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt8) ChunkByInt64(f func(el int8) int64) [][]int8 {
	chunks := make([][]int8, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int8, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int8, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt8) ChunkByUint(f func(el int8) uint) [][]int8 {
	chunks := make([][]int8, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int8, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int8, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt8) ChunkByUint8(f func(el int8) uint8) [][]int8 {
	chunks := make([][]int8, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int8, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int8, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt8) ChunkByUint16(f func(el int8) uint16) [][]int8 {
	chunks := make([][]int8, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int8, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int8, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt8) ChunkByUint32(f func(el int8) uint32) [][]int8 {
	chunks := make([][]int8, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int8, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int8, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt8) ChunkByUint64(f func(el int8) uint64) [][]int8 {
	chunks := make([][]int8, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int8, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int8, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt8) ChunkByInterface(f func(el int8) interface{}) [][]int8 {
	chunks := make([][]int8, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int8, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int8, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkEvery returns slice of slices containing count elements each
func (s SliceInt8) ChunkEvery(count int) ([][]int8, error) {
	chunks := make([][]int8, 0)
	if count <= 0 {
		return chunks, ErrNegativeValue
	}
	chunk := make([]int8, 0, count)
	for i, el := range s.Data {
		chunk = append(chunk, el)
		if (i+1)%count == 0 {
			chunks = append(chunks, chunk)
			chunk = make([]int8, 0, count)
		}
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks, nil
}

// Contains returns true if el in arr.
func (s SliceInt8) Contains(el int8) bool {
	for _, val := range s.Data {
		if val == el {
			return true
		}
	}
	return false
}

// Count return count of el occurences in arr.
func (s SliceInt8) Count(el int8) int {
	count := 0
	for _, val := range s.Data {
		if val == el {
			count++
		}
	}
	return count
}

// CountBy returns how many times f returns true.
func (s SliceInt8) CountBy(f func(el int8) bool) int {
	count := 0
	for _, el := range s.Data {
		if f(el) {
			count++
		}
	}
	return count
}

// Cycle is an infinite loop over slice
func (s SliceInt8) Cycle() chan int8 {
	c := make(chan int8, 1)
	go func() {
		defer close(c)
		if len(s.Data) == 0 {
			return
		}
		for {
			for _, val := range s.Data {
				c <- val
			}
		}
	}()
	return c
}

// Dedup returns a given slice without consecutive duplicated elements
func (s SliceInt8) Dedup() []int8 {
	if len(s.Data) == 0 {
		return s.Data
	}

	result := make([]int8, 0, len(s.Data))
	prev := s.Data[0]
	result = append(result, prev)
	for _, el := range s.Data[1:] {
		if el != prev {
			result = append(result, el)
			prev = el
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt8) DedupByBool(f func(el int8) bool) []int8 {
	result := make([]int8, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt8) DedupByByte(f func(el int8) byte) []int8 {
	result := make([]int8, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt8) DedupByString(f func(el int8) string) []int8 {
	result := make([]int8, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt8) DedupByFloat32(f func(el int8) float32) []int8 {
	result := make([]int8, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt8) DedupByFloat64(f func(el int8) float64) []int8 {
	result := make([]int8, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt8) DedupByInt(f func(el int8) int) []int8 {
	result := make([]int8, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt8) DedupByInt8(f func(el int8) int8) []int8 {
	result := make([]int8, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt8) DedupByInt16(f func(el int8) int16) []int8 {
	result := make([]int8, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt8) DedupByInt32(f func(el int8) int32) []int8 {
	result := make([]int8, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt8) DedupByInt64(f func(el int8) int64) []int8 {
	result := make([]int8, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt8) DedupByUint(f func(el int8) uint) []int8 {
	result := make([]int8, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt8) DedupByUint8(f func(el int8) uint8) []int8 {
	result := make([]int8, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt8) DedupByUint16(f func(el int8) uint16) []int8 {
	result := make([]int8, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt8) DedupByUint32(f func(el int8) uint32) []int8 {
	result := make([]int8, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt8) DedupByUint64(f func(el int8) uint64) []int8 {
	result := make([]int8, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt8) DedupByInterface(f func(el int8) interface{}) []int8 {
	result := make([]int8, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// Delete deletes the first occurence of the element from the slice
func (s SliceInt8) Delete(element int8) []int8 {
	result := make([]int8, 0, len(s.Data)-1)
	deleted := false
	for _, el := range s.Data {
		if !deleted && el == element {
			continue
		}
		result = append(result, el)
	}
	return result

}

// DeleteAt returns the slice without elements on given positions
func (s SliceInt8) DeleteAt(index int) ([]int8, error) {
	if index >= len(s.Data) {
		return s.Data, ErrOutOfRange
	}

	result := make([]int8, 0, len(s.Data)-1)
	for i, el := range s.Data {
		if i != index {
			result = append(result, el)
		}
	}
	return result, nil
}

// DropEvery returns a slice of every nth element in the enumerable dropped,
// starting with the first element.
func (s SliceInt8) DropEvery(nth int) ([]int8, error) {
	if nth <= 0 {
		return s.Data, ErrNonPositiveValue
	}
	result := make([]int8, 0, len(s.Data)/nth)
	for i, el := range s.Data {
		if (i+1)%nth != 0 {
			result = append(result, el)
		}
	}
	return result, nil
}

// DropWhile drops elements from arr while f returns true
func (s SliceInt8) DropWhile(f func(arr int8) bool) []int8 {
	result := make([]int8, 0, len(s.Data))
	for _, el := range s.Data {
		if !f(el) {
			return result
		}
		result = append(result, el)
	}
	return result
}

// Each calls f for every element from arr
func (s SliceInt8) Each(f func(el int8)) {
	for _, el := range s.Data {
		f(el)
	}
}

// Equal returns true if slices are equal
func (s SliceInt8) Equal(other []int8) bool {
	if len(s.Data) != len(other) {
		return false
	}
	for i, el := range other {
		if s.Data[i] != el {
			return false
		}
	}
	return true
}

// Filter returns slice of T for which F returned true
func (s SliceInt8) Filter(f func(el int8) bool) []int8 {
	result := make([]int8, 0, len(s.Data))
	for _, el := range s.Data {
		if f(el) {
			result = append(result, el)
		}
	}
	return result
}

// Find returns the first element for which f returns true
func (s SliceInt8) Find(f func(el int8) bool) (int8, error) {
	for _, el := range s.Data {
		if f(el) {
			return el, nil
		}
	}
	var tmp int8
	return tmp, ErrNotFound
}

// FindIndex is like Find, but return element index instead of element itself
func (s SliceInt8) FindIndex(f func(el int8) bool) (int, error) {
	for i, el := range s.Data {
		if f(el) {
			return i, nil
		}
	}
	return 0, ErrNotFound
}

// Join concatenates elements of the slice to create a single string.
func (s SliceInt8) Join(sep string) string {
	strs := make([]string, 0, len(s.Data))
	for _, el := range s.Data {
		strs = append(strs, string(el))
	}
	return strings.Join(strs, sep)
}

// GroupBy groups element from array by value returned by f
func (s SliceInt8) GroupByBool(f func(el int8) bool) map[bool][]int8 {
	result := make(map[bool][]int8)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int8, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt8) GroupByByte(f func(el int8) byte) map[byte][]int8 {
	result := make(map[byte][]int8)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int8, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt8) GroupByString(f func(el int8) string) map[string][]int8 {
	result := make(map[string][]int8)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int8, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt8) GroupByFloat32(f func(el int8) float32) map[float32][]int8 {
	result := make(map[float32][]int8)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int8, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt8) GroupByFloat64(f func(el int8) float64) map[float64][]int8 {
	result := make(map[float64][]int8)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int8, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt8) GroupByInt(f func(el int8) int) map[int][]int8 {
	result := make(map[int][]int8)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int8, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt8) GroupByInt8(f func(el int8) int8) map[int8][]int8 {
	result := make(map[int8][]int8)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int8, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt8) GroupByInt16(f func(el int8) int16) map[int16][]int8 {
	result := make(map[int16][]int8)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int8, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt8) GroupByInt32(f func(el int8) int32) map[int32][]int8 {
	result := make(map[int32][]int8)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int8, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt8) GroupByInt64(f func(el int8) int64) map[int64][]int8 {
	result := make(map[int64][]int8)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int8, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt8) GroupByUint(f func(el int8) uint) map[uint][]int8 {
	result := make(map[uint][]int8)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int8, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt8) GroupByUint8(f func(el int8) uint8) map[uint8][]int8 {
	result := make(map[uint8][]int8)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int8, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt8) GroupByUint16(f func(el int8) uint16) map[uint16][]int8 {
	result := make(map[uint16][]int8)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int8, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt8) GroupByUint32(f func(el int8) uint32) map[uint32][]int8 {
	result := make(map[uint32][]int8)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int8, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt8) GroupByUint64(f func(el int8) uint64) map[uint64][]int8 {
	result := make(map[uint64][]int8)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int8, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt8) GroupByInterface(f func(el int8) interface{}) map[interface{}][]int8 {
	result := make(map[interface{}][]int8)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int8, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// InsertAt returns the slice with element inserted at given index.
func (s SliceInt8) InsertAt(index int, element int8) ([]int8, error) {
	result := make([]int8, 0, len(s.Data)+1)

	// insert at the end
	if index == len(s.Data) || index == -1 {
		result = append(result, s.Data...)
		result = append(result, element)
		return result, nil
	}

	if index > len(s.Data) {
		return s.Data, ErrOutOfRange
	}
	if index < 0 {
		return s.Data, ErrNegativeValue
	}

	for i, el := range s.Data {
		if i == index {
			result = append(result, element)
		}
		result = append(result, el)
	}
	return result, nil
}

// Intersperse inserts el between each element of arr
func (s SliceInt8) Intersperse(el int8) []int8 {
	if len(s.Data) == 0 {
		return s.Data
	}
	result := make([]int8, 0, len(s.Data)*2-1)
	result = append(result, s.Data[0])
	for _, val := range s.Data[1:] {
		result = append(result, el, val)
	}
	return result
}

// Last returns the last element from the slice
func (s SliceInt8) Last() (int8, error) {
	if len(s.Data) == 0 {
		var tmp int8
		return tmp, ErrEmpty
	}
	return s.Data[len(s.Data)-1], nil
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt8) MapBool(f func(el int8) bool) []bool {
	result := make([]bool, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt8) MapByte(f func(el int8) byte) []byte {
	result := make([]byte, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt8) MapString(f func(el int8) string) []string {
	result := make([]string, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt8) MapFloat32(f func(el int8) float32) []float32 {
	result := make([]float32, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt8) MapFloat64(f func(el int8) float64) []float64 {
	result := make([]float64, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt8) MapInt(f func(el int8) int) []int {
	result := make([]int, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt8) MapInt8(f func(el int8) int8) []int8 {
	result := make([]int8, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt8) MapInt16(f func(el int8) int16) []int16 {
	result := make([]int16, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt8) MapInt32(f func(el int8) int32) []int32 {
	result := make([]int32, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt8) MapInt64(f func(el int8) int64) []int64 {
	result := make([]int64, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt8) MapUint(f func(el int8) uint) []uint {
	result := make([]uint, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt8) MapUint8(f func(el int8) uint8) []uint8 {
	result := make([]uint8, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt8) MapUint16(f func(el int8) uint16) []uint16 {
	result := make([]uint16, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt8) MapUint32(f func(el int8) uint32) []uint32 {
	result := make([]uint32, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt8) MapUint64(f func(el int8) uint64) []uint64 {
	result := make([]uint64, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt8) MapInterface(f func(el int8) interface{}) []interface{} {
	result := make([]interface{}, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Max returns the maximal element from arr
func (s SliceInt8) Max() (int8, error) {
	if len(s.Data) == 0 {
		var tmp int8
		return tmp, ErrEmpty
	}

	max := s.Data[0]
	for _, el := range s.Data[1:] {
		if el > max {
			max = el
		}
	}
	return max, nil
}

// Min returns the minimal element from arr
func (s SliceInt8) Min() (int8, error) {
	if len(s.Data) == 0 {
		var tmp int8
		return tmp, ErrEmpty
	}

	min := s.Data[0]
	for _, el := range s.Data[1:] {
		if el < min {
			min = el
		}
	}
	return min, nil
}

// Permutations returns successive size-length permutations of elements from the slice.
// {1, 2, 3} -> {1, 2}, {1, 3}, {2, 1}, {2, 3}, {3, 1}, {3, 2}
func (s SliceInt8) Permutations(size int) chan []int8 {
	c := make(chan []int8, 1)
	go func() {
		if len(s.Data) > 0 {
			s.permutations(c, size, []int8{}, s.Data)
		}
		close(c)
	}()
	return c
}

// permutations is a core implementation for Permutations
func (s SliceInt8) permutations(c chan []int8, size int, left []int8, right []int8) {
	if len(left) == size || len(right) == 0 {
		c <- left
		return
	}

	for i, el := range right {
		newLeft := make([]int8, 0, len(left)+1)
		newLeft = append(newLeft, left...)
		newLeft = append(newLeft, el)

		newRight := make([]int8, 0, len(right)-1)
		for j, other := range right {
			if j != i {
				newRight = append(newRight, other)
			}
		}
		s.permutations(c, size, newLeft, newRight)
	}
}

// Product returns cortesian product of elements
// {{1, 2}, {3, 4}} -> {1, 3}, {1, 4}, {2, 3}, {2, 4}
func (s SliceInt8) Product(repeat int) chan []int8 {
	c := make(chan []int8, 1)
	go s.product(c, repeat, []int8{}, 0)
	return c
}

// product is a core implementation for Product
func (s SliceInt8) product(c chan []int8, repeat int, left []int8, pos int) {
	// iterate over the last array
	if pos == repeat-1 {
		for _, el := range s.Data {
			result := make([]int8, 0, len(left)+1)
			result = append(result, left...)
			result = append(result, el)
			c <- result
		}
		return
	}

	for _, el := range s.Data {
		result := make([]int8, 0, len(left)+1)
		result = append(result, left...)
		result = append(result, el)
		s.product(c, repeat, result, pos+1)
	}

	if pos == 0 {
		close(c)
	}
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt8) ReduceBool(acc bool, f func(el int8, acc bool) bool) bool {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt8) ReduceByte(acc byte, f func(el int8, acc byte) byte) byte {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt8) ReduceString(acc string, f func(el int8, acc string) string) string {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt8) ReduceFloat32(acc float32, f func(el int8, acc float32) float32) float32 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt8) ReduceFloat64(acc float64, f func(el int8, acc float64) float64) float64 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt8) ReduceInt(acc int, f func(el int8, acc int) int) int {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt8) ReduceInt8(acc int8, f func(el int8, acc int8) int8) int8 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt8) ReduceInt16(acc int16, f func(el int8, acc int16) int16) int16 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt8) ReduceInt32(acc int32, f func(el int8, acc int32) int32) int32 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt8) ReduceInt64(acc int64, f func(el int8, acc int64) int64) int64 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt8) ReduceUint(acc uint, f func(el int8, acc uint) uint) uint {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt8) ReduceUint8(acc uint8, f func(el int8, acc uint8) uint8) uint8 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt8) ReduceUint16(acc uint16, f func(el int8, acc uint16) uint16) uint16 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt8) ReduceUint32(acc uint32, f func(el int8, acc uint32) uint32) uint32 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt8) ReduceUint64(acc uint64, f func(el int8, acc uint64) uint64) uint64 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt8) ReduceInterface(acc interface{}, f func(el int8, acc interface{}) interface{}) interface{} {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt8) ReduceWhileBool(acc bool, f func(el int8, acc bool) (bool, error)) (bool, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt8) ReduceWhileByte(acc byte, f func(el int8, acc byte) (byte, error)) (byte, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt8) ReduceWhileString(acc string, f func(el int8, acc string) (string, error)) (string, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt8) ReduceWhileFloat32(acc float32, f func(el int8, acc float32) (float32, error)) (float32, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt8) ReduceWhileFloat64(acc float64, f func(el int8, acc float64) (float64, error)) (float64, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt8) ReduceWhileInt(acc int, f func(el int8, acc int) (int, error)) (int, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt8) ReduceWhileInt8(acc int8, f func(el int8, acc int8) (int8, error)) (int8, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt8) ReduceWhileInt16(acc int16, f func(el int8, acc int16) (int16, error)) (int16, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt8) ReduceWhileInt32(acc int32, f func(el int8, acc int32) (int32, error)) (int32, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt8) ReduceWhileInt64(acc int64, f func(el int8, acc int64) (int64, error)) (int64, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt8) ReduceWhileUint(acc uint, f func(el int8, acc uint) (uint, error)) (uint, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt8) ReduceWhileUint8(acc uint8, f func(el int8, acc uint8) (uint8, error)) (uint8, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt8) ReduceWhileUint16(acc uint16, f func(el int8, acc uint16) (uint16, error)) (uint16, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt8) ReduceWhileUint32(acc uint32, f func(el int8, acc uint32) (uint32, error)) (uint32, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt8) ReduceWhileUint64(acc uint64, f func(el int8, acc uint64) (uint64, error)) (uint64, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt8) ReduceWhileInterface(acc interface{}, f func(el int8, acc interface{}) (interface{}, error)) (interface{}, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// Reverse returns given arr in reversed order
func (s SliceInt8) Reverse() []int8 {
	if len(s.Data) <= 1 {
		return s.Data
	}
	result := make([]int8, 0, len(s.Data))
	for i := len(s.Data) - 1; i >= 0; i-- {
		result = append(result, s.Data[i])
	}
	return result
}

// Same returns true if all element in arr the same
func (s SliceInt8) Same() bool {
	if len(s.Data) <= 1 {
		return true
	}
	for i := 0; i < len(s.Data)-1; i++ {
		if s.Data[i] != s.Data[i+1] {
			return false
		}
	}
	return true
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt8) ScanBool(acc bool, f func(el int8, acc bool) bool) []bool {
	result := make([]bool, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt8) ScanByte(acc byte, f func(el int8, acc byte) byte) []byte {
	result := make([]byte, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt8) ScanString(acc string, f func(el int8, acc string) string) []string {
	result := make([]string, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt8) ScanFloat32(acc float32, f func(el int8, acc float32) float32) []float32 {
	result := make([]float32, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt8) ScanFloat64(acc float64, f func(el int8, acc float64) float64) []float64 {
	result := make([]float64, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt8) ScanInt(acc int, f func(el int8, acc int) int) []int {
	result := make([]int, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt8) ScanInt8(acc int8, f func(el int8, acc int8) int8) []int8 {
	result := make([]int8, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt8) ScanInt16(acc int16, f func(el int8, acc int16) int16) []int16 {
	result := make([]int16, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt8) ScanInt32(acc int32, f func(el int8, acc int32) int32) []int32 {
	result := make([]int32, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt8) ScanInt64(acc int64, f func(el int8, acc int64) int64) []int64 {
	result := make([]int64, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt8) ScanUint(acc uint, f func(el int8, acc uint) uint) []uint {
	result := make([]uint, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt8) ScanUint8(acc uint8, f func(el int8, acc uint8) uint8) []uint8 {
	result := make([]uint8, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt8) ScanUint16(acc uint16, f func(el int8, acc uint16) uint16) []uint16 {
	result := make([]uint16, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt8) ScanUint32(acc uint32, f func(el int8, acc uint32) uint32) []uint32 {
	result := make([]uint32, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt8) ScanUint64(acc uint64, f func(el int8, acc uint64) uint64) []uint64 {
	result := make([]uint64, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt8) ScanInterface(acc interface{}, f func(el int8, acc interface{}) interface{}) []interface{} {
	result := make([]interface{}, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Shuffle in random order arr elements
func (s SliceInt8) Shuffle() []int8 {
	if len(s.Data) <= 1 {
		return s.Data
	}
	rand.Seed(time.Now().UnixNano())
	swap := func(i, j int) {
		s.Data[i], s.Data[j] = s.Data[j], s.Data[i]
	}
	rand.Shuffle(len(s.Data), swap)
	return s.Data
}

// Sort returns sorted slice
func (s SliceInt8) Sort() []int8 {
	if len(s.Data) <= 1 {
		return s.Data
	}
	less := func(i int, j int) bool {
		return s.Data[i] < s.Data[j]
	}
	sort.SliceStable(s.Data, less)
	return s.Data
}

// Sorted returns true if slice is sorted
func (s SliceInt8) Sorted() bool {
	if len(s.Data) <= 1 {
		return true
	}
	for i := 1; i < len(s.Data); i++ {
		if s.Data[i-1] > s.Data[i] {
			return false
		}
	}
	return true
}

// Split splits arr by sep
func (s SliceInt8) Split(sep int8) [][]int8 {
	result := make([][]int8, 0)
	curr := make([]int8, 0)
	for _, el := range s.Data {
		if el == sep {
			result = append(result, curr)
		} else {
			curr = append(curr, el)
		}
	}
	result = append(result, curr)
	return result
}

// StartsWith returns true if slice starts with the given prefix slice.
// If prefix is empty, it returns true.
func (s SliceInt8) StartsWith(prefix []int8) bool {
	if len(prefix) > len(s.Data) {
		return false
	}
	for i, el := range prefix {
		if el != s.Data[i] {
			return false
		}
	}
	return true
}

// Sum return sum of all elements from arr
func (s SliceInt8) Sum() int8 {
	var sum int8
	for _, el := range s.Data {
		sum += el
	}
	return sum
}

// TakeEvery returns slice of every nth elements
func (s SliceInt8) TakeEvery(nth int) ([]int8, error) {
	if nth <= 0 {
		return s.Data, ErrNonPositiveValue
	}
	result := make([]int8, 0, len(s.Data))
	for i, el := range s.Data {
		if (i+1)%nth == 0 {
			result = append(result, el)
		}
	}
	return result, nil
}

// TakeRandom returns slice of count random elements from the slice
func (s SliceInt8) TakeRandom(count int) ([]int8, error) {
	if count > len(s.Data) {
		return nil, ErrOutOfRange
	}
	if count <= 0 {
		return nil, ErrNonPositiveValue
	}

	rand.Seed(time.Now().UnixNano())
	swap := func(i, j int) {
		s.Data[i], s.Data[j] = s.Data[j], s.Data[i]
	}
	rand.Shuffle(len(s.Data), swap)
	return s.Data[:count], nil
}

// TakeWhile takes elements from arr while f returns true
func (s SliceInt8) TakeWhile(f func(el int8) bool) []int8 {
	result := make([]int8, 0, len(s.Data))
	for _, el := range s.Data {
		if !f(el) {
			return result
		}
		result = append(result, el)
	}
	return result
}

// ToChannel returns channel with elements from the slice
func (s SliceInt8) ToChannel() chan int8 {
	c := make(chan int8, 1)
	go func() {
		for _, el := range s.Data {
			c <- el
		}
		close(c)
	}()
	return c
}

// Uniq returns arr with only first occurences of every element.
func (s SliceInt8) Uniq() []int8 {
	if len(s.Data) <= 1 {
		return s.Data
	}
	added := make(map[int8]struct{})
	nothing := struct{}{}
	result := make([]int8, 0, len(s.Data))
	for _, el := range s.Data {
		_, exists := added[el]
		if !exists {
			result = append(result, el)
			added[el] = nothing
		}
	}
	return result

}

// Window makes sliding window for a given slice:
// ({1,2,3}, 2) -> (1,2), (2,3)
func (s SliceInt8) Window(size int) ([][]int8, error) {
	if size <= 0 {
		return nil, ErrNonPositiveValue
	}
	result := make([][]int8, 0, len(s.Data)/size)
	for i := 0; i <= len(s.Data)-size; i++ {
		chunk := s.Data[i : i+size]
		result = append(result, chunk)
	}
	return result, nil
}

// Without returns the slice with filtered out element
func (s SliceInt8) Without(elements ...int8) []int8 {
	result := make([]int8, 0, len(s.Data))
	for _, el := range s.Data {
		allowed := true
		for _, other := range elements {
			if el == other {
				allowed = false
			}
		}
		if allowed {
			result = append(result, el)
		}
	}
	return result
}

// Concat concatenates given slices into a single slice.
func (s SlicesInt8) Concat() []int8 {
	result := make([]int8, 0)
	for _, arr := range s.Data {
		result = append(result, arr...)
	}
	return result
}

// Product returns cortesian product of elements
// {{1, 2}, {3, 4}} -> {1, 3}, {1, 4}, {2, 3}, {2, 4}
func (s SlicesInt8) Product() chan []int8 {
	c := make(chan []int8, 1)
	go s.product(c, []int8{}, 0)
	return c
}

// product is a core implementation of Product
func (s SlicesInt8) product(c chan []int8, left []int8, pos int) {
	// iterate over the last array
	if pos == len(s.Data)-1 {
		for _, el := range s.Data[pos] {
			result := make([]int8, 0, len(left)+1)
			result = append(result, left...)
			result = append(result, el)
			c <- result
		}
		return
	}

	for _, el := range s.Data[pos] {
		result := make([]int8, 0, len(left)+1)
		result = append(result, left...)
		result = append(result, el)
		s.product(c, result, pos+1)
	}

	if pos == 0 {
		close(c)
	}
}

// Zip returns array of arrays of elements from given arrs
// on the same position
func (s SlicesInt8) Zip() [][]int8 {
	size := len(s.Data[0])
	for _, arr := range s.Data[1:] {
		if len(arr) > size {
			size = len(arr)
		}
	}

	result := make([][]int8, 0, size)
	for i := 0; i <= size; i++ {
		chunk := make([]int8, 0, len(s.Data))
		for _, arr := range s.Data {
			chunk = append(chunk, arr[i])
		}
		result = append(result, chunk)
	}
	return result
}

// Channel is a set of operations with channel
type ChannelInt16 struct {
	Data chan int16
}

// AsyncSlice is a set of operations to work with slice asynchronously
type AsyncSliceInt16 struct {
	Data    []int16
	Workers int
}

// Sequence is a set of operations to generate sequences
type SequenceInt16 struct {
	ctx context.Context
}

// Pair is a set of functions for 2 values that you can pass into reduce-like funcs
type PairInt16 struct {
	// empty
}

// Slice is a set of operations to work with slice
type SliceInt16 struct {
	Data []int16
}

// Slices is a set of operations to work with slice of slices
type SlicesInt16 struct {
	Data [][]int16
}

// Any returns true if f returns true for any element in channel
func (c ChannelInt16) Any(f func(el int16) bool) bool {
	for el := range c.Data {
		if f(el) {
			return true
		}
	}
	return false
}

// All returns true if f returns true for all elements in channel
func (c ChannelInt16) All(f func(el int16) bool) bool {
	for el := range c.Data {
		if !f(el) {
			return false
		}
	}
	return true
}

// ChunkEvery returns channel with slices containing count elements each
func (c ChannelInt16) ChunkEvery(count int) chan []int16 {
	chunks := make(chan []int16, 1)
	go func() {
		chunk := make([]int16, 0, count)
		i := 0
		for el := range c.Data {
			chunk = append(chunk, el)
			i++
			if i%count == 0 {
				i = 0
				chunks <- chunk
				chunk = make([]int16, 0, count)
			}
		}
		if len(chunk) > 0 {
			chunks <- chunk
		}
		close(chunks)
	}()
	return chunks
}

// Count return count of el occurences in channel.
func (c ChannelInt16) Count(el int16) int {
	count := 0
	for val := range c.Data {
		if val == el {
			count++
		}
	}
	return count
}

// Drop drops first n elements from channel c and returns a new channel with the rest.
// It returns channel do be unblocking. If you want array instead, wrap result into TakeAll.
func (c ChannelInt16) Drop(n int) chan int16 {
	result := make(chan int16, 1)
	go func() {
		i := 0
		for el := range c.Data {
			if i >= n {
				result <- el
			}
			i++
		}
		close(result)
	}()
	return result
}

// Each calls f for every element in the channel
func (c ChannelInt16) Each(f func(el int16)) {
	for el := range c.Data {
		f(el)
	}
}

// Filter returns a new channel with elements from input channel
// for which f returns true
func (c ChannelInt16) Filter(f func(el int16) bool) chan int16 {
	result := make(chan int16, 1)
	go func() {
		for el := range c.Data {
			if f(el) {
				result <- el
			}
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt16) MapBool(f func(el int16) bool) chan bool {
	result := make(chan bool, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt16) MapByte(f func(el int16) byte) chan byte {
	result := make(chan byte, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt16) MapString(f func(el int16) string) chan string {
	result := make(chan string, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt16) MapFloat32(f func(el int16) float32) chan float32 {
	result := make(chan float32, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt16) MapFloat64(f func(el int16) float64) chan float64 {
	result := make(chan float64, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt16) MapInt(f func(el int16) int) chan int {
	result := make(chan int, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt16) MapInt8(f func(el int16) int8) chan int8 {
	result := make(chan int8, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt16) MapInt16(f func(el int16) int16) chan int16 {
	result := make(chan int16, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt16) MapInt32(f func(el int16) int32) chan int32 {
	result := make(chan int32, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt16) MapInt64(f func(el int16) int64) chan int64 {
	result := make(chan int64, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt16) MapUint(f func(el int16) uint) chan uint {
	result := make(chan uint, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt16) MapUint8(f func(el int16) uint8) chan uint8 {
	result := make(chan uint8, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt16) MapUint16(f func(el int16) uint16) chan uint16 {
	result := make(chan uint16, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt16) MapUint32(f func(el int16) uint32) chan uint32 {
	result := make(chan uint32, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt16) MapUint64(f func(el int16) uint64) chan uint64 {
	result := make(chan uint64, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt16) MapInterface(f func(el int16) interface{}) chan interface{} {
	result := make(chan interface{}, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Max returns the maximal element from channel
func (c ChannelInt16) Max() (int16, error) {
	max, ok := <-c.Data
	if !ok {
		return max, ErrEmpty
	}
	for el := range c.Data {
		if el > max {
			max = el
		}
	}
	return max, nil
}

// Min returns the minimal element from channel
func (c ChannelInt16) Min() (int16, error) {
	min, ok := <-c.Data
	if !ok {
		return min, ErrEmpty
	}
	for el := range c.Data {
		if el < min {
			min = el
		}
	}
	return min, nil
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt16) ReduceBool(acc bool, f func(el int16, acc bool) bool) bool {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt16) ReduceByte(acc byte, f func(el int16, acc byte) byte) byte {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt16) ReduceString(acc string, f func(el int16, acc string) string) string {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt16) ReduceFloat32(acc float32, f func(el int16, acc float32) float32) float32 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt16) ReduceFloat64(acc float64, f func(el int16, acc float64) float64) float64 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt16) ReduceInt(acc int, f func(el int16, acc int) int) int {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt16) ReduceInt8(acc int8, f func(el int16, acc int8) int8) int8 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt16) ReduceInt16(acc int16, f func(el int16, acc int16) int16) int16 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt16) ReduceInt32(acc int32, f func(el int16, acc int32) int32) int32 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt16) ReduceInt64(acc int64, f func(el int16, acc int64) int64) int64 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt16) ReduceUint(acc uint, f func(el int16, acc uint) uint) uint {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt16) ReduceUint8(acc uint8, f func(el int16, acc uint8) uint8) uint8 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt16) ReduceUint16(acc uint16, f func(el int16, acc uint16) uint16) uint16 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt16) ReduceUint32(acc uint32, f func(el int16, acc uint32) uint32) uint32 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt16) ReduceUint64(acc uint64, f func(el int16, acc uint64) uint64) uint64 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt16) ReduceInterface(acc interface{}, f func(el int16, acc interface{}) interface{}) interface{} {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt16) ScanBool(acc bool, f func(el int16, acc bool) bool) chan bool {
	result := make(chan bool, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt16) ScanByte(acc byte, f func(el int16, acc byte) byte) chan byte {
	result := make(chan byte, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt16) ScanString(acc string, f func(el int16, acc string) string) chan string {
	result := make(chan string, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt16) ScanFloat32(acc float32, f func(el int16, acc float32) float32) chan float32 {
	result := make(chan float32, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt16) ScanFloat64(acc float64, f func(el int16, acc float64) float64) chan float64 {
	result := make(chan float64, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt16) ScanInt(acc int, f func(el int16, acc int) int) chan int {
	result := make(chan int, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt16) ScanInt8(acc int8, f func(el int16, acc int8) int8) chan int8 {
	result := make(chan int8, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt16) ScanInt16(acc int16, f func(el int16, acc int16) int16) chan int16 {
	result := make(chan int16, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt16) ScanInt32(acc int32, f func(el int16, acc int32) int32) chan int32 {
	result := make(chan int32, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt16) ScanInt64(acc int64, f func(el int16, acc int64) int64) chan int64 {
	result := make(chan int64, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt16) ScanUint(acc uint, f func(el int16, acc uint) uint) chan uint {
	result := make(chan uint, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt16) ScanUint8(acc uint8, f func(el int16, acc uint8) uint8) chan uint8 {
	result := make(chan uint8, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt16) ScanUint16(acc uint16, f func(el int16, acc uint16) uint16) chan uint16 {
	result := make(chan uint16, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt16) ScanUint32(acc uint32, f func(el int16, acc uint32) uint32) chan uint32 {
	result := make(chan uint32, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt16) ScanUint64(acc uint64, f func(el int16, acc uint64) uint64) chan uint64 {
	result := make(chan uint64, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt16) ScanInterface(acc interface{}, f func(el int16, acc interface{}) interface{}) chan interface{} {
	result := make(chan interface{}, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Sum returns sum of all elements from channel
func (c ChannelInt16) Sum() int16 {
	var sum int16
	for el := range c.Data {
		sum += el
	}
	return sum
}

// Take takes first count elements from the channel.
func (c ChannelInt16) Take(count int) chan int16 {
	result := make(chan int16, 1)
	go func() {
		defer close(result)
		if count <= 0 {
			return
		}
		i := 0
		for el := range c.Data {
			result <- el
			i++
			if i == count {
				return
			}
		}
	}()
	return result
}

// Tee returns 2 channels with elements from the input channel
func (c ChannelInt16) Tee(count int) []chan int16 {
	channels := make([]chan int16, 0, count)
	for i := 0; i < count; i++ {
		channels = append(channels, make(chan int16, 1))
	}
	go func() {
		for el := range c.Data {
			wg := sync.WaitGroup{}
			putInto := func(ch chan int16) {
				defer wg.Done()
				ch <- el
			}
			wg.Add(count)
			for _, ch := range channels {
				putInto(ch)
			}
			wg.Wait()
		}
		for _, ch := range channels {
			close(ch)
		}
	}()
	return channels
}

// ToSlice returns slice with all elements from channel.
func (c ChannelInt16) ToSlice() []int16 {
	result := make([]int16, 0)
	for val := range c.Data {
		result = append(result, val)
	}
	return result
}

// All returns true if f returns true for all elements in slice
func (s AsyncSliceInt16) All(f func(el int16) bool) bool {
	if len(s.Data) == 0 {
		return true
	}

	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int, result chan<- bool, ctx context.Context) {
		defer wg.Done()
		for {
			select {
			case <-ctx.Done():
				return
			case index, ok := <-jobs:
				if !ok {
					return
				}
				if !f(s.Data[index]) {
					result <- false
					return
				}
			}
		}
	}

	ctx, cancel := context.WithCancel(context.Background())
	// when we're returning the result, cancel all workers
	defer cancel()

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	result := make(chan bool, workers)
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs, result, ctx)
	}

	// close the result channel when all workers have done
	go func() {
		wg.Wait()
		close(result)
	}()

	// schedule the jobs: indices to check
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)

	for range result {
		return false
	}
	return true
}

// Any returns true if f returns true for any element from slice
func (s AsyncSliceInt16) Any(f func(el int16) bool) bool {
	if len(s.Data) == 0 {
		return false
	}

	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int, result chan<- bool, ctx context.Context) {
		defer wg.Done()
		for {
			select {
			case <-ctx.Done():
				return
			case index, ok := <-jobs:
				if !ok {
					return
				}
				if f(s.Data[index]) {
					result <- true
					return
				}
			}
		}
	}

	ctx, cancel := context.WithCancel(context.Background())
	// when we're returning the result, cancel all workers
	defer cancel()

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	result := make(chan bool, workers)
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs, result, ctx)
	}

	// close the result channel when all workers have done
	go func() {
		wg.Wait()
		close(result)
	}()

	// schedule the jobs: indices to check
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)

	for range result {
		return true
	}
	return false
}

// Each calls f for every element from slice
func (s AsyncSliceInt16) Each(f func(el int16)) {
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		defer wg.Done()
		for index := range jobs {
			f(s.Data[index])
		}
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
}

// Filter returns slice of element for which f returns true
func (s AsyncSliceInt16) Filter(f func(el int16) bool) []int16 {
	resultMap := make([]bool, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			if f(s.Data[index]) {
				resultMap[index] = true
			}
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()

	// return filtered results
	result := make([]int16, 0, len(s.Data))
	for i, el := range s.Data {
		if resultMap[i] {
			result = append(result, el)
		}
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt16) MapBool(f func(el int16) bool) []bool {
	result := make([]bool, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt16) MapByte(f func(el int16) byte) []byte {
	result := make([]byte, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt16) MapString(f func(el int16) string) []string {
	result := make([]string, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt16) MapFloat32(f func(el int16) float32) []float32 {
	result := make([]float32, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt16) MapFloat64(f func(el int16) float64) []float64 {
	result := make([]float64, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt16) MapInt(f func(el int16) int) []int {
	result := make([]int, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt16) MapInt8(f func(el int16) int8) []int8 {
	result := make([]int8, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt16) MapInt16(f func(el int16) int16) []int16 {
	result := make([]int16, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt16) MapInt32(f func(el int16) int32) []int32 {
	result := make([]int32, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt16) MapInt64(f func(el int16) int64) []int64 {
	result := make([]int64, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt16) MapUint(f func(el int16) uint) []uint {
	result := make([]uint, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt16) MapUint8(f func(el int16) uint8) []uint8 {
	result := make([]uint8, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt16) MapUint16(f func(el int16) uint16) []uint16 {
	result := make([]uint16, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt16) MapUint32(f func(el int16) uint32) []uint32 {
	result := make([]uint32, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt16) MapUint64(f func(el int16) uint64) []uint64 {
	result := make([]uint64, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt16) MapInterface(f func(el int16) interface{}) []interface{} {
	result := make([]interface{}, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Reduce reduces slice to a single value with f
func (s AsyncSliceInt16) Reduce(f func(left int16, right int16) int16) int16 {
	if len(s.Data) == 0 {
		var tmp int16
		return tmp
	}

	state := make([]int16, len(s.Data))
	state = append(state, s.Data...)
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int, result chan<- int16) {
		for index := range jobs {
			result <- f(state[index], state[index+1])
		}
		wg.Done()
	}

	for len(state) > 1 {
		// calculate workers count
		workers := s.Workers
		if workers == 0 || workers > len(state) {
			workers = len(state)
		}

		// run workers
		jobs := make(chan int, len(state))
		wg.Add(workers)
		result := make(chan int16, 1)
		for i := 0; i < workers; i++ {
			go worker(jobs, result)
		}

		go func() {
			wg.Wait()
			close(result)
		}()

		// add indices into jobs for workers
		for i := 0; i < len(state)-1; i += 2 {
			jobs <- i
		}
		close(jobs)

		// collect new state
		newState := make([]int16, 0, len(state)/2+len(state)%2)
		for el := range result {
			newState = append(newState, el)
		}
		if len(state)%2 == 1 {
			newState = append(newState, state[len(state)-1])
		}
		// put new state as current state after all
		state = newState
	}

	return state[0]
}

// Count is like Range, but infinite
func (s SequenceInt16) Count(start int16, step int16) chan int16 {
	c := make(chan int16, 1)
	go func() {
		defer close(c)
		for {
			select {
			case <-s.ctx.Done():
				return
			case c <- start:
				start += step
			}
		}
	}()
	return c
}

// Exponential generates elements from start with
// multiplication of value on factor on every step
func (s SequenceInt16) Exponential(start int16, factor int16) chan int16 {
	c := make(chan int16, 1)
	go func() {
		defer close(c)
		for {
			select {
			case <-s.ctx.Done():
				return
			case c <- start:
				start *= factor
			}
		}
	}()
	return c
}

// Iterate returns an infinite list of repeated applications of f to val
func (s SequenceInt16) Iterate(val int16, f func(val int16) int16) chan int16 {
	c := make(chan int16, 1)
	go func() {
		defer close(c)
		for {
			select {
			case <-s.ctx.Done():
				return
			case c <- val:
				val = f(val)
			}
		}
	}()
	return c
}

// Range generates elements from start to end with given step
func (s SequenceInt16) Range(start int16, end int16, step int16) chan int16 {
	c := make(chan int16, 1)
	pos := start <= end
	go func() {
		for pos && (start < end) || !pos && (start > end) {
			c <- start
			start += step
		}
		close(c)
	}()
	return c
}

// Repeat returns channel that produces val infinite times
func (s SequenceInt16) Repeat(val int16) chan int16 {
	c := make(chan int16, 1)
	go func() {
		defer close(c)
		for {
			select {
			case <-s.ctx.Done():
				return
			case c <- val:
				continue
			}
		}
	}()
	return c
}

// Replicate returns channel that produces val n times
func (s SequenceInt16) Replicate(val int16, n int) chan int16 {
	c := make(chan int16, 1)
	go func() {
		for i := 0; i < n; i++ {
			c <- val
		}
		close(c)
	}()
	return c
}

// Min returns minimal value
func (PairInt16) Min(a int16, b int16) int16 {
	if a <= b {
		return a
	}
	return b
}

// Max returns maximal value
func (PairInt16) Max(a int16, b int16) int16 {
	if a > b {
		return a
	}
	return b
}

// Any returns true if f returns true for any element in arr
func (s SliceInt16) Any(f func(el int16) bool) bool {
	for _, el := range s.Data {
		if f(el) {
			return true
		}
	}
	return false
}

// All returns true if f returns true for all elements in arr
func (s SliceInt16) All(f func(el int16) bool) bool {
	for _, el := range s.Data {
		if !f(el) {
			return false
		}
	}
	return true
}

// Choice chooses a random element from the slice
func (s SliceInt16) Choice() (int16, error) {
	if len(s.Data) == 0 {
		var tmp int16
		return tmp, ErrEmpty
	}

	rand.Seed(time.Now().UnixNano())
	i := rand.Intn(len(s.Data))
	return s.Data[i], nil
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt16) ChunkByBool(f func(el int16) bool) [][]int16 {
	chunks := make([][]int16, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int16, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int16, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt16) ChunkByByte(f func(el int16) byte) [][]int16 {
	chunks := make([][]int16, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int16, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int16, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt16) ChunkByString(f func(el int16) string) [][]int16 {
	chunks := make([][]int16, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int16, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int16, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt16) ChunkByFloat32(f func(el int16) float32) [][]int16 {
	chunks := make([][]int16, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int16, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int16, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt16) ChunkByFloat64(f func(el int16) float64) [][]int16 {
	chunks := make([][]int16, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int16, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int16, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt16) ChunkByInt(f func(el int16) int) [][]int16 {
	chunks := make([][]int16, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int16, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int16, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt16) ChunkByInt8(f func(el int16) int8) [][]int16 {
	chunks := make([][]int16, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int16, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int16, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt16) ChunkByInt16(f func(el int16) int16) [][]int16 {
	chunks := make([][]int16, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int16, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int16, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt16) ChunkByInt32(f func(el int16) int32) [][]int16 {
	chunks := make([][]int16, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int16, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int16, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt16) ChunkByInt64(f func(el int16) int64) [][]int16 {
	chunks := make([][]int16, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int16, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int16, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt16) ChunkByUint(f func(el int16) uint) [][]int16 {
	chunks := make([][]int16, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int16, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int16, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt16) ChunkByUint8(f func(el int16) uint8) [][]int16 {
	chunks := make([][]int16, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int16, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int16, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt16) ChunkByUint16(f func(el int16) uint16) [][]int16 {
	chunks := make([][]int16, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int16, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int16, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt16) ChunkByUint32(f func(el int16) uint32) [][]int16 {
	chunks := make([][]int16, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int16, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int16, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt16) ChunkByUint64(f func(el int16) uint64) [][]int16 {
	chunks := make([][]int16, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int16, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int16, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt16) ChunkByInterface(f func(el int16) interface{}) [][]int16 {
	chunks := make([][]int16, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int16, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int16, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkEvery returns slice of slices containing count elements each
func (s SliceInt16) ChunkEvery(count int) ([][]int16, error) {
	chunks := make([][]int16, 0)
	if count <= 0 {
		return chunks, ErrNegativeValue
	}
	chunk := make([]int16, 0, count)
	for i, el := range s.Data {
		chunk = append(chunk, el)
		if (i+1)%count == 0 {
			chunks = append(chunks, chunk)
			chunk = make([]int16, 0, count)
		}
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks, nil
}

// Contains returns true if el in arr.
func (s SliceInt16) Contains(el int16) bool {
	for _, val := range s.Data {
		if val == el {
			return true
		}
	}
	return false
}

// Count return count of el occurences in arr.
func (s SliceInt16) Count(el int16) int {
	count := 0
	for _, val := range s.Data {
		if val == el {
			count++
		}
	}
	return count
}

// CountBy returns how many times f returns true.
func (s SliceInt16) CountBy(f func(el int16) bool) int {
	count := 0
	for _, el := range s.Data {
		if f(el) {
			count++
		}
	}
	return count
}

// Cycle is an infinite loop over slice
func (s SliceInt16) Cycle() chan int16 {
	c := make(chan int16, 1)
	go func() {
		defer close(c)
		if len(s.Data) == 0 {
			return
		}
		for {
			for _, val := range s.Data {
				c <- val
			}
		}
	}()
	return c
}

// Dedup returns a given slice without consecutive duplicated elements
func (s SliceInt16) Dedup() []int16 {
	if len(s.Data) == 0 {
		return s.Data
	}

	result := make([]int16, 0, len(s.Data))
	prev := s.Data[0]
	result = append(result, prev)
	for _, el := range s.Data[1:] {
		if el != prev {
			result = append(result, el)
			prev = el
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt16) DedupByBool(f func(el int16) bool) []int16 {
	result := make([]int16, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt16) DedupByByte(f func(el int16) byte) []int16 {
	result := make([]int16, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt16) DedupByString(f func(el int16) string) []int16 {
	result := make([]int16, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt16) DedupByFloat32(f func(el int16) float32) []int16 {
	result := make([]int16, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt16) DedupByFloat64(f func(el int16) float64) []int16 {
	result := make([]int16, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt16) DedupByInt(f func(el int16) int) []int16 {
	result := make([]int16, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt16) DedupByInt8(f func(el int16) int8) []int16 {
	result := make([]int16, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt16) DedupByInt16(f func(el int16) int16) []int16 {
	result := make([]int16, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt16) DedupByInt32(f func(el int16) int32) []int16 {
	result := make([]int16, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt16) DedupByInt64(f func(el int16) int64) []int16 {
	result := make([]int16, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt16) DedupByUint(f func(el int16) uint) []int16 {
	result := make([]int16, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt16) DedupByUint8(f func(el int16) uint8) []int16 {
	result := make([]int16, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt16) DedupByUint16(f func(el int16) uint16) []int16 {
	result := make([]int16, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt16) DedupByUint32(f func(el int16) uint32) []int16 {
	result := make([]int16, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt16) DedupByUint64(f func(el int16) uint64) []int16 {
	result := make([]int16, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt16) DedupByInterface(f func(el int16) interface{}) []int16 {
	result := make([]int16, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// Delete deletes the first occurence of the element from the slice
func (s SliceInt16) Delete(element int16) []int16 {
	result := make([]int16, 0, len(s.Data)-1)
	deleted := false
	for _, el := range s.Data {
		if !deleted && el == element {
			continue
		}
		result = append(result, el)
	}
	return result

}

// DeleteAt returns the slice without elements on given positions
func (s SliceInt16) DeleteAt(index int) ([]int16, error) {
	if index >= len(s.Data) {
		return s.Data, ErrOutOfRange
	}

	result := make([]int16, 0, len(s.Data)-1)
	for i, el := range s.Data {
		if i != index {
			result = append(result, el)
		}
	}
	return result, nil
}

// DropEvery returns a slice of every nth element in the enumerable dropped,
// starting with the first element.
func (s SliceInt16) DropEvery(nth int) ([]int16, error) {
	if nth <= 0 {
		return s.Data, ErrNonPositiveValue
	}
	result := make([]int16, 0, len(s.Data)/nth)
	for i, el := range s.Data {
		if (i+1)%nth != 0 {
			result = append(result, el)
		}
	}
	return result, nil
}

// DropWhile drops elements from arr while f returns true
func (s SliceInt16) DropWhile(f func(arr int16) bool) []int16 {
	result := make([]int16, 0, len(s.Data))
	for _, el := range s.Data {
		if !f(el) {
			return result
		}
		result = append(result, el)
	}
	return result
}

// Each calls f for every element from arr
func (s SliceInt16) Each(f func(el int16)) {
	for _, el := range s.Data {
		f(el)
	}
}

// Equal returns true if slices are equal
func (s SliceInt16) Equal(other []int16) bool {
	if len(s.Data) != len(other) {
		return false
	}
	for i, el := range other {
		if s.Data[i] != el {
			return false
		}
	}
	return true
}

// Filter returns slice of T for which F returned true
func (s SliceInt16) Filter(f func(el int16) bool) []int16 {
	result := make([]int16, 0, len(s.Data))
	for _, el := range s.Data {
		if f(el) {
			result = append(result, el)
		}
	}
	return result
}

// Find returns the first element for which f returns true
func (s SliceInt16) Find(f func(el int16) bool) (int16, error) {
	for _, el := range s.Data {
		if f(el) {
			return el, nil
		}
	}
	var tmp int16
	return tmp, ErrNotFound
}

// FindIndex is like Find, but return element index instead of element itself
func (s SliceInt16) FindIndex(f func(el int16) bool) (int, error) {
	for i, el := range s.Data {
		if f(el) {
			return i, nil
		}
	}
	return 0, ErrNotFound
}

// Join concatenates elements of the slice to create a single string.
func (s SliceInt16) Join(sep string) string {
	strs := make([]string, 0, len(s.Data))
	for _, el := range s.Data {
		strs = append(strs, string(el))
	}
	return strings.Join(strs, sep)
}

// GroupBy groups element from array by value returned by f
func (s SliceInt16) GroupByBool(f func(el int16) bool) map[bool][]int16 {
	result := make(map[bool][]int16)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int16, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt16) GroupByByte(f func(el int16) byte) map[byte][]int16 {
	result := make(map[byte][]int16)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int16, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt16) GroupByString(f func(el int16) string) map[string][]int16 {
	result := make(map[string][]int16)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int16, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt16) GroupByFloat32(f func(el int16) float32) map[float32][]int16 {
	result := make(map[float32][]int16)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int16, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt16) GroupByFloat64(f func(el int16) float64) map[float64][]int16 {
	result := make(map[float64][]int16)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int16, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt16) GroupByInt(f func(el int16) int) map[int][]int16 {
	result := make(map[int][]int16)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int16, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt16) GroupByInt8(f func(el int16) int8) map[int8][]int16 {
	result := make(map[int8][]int16)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int16, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt16) GroupByInt16(f func(el int16) int16) map[int16][]int16 {
	result := make(map[int16][]int16)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int16, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt16) GroupByInt32(f func(el int16) int32) map[int32][]int16 {
	result := make(map[int32][]int16)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int16, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt16) GroupByInt64(f func(el int16) int64) map[int64][]int16 {
	result := make(map[int64][]int16)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int16, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt16) GroupByUint(f func(el int16) uint) map[uint][]int16 {
	result := make(map[uint][]int16)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int16, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt16) GroupByUint8(f func(el int16) uint8) map[uint8][]int16 {
	result := make(map[uint8][]int16)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int16, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt16) GroupByUint16(f func(el int16) uint16) map[uint16][]int16 {
	result := make(map[uint16][]int16)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int16, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt16) GroupByUint32(f func(el int16) uint32) map[uint32][]int16 {
	result := make(map[uint32][]int16)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int16, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt16) GroupByUint64(f func(el int16) uint64) map[uint64][]int16 {
	result := make(map[uint64][]int16)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int16, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt16) GroupByInterface(f func(el int16) interface{}) map[interface{}][]int16 {
	result := make(map[interface{}][]int16)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int16, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// InsertAt returns the slice with element inserted at given index.
func (s SliceInt16) InsertAt(index int, element int16) ([]int16, error) {
	result := make([]int16, 0, len(s.Data)+1)

	// insert at the end
	if index == len(s.Data) || index == -1 {
		result = append(result, s.Data...)
		result = append(result, element)
		return result, nil
	}

	if index > len(s.Data) {
		return s.Data, ErrOutOfRange
	}
	if index < 0 {
		return s.Data, ErrNegativeValue
	}

	for i, el := range s.Data {
		if i == index {
			result = append(result, element)
		}
		result = append(result, el)
	}
	return result, nil
}

// Intersperse inserts el between each element of arr
func (s SliceInt16) Intersperse(el int16) []int16 {
	if len(s.Data) == 0 {
		return s.Data
	}
	result := make([]int16, 0, len(s.Data)*2-1)
	result = append(result, s.Data[0])
	for _, val := range s.Data[1:] {
		result = append(result, el, val)
	}
	return result
}

// Last returns the last element from the slice
func (s SliceInt16) Last() (int16, error) {
	if len(s.Data) == 0 {
		var tmp int16
		return tmp, ErrEmpty
	}
	return s.Data[len(s.Data)-1], nil
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt16) MapBool(f func(el int16) bool) []bool {
	result := make([]bool, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt16) MapByte(f func(el int16) byte) []byte {
	result := make([]byte, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt16) MapString(f func(el int16) string) []string {
	result := make([]string, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt16) MapFloat32(f func(el int16) float32) []float32 {
	result := make([]float32, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt16) MapFloat64(f func(el int16) float64) []float64 {
	result := make([]float64, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt16) MapInt(f func(el int16) int) []int {
	result := make([]int, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt16) MapInt8(f func(el int16) int8) []int8 {
	result := make([]int8, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt16) MapInt16(f func(el int16) int16) []int16 {
	result := make([]int16, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt16) MapInt32(f func(el int16) int32) []int32 {
	result := make([]int32, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt16) MapInt64(f func(el int16) int64) []int64 {
	result := make([]int64, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt16) MapUint(f func(el int16) uint) []uint {
	result := make([]uint, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt16) MapUint8(f func(el int16) uint8) []uint8 {
	result := make([]uint8, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt16) MapUint16(f func(el int16) uint16) []uint16 {
	result := make([]uint16, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt16) MapUint32(f func(el int16) uint32) []uint32 {
	result := make([]uint32, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt16) MapUint64(f func(el int16) uint64) []uint64 {
	result := make([]uint64, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt16) MapInterface(f func(el int16) interface{}) []interface{} {
	result := make([]interface{}, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Max returns the maximal element from arr
func (s SliceInt16) Max() (int16, error) {
	if len(s.Data) == 0 {
		var tmp int16
		return tmp, ErrEmpty
	}

	max := s.Data[0]
	for _, el := range s.Data[1:] {
		if el > max {
			max = el
		}
	}
	return max, nil
}

// Min returns the minimal element from arr
func (s SliceInt16) Min() (int16, error) {
	if len(s.Data) == 0 {
		var tmp int16
		return tmp, ErrEmpty
	}

	min := s.Data[0]
	for _, el := range s.Data[1:] {
		if el < min {
			min = el
		}
	}
	return min, nil
}

// Permutations returns successive size-length permutations of elements from the slice.
// {1, 2, 3} -> {1, 2}, {1, 3}, {2, 1}, {2, 3}, {3, 1}, {3, 2}
func (s SliceInt16) Permutations(size int) chan []int16 {
	c := make(chan []int16, 1)
	go func() {
		if len(s.Data) > 0 {
			s.permutations(c, size, []int16{}, s.Data)
		}
		close(c)
	}()
	return c
}

// permutations is a core implementation for Permutations
func (s SliceInt16) permutations(c chan []int16, size int, left []int16, right []int16) {
	if len(left) == size || len(right) == 0 {
		c <- left
		return
	}

	for i, el := range right {
		newLeft := make([]int16, 0, len(left)+1)
		newLeft = append(newLeft, left...)
		newLeft = append(newLeft, el)

		newRight := make([]int16, 0, len(right)-1)
		for j, other := range right {
			if j != i {
				newRight = append(newRight, other)
			}
		}
		s.permutations(c, size, newLeft, newRight)
	}
}

// Product returns cortesian product of elements
// {{1, 2}, {3, 4}} -> {1, 3}, {1, 4}, {2, 3}, {2, 4}
func (s SliceInt16) Product(repeat int) chan []int16 {
	c := make(chan []int16, 1)
	go s.product(c, repeat, []int16{}, 0)
	return c
}

// product is a core implementation for Product
func (s SliceInt16) product(c chan []int16, repeat int, left []int16, pos int) {
	// iterate over the last array
	if pos == repeat-1 {
		for _, el := range s.Data {
			result := make([]int16, 0, len(left)+1)
			result = append(result, left...)
			result = append(result, el)
			c <- result
		}
		return
	}

	for _, el := range s.Data {
		result := make([]int16, 0, len(left)+1)
		result = append(result, left...)
		result = append(result, el)
		s.product(c, repeat, result, pos+1)
	}

	if pos == 0 {
		close(c)
	}
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt16) ReduceBool(acc bool, f func(el int16, acc bool) bool) bool {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt16) ReduceByte(acc byte, f func(el int16, acc byte) byte) byte {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt16) ReduceString(acc string, f func(el int16, acc string) string) string {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt16) ReduceFloat32(acc float32, f func(el int16, acc float32) float32) float32 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt16) ReduceFloat64(acc float64, f func(el int16, acc float64) float64) float64 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt16) ReduceInt(acc int, f func(el int16, acc int) int) int {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt16) ReduceInt8(acc int8, f func(el int16, acc int8) int8) int8 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt16) ReduceInt16(acc int16, f func(el int16, acc int16) int16) int16 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt16) ReduceInt32(acc int32, f func(el int16, acc int32) int32) int32 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt16) ReduceInt64(acc int64, f func(el int16, acc int64) int64) int64 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt16) ReduceUint(acc uint, f func(el int16, acc uint) uint) uint {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt16) ReduceUint8(acc uint8, f func(el int16, acc uint8) uint8) uint8 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt16) ReduceUint16(acc uint16, f func(el int16, acc uint16) uint16) uint16 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt16) ReduceUint32(acc uint32, f func(el int16, acc uint32) uint32) uint32 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt16) ReduceUint64(acc uint64, f func(el int16, acc uint64) uint64) uint64 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt16) ReduceInterface(acc interface{}, f func(el int16, acc interface{}) interface{}) interface{} {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt16) ReduceWhileBool(acc bool, f func(el int16, acc bool) (bool, error)) (bool, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt16) ReduceWhileByte(acc byte, f func(el int16, acc byte) (byte, error)) (byte, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt16) ReduceWhileString(acc string, f func(el int16, acc string) (string, error)) (string, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt16) ReduceWhileFloat32(acc float32, f func(el int16, acc float32) (float32, error)) (float32, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt16) ReduceWhileFloat64(acc float64, f func(el int16, acc float64) (float64, error)) (float64, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt16) ReduceWhileInt(acc int, f func(el int16, acc int) (int, error)) (int, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt16) ReduceWhileInt8(acc int8, f func(el int16, acc int8) (int8, error)) (int8, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt16) ReduceWhileInt16(acc int16, f func(el int16, acc int16) (int16, error)) (int16, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt16) ReduceWhileInt32(acc int32, f func(el int16, acc int32) (int32, error)) (int32, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt16) ReduceWhileInt64(acc int64, f func(el int16, acc int64) (int64, error)) (int64, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt16) ReduceWhileUint(acc uint, f func(el int16, acc uint) (uint, error)) (uint, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt16) ReduceWhileUint8(acc uint8, f func(el int16, acc uint8) (uint8, error)) (uint8, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt16) ReduceWhileUint16(acc uint16, f func(el int16, acc uint16) (uint16, error)) (uint16, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt16) ReduceWhileUint32(acc uint32, f func(el int16, acc uint32) (uint32, error)) (uint32, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt16) ReduceWhileUint64(acc uint64, f func(el int16, acc uint64) (uint64, error)) (uint64, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt16) ReduceWhileInterface(acc interface{}, f func(el int16, acc interface{}) (interface{}, error)) (interface{}, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// Reverse returns given arr in reversed order
func (s SliceInt16) Reverse() []int16 {
	if len(s.Data) <= 1 {
		return s.Data
	}
	result := make([]int16, 0, len(s.Data))
	for i := len(s.Data) - 1; i >= 0; i-- {
		result = append(result, s.Data[i])
	}
	return result
}

// Same returns true if all element in arr the same
func (s SliceInt16) Same() bool {
	if len(s.Data) <= 1 {
		return true
	}
	for i := 0; i < len(s.Data)-1; i++ {
		if s.Data[i] != s.Data[i+1] {
			return false
		}
	}
	return true
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt16) ScanBool(acc bool, f func(el int16, acc bool) bool) []bool {
	result := make([]bool, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt16) ScanByte(acc byte, f func(el int16, acc byte) byte) []byte {
	result := make([]byte, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt16) ScanString(acc string, f func(el int16, acc string) string) []string {
	result := make([]string, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt16) ScanFloat32(acc float32, f func(el int16, acc float32) float32) []float32 {
	result := make([]float32, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt16) ScanFloat64(acc float64, f func(el int16, acc float64) float64) []float64 {
	result := make([]float64, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt16) ScanInt(acc int, f func(el int16, acc int) int) []int {
	result := make([]int, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt16) ScanInt8(acc int8, f func(el int16, acc int8) int8) []int8 {
	result := make([]int8, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt16) ScanInt16(acc int16, f func(el int16, acc int16) int16) []int16 {
	result := make([]int16, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt16) ScanInt32(acc int32, f func(el int16, acc int32) int32) []int32 {
	result := make([]int32, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt16) ScanInt64(acc int64, f func(el int16, acc int64) int64) []int64 {
	result := make([]int64, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt16) ScanUint(acc uint, f func(el int16, acc uint) uint) []uint {
	result := make([]uint, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt16) ScanUint8(acc uint8, f func(el int16, acc uint8) uint8) []uint8 {
	result := make([]uint8, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt16) ScanUint16(acc uint16, f func(el int16, acc uint16) uint16) []uint16 {
	result := make([]uint16, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt16) ScanUint32(acc uint32, f func(el int16, acc uint32) uint32) []uint32 {
	result := make([]uint32, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt16) ScanUint64(acc uint64, f func(el int16, acc uint64) uint64) []uint64 {
	result := make([]uint64, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt16) ScanInterface(acc interface{}, f func(el int16, acc interface{}) interface{}) []interface{} {
	result := make([]interface{}, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Shuffle in random order arr elements
func (s SliceInt16) Shuffle() []int16 {
	if len(s.Data) <= 1 {
		return s.Data
	}
	rand.Seed(time.Now().UnixNano())
	swap := func(i, j int) {
		s.Data[i], s.Data[j] = s.Data[j], s.Data[i]
	}
	rand.Shuffle(len(s.Data), swap)
	return s.Data
}

// Sort returns sorted slice
func (s SliceInt16) Sort() []int16 {
	if len(s.Data) <= 1 {
		return s.Data
	}
	less := func(i int, j int) bool {
		return s.Data[i] < s.Data[j]
	}
	sort.SliceStable(s.Data, less)
	return s.Data
}

// Sorted returns true if slice is sorted
func (s SliceInt16) Sorted() bool {
	if len(s.Data) <= 1 {
		return true
	}
	for i := 1; i < len(s.Data); i++ {
		if s.Data[i-1] > s.Data[i] {
			return false
		}
	}
	return true
}

// Split splits arr by sep
func (s SliceInt16) Split(sep int16) [][]int16 {
	result := make([][]int16, 0)
	curr := make([]int16, 0)
	for _, el := range s.Data {
		if el == sep {
			result = append(result, curr)
		} else {
			curr = append(curr, el)
		}
	}
	result = append(result, curr)
	return result
}

// StartsWith returns true if slice starts with the given prefix slice.
// If prefix is empty, it returns true.
func (s SliceInt16) StartsWith(prefix []int16) bool {
	if len(prefix) > len(s.Data) {
		return false
	}
	for i, el := range prefix {
		if el != s.Data[i] {
			return false
		}
	}
	return true
}

// Sum return sum of all elements from arr
func (s SliceInt16) Sum() int16 {
	var sum int16
	for _, el := range s.Data {
		sum += el
	}
	return sum
}

// TakeEvery returns slice of every nth elements
func (s SliceInt16) TakeEvery(nth int) ([]int16, error) {
	if nth <= 0 {
		return s.Data, ErrNonPositiveValue
	}
	result := make([]int16, 0, len(s.Data))
	for i, el := range s.Data {
		if (i+1)%nth == 0 {
			result = append(result, el)
		}
	}
	return result, nil
}

// TakeRandom returns slice of count random elements from the slice
func (s SliceInt16) TakeRandom(count int) ([]int16, error) {
	if count > len(s.Data) {
		return nil, ErrOutOfRange
	}
	if count <= 0 {
		return nil, ErrNonPositiveValue
	}

	rand.Seed(time.Now().UnixNano())
	swap := func(i, j int) {
		s.Data[i], s.Data[j] = s.Data[j], s.Data[i]
	}
	rand.Shuffle(len(s.Data), swap)
	return s.Data[:count], nil
}

// TakeWhile takes elements from arr while f returns true
func (s SliceInt16) TakeWhile(f func(el int16) bool) []int16 {
	result := make([]int16, 0, len(s.Data))
	for _, el := range s.Data {
		if !f(el) {
			return result
		}
		result = append(result, el)
	}
	return result
}

// ToChannel returns channel with elements from the slice
func (s SliceInt16) ToChannel() chan int16 {
	c := make(chan int16, 1)
	go func() {
		for _, el := range s.Data {
			c <- el
		}
		close(c)
	}()
	return c
}

// Uniq returns arr with only first occurences of every element.
func (s SliceInt16) Uniq() []int16 {
	if len(s.Data) <= 1 {
		return s.Data
	}
	added := make(map[int16]struct{})
	nothing := struct{}{}
	result := make([]int16, 0, len(s.Data))
	for _, el := range s.Data {
		_, exists := added[el]
		if !exists {
			result = append(result, el)
			added[el] = nothing
		}
	}
	return result

}

// Window makes sliding window for a given slice:
// ({1,2,3}, 2) -> (1,2), (2,3)
func (s SliceInt16) Window(size int) ([][]int16, error) {
	if size <= 0 {
		return nil, ErrNonPositiveValue
	}
	result := make([][]int16, 0, len(s.Data)/size)
	for i := 0; i <= len(s.Data)-size; i++ {
		chunk := s.Data[i : i+size]
		result = append(result, chunk)
	}
	return result, nil
}

// Without returns the slice with filtered out element
func (s SliceInt16) Without(elements ...int16) []int16 {
	result := make([]int16, 0, len(s.Data))
	for _, el := range s.Data {
		allowed := true
		for _, other := range elements {
			if el == other {
				allowed = false
			}
		}
		if allowed {
			result = append(result, el)
		}
	}
	return result
}

// Concat concatenates given slices into a single slice.
func (s SlicesInt16) Concat() []int16 {
	result := make([]int16, 0)
	for _, arr := range s.Data {
		result = append(result, arr...)
	}
	return result
}

// Product returns cortesian product of elements
// {{1, 2}, {3, 4}} -> {1, 3}, {1, 4}, {2, 3}, {2, 4}
func (s SlicesInt16) Product() chan []int16 {
	c := make(chan []int16, 1)
	go s.product(c, []int16{}, 0)
	return c
}

// product is a core implementation of Product
func (s SlicesInt16) product(c chan []int16, left []int16, pos int) {
	// iterate over the last array
	if pos == len(s.Data)-1 {
		for _, el := range s.Data[pos] {
			result := make([]int16, 0, len(left)+1)
			result = append(result, left...)
			result = append(result, el)
			c <- result
		}
		return
	}

	for _, el := range s.Data[pos] {
		result := make([]int16, 0, len(left)+1)
		result = append(result, left...)
		result = append(result, el)
		s.product(c, result, pos+1)
	}

	if pos == 0 {
		close(c)
	}
}

// Zip returns array of arrays of elements from given arrs
// on the same position
func (s SlicesInt16) Zip() [][]int16 {
	size := len(s.Data[0])
	for _, arr := range s.Data[1:] {
		if len(arr) > size {
			size = len(arr)
		}
	}

	result := make([][]int16, 0, size)
	for i := 0; i <= size; i++ {
		chunk := make([]int16, 0, len(s.Data))
		for _, arr := range s.Data {
			chunk = append(chunk, arr[i])
		}
		result = append(result, chunk)
	}
	return result
}

// Channel is a set of operations with channel
type ChannelInt32 struct {
	Data chan int32
}

// AsyncSlice is a set of operations to work with slice asynchronously
type AsyncSliceInt32 struct {
	Data    []int32
	Workers int
}

// Sequence is a set of operations to generate sequences
type SequenceInt32 struct {
	ctx context.Context
}

// Pair is a set of functions for 2 values that you can pass into reduce-like funcs
type PairInt32 struct {
	// empty
}

// Slice is a set of operations to work with slice
type SliceInt32 struct {
	Data []int32
}

// Slices is a set of operations to work with slice of slices
type SlicesInt32 struct {
	Data [][]int32
}

// Any returns true if f returns true for any element in channel
func (c ChannelInt32) Any(f func(el int32) bool) bool {
	for el := range c.Data {
		if f(el) {
			return true
		}
	}
	return false
}

// All returns true if f returns true for all elements in channel
func (c ChannelInt32) All(f func(el int32) bool) bool {
	for el := range c.Data {
		if !f(el) {
			return false
		}
	}
	return true
}

// ChunkEvery returns channel with slices containing count elements each
func (c ChannelInt32) ChunkEvery(count int) chan []int32 {
	chunks := make(chan []int32, 1)
	go func() {
		chunk := make([]int32, 0, count)
		i := 0
		for el := range c.Data {
			chunk = append(chunk, el)
			i++
			if i%count == 0 {
				i = 0
				chunks <- chunk
				chunk = make([]int32, 0, count)
			}
		}
		if len(chunk) > 0 {
			chunks <- chunk
		}
		close(chunks)
	}()
	return chunks
}

// Count return count of el occurences in channel.
func (c ChannelInt32) Count(el int32) int {
	count := 0
	for val := range c.Data {
		if val == el {
			count++
		}
	}
	return count
}

// Drop drops first n elements from channel c and returns a new channel with the rest.
// It returns channel do be unblocking. If you want array instead, wrap result into TakeAll.
func (c ChannelInt32) Drop(n int) chan int32 {
	result := make(chan int32, 1)
	go func() {
		i := 0
		for el := range c.Data {
			if i >= n {
				result <- el
			}
			i++
		}
		close(result)
	}()
	return result
}

// Each calls f for every element in the channel
func (c ChannelInt32) Each(f func(el int32)) {
	for el := range c.Data {
		f(el)
	}
}

// Filter returns a new channel with elements from input channel
// for which f returns true
func (c ChannelInt32) Filter(f func(el int32) bool) chan int32 {
	result := make(chan int32, 1)
	go func() {
		for el := range c.Data {
			if f(el) {
				result <- el
			}
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt32) MapBool(f func(el int32) bool) chan bool {
	result := make(chan bool, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt32) MapByte(f func(el int32) byte) chan byte {
	result := make(chan byte, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt32) MapString(f func(el int32) string) chan string {
	result := make(chan string, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt32) MapFloat32(f func(el int32) float32) chan float32 {
	result := make(chan float32, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt32) MapFloat64(f func(el int32) float64) chan float64 {
	result := make(chan float64, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt32) MapInt(f func(el int32) int) chan int {
	result := make(chan int, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt32) MapInt8(f func(el int32) int8) chan int8 {
	result := make(chan int8, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt32) MapInt16(f func(el int32) int16) chan int16 {
	result := make(chan int16, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt32) MapInt32(f func(el int32) int32) chan int32 {
	result := make(chan int32, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt32) MapInt64(f func(el int32) int64) chan int64 {
	result := make(chan int64, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt32) MapUint(f func(el int32) uint) chan uint {
	result := make(chan uint, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt32) MapUint8(f func(el int32) uint8) chan uint8 {
	result := make(chan uint8, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt32) MapUint16(f func(el int32) uint16) chan uint16 {
	result := make(chan uint16, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt32) MapUint32(f func(el int32) uint32) chan uint32 {
	result := make(chan uint32, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt32) MapUint64(f func(el int32) uint64) chan uint64 {
	result := make(chan uint64, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt32) MapInterface(f func(el int32) interface{}) chan interface{} {
	result := make(chan interface{}, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Max returns the maximal element from channel
func (c ChannelInt32) Max() (int32, error) {
	max, ok := <-c.Data
	if !ok {
		return max, ErrEmpty
	}
	for el := range c.Data {
		if el > max {
			max = el
		}
	}
	return max, nil
}

// Min returns the minimal element from channel
func (c ChannelInt32) Min() (int32, error) {
	min, ok := <-c.Data
	if !ok {
		return min, ErrEmpty
	}
	for el := range c.Data {
		if el < min {
			min = el
		}
	}
	return min, nil
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt32) ReduceBool(acc bool, f func(el int32, acc bool) bool) bool {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt32) ReduceByte(acc byte, f func(el int32, acc byte) byte) byte {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt32) ReduceString(acc string, f func(el int32, acc string) string) string {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt32) ReduceFloat32(acc float32, f func(el int32, acc float32) float32) float32 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt32) ReduceFloat64(acc float64, f func(el int32, acc float64) float64) float64 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt32) ReduceInt(acc int, f func(el int32, acc int) int) int {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt32) ReduceInt8(acc int8, f func(el int32, acc int8) int8) int8 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt32) ReduceInt16(acc int16, f func(el int32, acc int16) int16) int16 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt32) ReduceInt32(acc int32, f func(el int32, acc int32) int32) int32 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt32) ReduceInt64(acc int64, f func(el int32, acc int64) int64) int64 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt32) ReduceUint(acc uint, f func(el int32, acc uint) uint) uint {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt32) ReduceUint8(acc uint8, f func(el int32, acc uint8) uint8) uint8 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt32) ReduceUint16(acc uint16, f func(el int32, acc uint16) uint16) uint16 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt32) ReduceUint32(acc uint32, f func(el int32, acc uint32) uint32) uint32 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt32) ReduceUint64(acc uint64, f func(el int32, acc uint64) uint64) uint64 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt32) ReduceInterface(acc interface{}, f func(el int32, acc interface{}) interface{}) interface{} {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt32) ScanBool(acc bool, f func(el int32, acc bool) bool) chan bool {
	result := make(chan bool, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt32) ScanByte(acc byte, f func(el int32, acc byte) byte) chan byte {
	result := make(chan byte, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt32) ScanString(acc string, f func(el int32, acc string) string) chan string {
	result := make(chan string, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt32) ScanFloat32(acc float32, f func(el int32, acc float32) float32) chan float32 {
	result := make(chan float32, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt32) ScanFloat64(acc float64, f func(el int32, acc float64) float64) chan float64 {
	result := make(chan float64, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt32) ScanInt(acc int, f func(el int32, acc int) int) chan int {
	result := make(chan int, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt32) ScanInt8(acc int8, f func(el int32, acc int8) int8) chan int8 {
	result := make(chan int8, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt32) ScanInt16(acc int16, f func(el int32, acc int16) int16) chan int16 {
	result := make(chan int16, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt32) ScanInt32(acc int32, f func(el int32, acc int32) int32) chan int32 {
	result := make(chan int32, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt32) ScanInt64(acc int64, f func(el int32, acc int64) int64) chan int64 {
	result := make(chan int64, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt32) ScanUint(acc uint, f func(el int32, acc uint) uint) chan uint {
	result := make(chan uint, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt32) ScanUint8(acc uint8, f func(el int32, acc uint8) uint8) chan uint8 {
	result := make(chan uint8, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt32) ScanUint16(acc uint16, f func(el int32, acc uint16) uint16) chan uint16 {
	result := make(chan uint16, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt32) ScanUint32(acc uint32, f func(el int32, acc uint32) uint32) chan uint32 {
	result := make(chan uint32, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt32) ScanUint64(acc uint64, f func(el int32, acc uint64) uint64) chan uint64 {
	result := make(chan uint64, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt32) ScanInterface(acc interface{}, f func(el int32, acc interface{}) interface{}) chan interface{} {
	result := make(chan interface{}, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Sum returns sum of all elements from channel
func (c ChannelInt32) Sum() int32 {
	var sum int32
	for el := range c.Data {
		sum += el
	}
	return sum
}

// Take takes first count elements from the channel.
func (c ChannelInt32) Take(count int) chan int32 {
	result := make(chan int32, 1)
	go func() {
		defer close(result)
		if count <= 0 {
			return
		}
		i := 0
		for el := range c.Data {
			result <- el
			i++
			if i == count {
				return
			}
		}
	}()
	return result
}

// Tee returns 2 channels with elements from the input channel
func (c ChannelInt32) Tee(count int) []chan int32 {
	channels := make([]chan int32, 0, count)
	for i := 0; i < count; i++ {
		channels = append(channels, make(chan int32, 1))
	}
	go func() {
		for el := range c.Data {
			wg := sync.WaitGroup{}
			putInto := func(ch chan int32) {
				defer wg.Done()
				ch <- el
			}
			wg.Add(count)
			for _, ch := range channels {
				putInto(ch)
			}
			wg.Wait()
		}
		for _, ch := range channels {
			close(ch)
		}
	}()
	return channels
}

// ToSlice returns slice with all elements from channel.
func (c ChannelInt32) ToSlice() []int32 {
	result := make([]int32, 0)
	for val := range c.Data {
		result = append(result, val)
	}
	return result
}

// All returns true if f returns true for all elements in slice
func (s AsyncSliceInt32) All(f func(el int32) bool) bool {
	if len(s.Data) == 0 {
		return true
	}

	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int, result chan<- bool, ctx context.Context) {
		defer wg.Done()
		for {
			select {
			case <-ctx.Done():
				return
			case index, ok := <-jobs:
				if !ok {
					return
				}
				if !f(s.Data[index]) {
					result <- false
					return
				}
			}
		}
	}

	ctx, cancel := context.WithCancel(context.Background())
	// when we're returning the result, cancel all workers
	defer cancel()

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	result := make(chan bool, workers)
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs, result, ctx)
	}

	// close the result channel when all workers have done
	go func() {
		wg.Wait()
		close(result)
	}()

	// schedule the jobs: indices to check
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)

	for range result {
		return false
	}
	return true
}

// Any returns true if f returns true for any element from slice
func (s AsyncSliceInt32) Any(f func(el int32) bool) bool {
	if len(s.Data) == 0 {
		return false
	}

	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int, result chan<- bool, ctx context.Context) {
		defer wg.Done()
		for {
			select {
			case <-ctx.Done():
				return
			case index, ok := <-jobs:
				if !ok {
					return
				}
				if f(s.Data[index]) {
					result <- true
					return
				}
			}
		}
	}

	ctx, cancel := context.WithCancel(context.Background())
	// when we're returning the result, cancel all workers
	defer cancel()

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	result := make(chan bool, workers)
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs, result, ctx)
	}

	// close the result channel when all workers have done
	go func() {
		wg.Wait()
		close(result)
	}()

	// schedule the jobs: indices to check
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)

	for range result {
		return true
	}
	return false
}

// Each calls f for every element from slice
func (s AsyncSliceInt32) Each(f func(el int32)) {
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		defer wg.Done()
		for index := range jobs {
			f(s.Data[index])
		}
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
}

// Filter returns slice of element for which f returns true
func (s AsyncSliceInt32) Filter(f func(el int32) bool) []int32 {
	resultMap := make([]bool, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			if f(s.Data[index]) {
				resultMap[index] = true
			}
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()

	// return filtered results
	result := make([]int32, 0, len(s.Data))
	for i, el := range s.Data {
		if resultMap[i] {
			result = append(result, el)
		}
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt32) MapBool(f func(el int32) bool) []bool {
	result := make([]bool, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt32) MapByte(f func(el int32) byte) []byte {
	result := make([]byte, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt32) MapString(f func(el int32) string) []string {
	result := make([]string, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt32) MapFloat32(f func(el int32) float32) []float32 {
	result := make([]float32, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt32) MapFloat64(f func(el int32) float64) []float64 {
	result := make([]float64, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt32) MapInt(f func(el int32) int) []int {
	result := make([]int, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt32) MapInt8(f func(el int32) int8) []int8 {
	result := make([]int8, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt32) MapInt16(f func(el int32) int16) []int16 {
	result := make([]int16, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt32) MapInt32(f func(el int32) int32) []int32 {
	result := make([]int32, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt32) MapInt64(f func(el int32) int64) []int64 {
	result := make([]int64, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt32) MapUint(f func(el int32) uint) []uint {
	result := make([]uint, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt32) MapUint8(f func(el int32) uint8) []uint8 {
	result := make([]uint8, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt32) MapUint16(f func(el int32) uint16) []uint16 {
	result := make([]uint16, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt32) MapUint32(f func(el int32) uint32) []uint32 {
	result := make([]uint32, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt32) MapUint64(f func(el int32) uint64) []uint64 {
	result := make([]uint64, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt32) MapInterface(f func(el int32) interface{}) []interface{} {
	result := make([]interface{}, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Reduce reduces slice to a single value with f
func (s AsyncSliceInt32) Reduce(f func(left int32, right int32) int32) int32 {
	if len(s.Data) == 0 {
		var tmp int32
		return tmp
	}

	state := make([]int32, len(s.Data))
	state = append(state, s.Data...)
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int, result chan<- int32) {
		for index := range jobs {
			result <- f(state[index], state[index+1])
		}
		wg.Done()
	}

	for len(state) > 1 {
		// calculate workers count
		workers := s.Workers
		if workers == 0 || workers > len(state) {
			workers = len(state)
		}

		// run workers
		jobs := make(chan int, len(state))
		wg.Add(workers)
		result := make(chan int32, 1)
		for i := 0; i < workers; i++ {
			go worker(jobs, result)
		}

		go func() {
			wg.Wait()
			close(result)
		}()

		// add indices into jobs for workers
		for i := 0; i < len(state)-1; i += 2 {
			jobs <- i
		}
		close(jobs)

		// collect new state
		newState := make([]int32, 0, len(state)/2+len(state)%2)
		for el := range result {
			newState = append(newState, el)
		}
		if len(state)%2 == 1 {
			newState = append(newState, state[len(state)-1])
		}
		// put new state as current state after all
		state = newState
	}

	return state[0]
}

// Count is like Range, but infinite
func (s SequenceInt32) Count(start int32, step int32) chan int32 {
	c := make(chan int32, 1)
	go func() {
		defer close(c)
		for {
			select {
			case <-s.ctx.Done():
				return
			case c <- start:
				start += step
			}
		}
	}()
	return c
}

// Exponential generates elements from start with
// multiplication of value on factor on every step
func (s SequenceInt32) Exponential(start int32, factor int32) chan int32 {
	c := make(chan int32, 1)
	go func() {
		defer close(c)
		for {
			select {
			case <-s.ctx.Done():
				return
			case c <- start:
				start *= factor
			}
		}
	}()
	return c
}

// Iterate returns an infinite list of repeated applications of f to val
func (s SequenceInt32) Iterate(val int32, f func(val int32) int32) chan int32 {
	c := make(chan int32, 1)
	go func() {
		defer close(c)
		for {
			select {
			case <-s.ctx.Done():
				return
			case c <- val:
				val = f(val)
			}
		}
	}()
	return c
}

// Range generates elements from start to end with given step
func (s SequenceInt32) Range(start int32, end int32, step int32) chan int32 {
	c := make(chan int32, 1)
	pos := start <= end
	go func() {
		for pos && (start < end) || !pos && (start > end) {
			c <- start
			start += step
		}
		close(c)
	}()
	return c
}

// Repeat returns channel that produces val infinite times
func (s SequenceInt32) Repeat(val int32) chan int32 {
	c := make(chan int32, 1)
	go func() {
		defer close(c)
		for {
			select {
			case <-s.ctx.Done():
				return
			case c <- val:
				continue
			}
		}
	}()
	return c
}

// Replicate returns channel that produces val n times
func (s SequenceInt32) Replicate(val int32, n int) chan int32 {
	c := make(chan int32, 1)
	go func() {
		for i := 0; i < n; i++ {
			c <- val
		}
		close(c)
	}()
	return c
}

// Min returns minimal value
func (PairInt32) Min(a int32, b int32) int32 {
	if a <= b {
		return a
	}
	return b
}

// Max returns maximal value
func (PairInt32) Max(a int32, b int32) int32 {
	if a > b {
		return a
	}
	return b
}

// Any returns true if f returns true for any element in arr
func (s SliceInt32) Any(f func(el int32) bool) bool {
	for _, el := range s.Data {
		if f(el) {
			return true
		}
	}
	return false
}

// All returns true if f returns true for all elements in arr
func (s SliceInt32) All(f func(el int32) bool) bool {
	for _, el := range s.Data {
		if !f(el) {
			return false
		}
	}
	return true
}

// Choice chooses a random element from the slice
func (s SliceInt32) Choice() (int32, error) {
	if len(s.Data) == 0 {
		var tmp int32
		return tmp, ErrEmpty
	}

	rand.Seed(time.Now().UnixNano())
	i := rand.Intn(len(s.Data))
	return s.Data[i], nil
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt32) ChunkByBool(f func(el int32) bool) [][]int32 {
	chunks := make([][]int32, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int32, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int32, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt32) ChunkByByte(f func(el int32) byte) [][]int32 {
	chunks := make([][]int32, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int32, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int32, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt32) ChunkByString(f func(el int32) string) [][]int32 {
	chunks := make([][]int32, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int32, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int32, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt32) ChunkByFloat32(f func(el int32) float32) [][]int32 {
	chunks := make([][]int32, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int32, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int32, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt32) ChunkByFloat64(f func(el int32) float64) [][]int32 {
	chunks := make([][]int32, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int32, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int32, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt32) ChunkByInt(f func(el int32) int) [][]int32 {
	chunks := make([][]int32, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int32, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int32, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt32) ChunkByInt8(f func(el int32) int8) [][]int32 {
	chunks := make([][]int32, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int32, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int32, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt32) ChunkByInt16(f func(el int32) int16) [][]int32 {
	chunks := make([][]int32, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int32, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int32, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt32) ChunkByInt32(f func(el int32) int32) [][]int32 {
	chunks := make([][]int32, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int32, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int32, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt32) ChunkByInt64(f func(el int32) int64) [][]int32 {
	chunks := make([][]int32, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int32, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int32, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt32) ChunkByUint(f func(el int32) uint) [][]int32 {
	chunks := make([][]int32, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int32, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int32, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt32) ChunkByUint8(f func(el int32) uint8) [][]int32 {
	chunks := make([][]int32, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int32, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int32, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt32) ChunkByUint16(f func(el int32) uint16) [][]int32 {
	chunks := make([][]int32, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int32, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int32, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt32) ChunkByUint32(f func(el int32) uint32) [][]int32 {
	chunks := make([][]int32, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int32, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int32, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt32) ChunkByUint64(f func(el int32) uint64) [][]int32 {
	chunks := make([][]int32, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int32, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int32, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt32) ChunkByInterface(f func(el int32) interface{}) [][]int32 {
	chunks := make([][]int32, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int32, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int32, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkEvery returns slice of slices containing count elements each
func (s SliceInt32) ChunkEvery(count int) ([][]int32, error) {
	chunks := make([][]int32, 0)
	if count <= 0 {
		return chunks, ErrNegativeValue
	}
	chunk := make([]int32, 0, count)
	for i, el := range s.Data {
		chunk = append(chunk, el)
		if (i+1)%count == 0 {
			chunks = append(chunks, chunk)
			chunk = make([]int32, 0, count)
		}
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks, nil
}

// Contains returns true if el in arr.
func (s SliceInt32) Contains(el int32) bool {
	for _, val := range s.Data {
		if val == el {
			return true
		}
	}
	return false
}

// Count return count of el occurences in arr.
func (s SliceInt32) Count(el int32) int {
	count := 0
	for _, val := range s.Data {
		if val == el {
			count++
		}
	}
	return count
}

// CountBy returns how many times f returns true.
func (s SliceInt32) CountBy(f func(el int32) bool) int {
	count := 0
	for _, el := range s.Data {
		if f(el) {
			count++
		}
	}
	return count
}

// Cycle is an infinite loop over slice
func (s SliceInt32) Cycle() chan int32 {
	c := make(chan int32, 1)
	go func() {
		defer close(c)
		if len(s.Data) == 0 {
			return
		}
		for {
			for _, val := range s.Data {
				c <- val
			}
		}
	}()
	return c
}

// Dedup returns a given slice without consecutive duplicated elements
func (s SliceInt32) Dedup() []int32 {
	if len(s.Data) == 0 {
		return s.Data
	}

	result := make([]int32, 0, len(s.Data))
	prev := s.Data[0]
	result = append(result, prev)
	for _, el := range s.Data[1:] {
		if el != prev {
			result = append(result, el)
			prev = el
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt32) DedupByBool(f func(el int32) bool) []int32 {
	result := make([]int32, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt32) DedupByByte(f func(el int32) byte) []int32 {
	result := make([]int32, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt32) DedupByString(f func(el int32) string) []int32 {
	result := make([]int32, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt32) DedupByFloat32(f func(el int32) float32) []int32 {
	result := make([]int32, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt32) DedupByFloat64(f func(el int32) float64) []int32 {
	result := make([]int32, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt32) DedupByInt(f func(el int32) int) []int32 {
	result := make([]int32, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt32) DedupByInt8(f func(el int32) int8) []int32 {
	result := make([]int32, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt32) DedupByInt16(f func(el int32) int16) []int32 {
	result := make([]int32, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt32) DedupByInt32(f func(el int32) int32) []int32 {
	result := make([]int32, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt32) DedupByInt64(f func(el int32) int64) []int32 {
	result := make([]int32, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt32) DedupByUint(f func(el int32) uint) []int32 {
	result := make([]int32, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt32) DedupByUint8(f func(el int32) uint8) []int32 {
	result := make([]int32, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt32) DedupByUint16(f func(el int32) uint16) []int32 {
	result := make([]int32, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt32) DedupByUint32(f func(el int32) uint32) []int32 {
	result := make([]int32, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt32) DedupByUint64(f func(el int32) uint64) []int32 {
	result := make([]int32, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt32) DedupByInterface(f func(el int32) interface{}) []int32 {
	result := make([]int32, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// Delete deletes the first occurence of the element from the slice
func (s SliceInt32) Delete(element int32) []int32 {
	result := make([]int32, 0, len(s.Data)-1)
	deleted := false
	for _, el := range s.Data {
		if !deleted && el == element {
			continue
		}
		result = append(result, el)
	}
	return result

}

// DeleteAt returns the slice without elements on given positions
func (s SliceInt32) DeleteAt(index int) ([]int32, error) {
	if index >= len(s.Data) {
		return s.Data, ErrOutOfRange
	}

	result := make([]int32, 0, len(s.Data)-1)
	for i, el := range s.Data {
		if i != index {
			result = append(result, el)
		}
	}
	return result, nil
}

// DropEvery returns a slice of every nth element in the enumerable dropped,
// starting with the first element.
func (s SliceInt32) DropEvery(nth int) ([]int32, error) {
	if nth <= 0 {
		return s.Data, ErrNonPositiveValue
	}
	result := make([]int32, 0, len(s.Data)/nth)
	for i, el := range s.Data {
		if (i+1)%nth != 0 {
			result = append(result, el)
		}
	}
	return result, nil
}

// DropWhile drops elements from arr while f returns true
func (s SliceInt32) DropWhile(f func(arr int32) bool) []int32 {
	result := make([]int32, 0, len(s.Data))
	for _, el := range s.Data {
		if !f(el) {
			return result
		}
		result = append(result, el)
	}
	return result
}

// Each calls f for every element from arr
func (s SliceInt32) Each(f func(el int32)) {
	for _, el := range s.Data {
		f(el)
	}
}

// Equal returns true if slices are equal
func (s SliceInt32) Equal(other []int32) bool {
	if len(s.Data) != len(other) {
		return false
	}
	for i, el := range other {
		if s.Data[i] != el {
			return false
		}
	}
	return true
}

// Filter returns slice of T for which F returned true
func (s SliceInt32) Filter(f func(el int32) bool) []int32 {
	result := make([]int32, 0, len(s.Data))
	for _, el := range s.Data {
		if f(el) {
			result = append(result, el)
		}
	}
	return result
}

// Find returns the first element for which f returns true
func (s SliceInt32) Find(f func(el int32) bool) (int32, error) {
	for _, el := range s.Data {
		if f(el) {
			return el, nil
		}
	}
	var tmp int32
	return tmp, ErrNotFound
}

// FindIndex is like Find, but return element index instead of element itself
func (s SliceInt32) FindIndex(f func(el int32) bool) (int, error) {
	for i, el := range s.Data {
		if f(el) {
			return i, nil
		}
	}
	return 0, ErrNotFound
}

// Join concatenates elements of the slice to create a single string.
func (s SliceInt32) Join(sep string) string {
	strs := make([]string, 0, len(s.Data))
	for _, el := range s.Data {
		strs = append(strs, string(el))
	}
	return strings.Join(strs, sep)
}

// GroupBy groups element from array by value returned by f
func (s SliceInt32) GroupByBool(f func(el int32) bool) map[bool][]int32 {
	result := make(map[bool][]int32)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int32, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt32) GroupByByte(f func(el int32) byte) map[byte][]int32 {
	result := make(map[byte][]int32)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int32, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt32) GroupByString(f func(el int32) string) map[string][]int32 {
	result := make(map[string][]int32)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int32, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt32) GroupByFloat32(f func(el int32) float32) map[float32][]int32 {
	result := make(map[float32][]int32)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int32, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt32) GroupByFloat64(f func(el int32) float64) map[float64][]int32 {
	result := make(map[float64][]int32)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int32, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt32) GroupByInt(f func(el int32) int) map[int][]int32 {
	result := make(map[int][]int32)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int32, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt32) GroupByInt8(f func(el int32) int8) map[int8][]int32 {
	result := make(map[int8][]int32)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int32, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt32) GroupByInt16(f func(el int32) int16) map[int16][]int32 {
	result := make(map[int16][]int32)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int32, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt32) GroupByInt32(f func(el int32) int32) map[int32][]int32 {
	result := make(map[int32][]int32)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int32, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt32) GroupByInt64(f func(el int32) int64) map[int64][]int32 {
	result := make(map[int64][]int32)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int32, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt32) GroupByUint(f func(el int32) uint) map[uint][]int32 {
	result := make(map[uint][]int32)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int32, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt32) GroupByUint8(f func(el int32) uint8) map[uint8][]int32 {
	result := make(map[uint8][]int32)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int32, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt32) GroupByUint16(f func(el int32) uint16) map[uint16][]int32 {
	result := make(map[uint16][]int32)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int32, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt32) GroupByUint32(f func(el int32) uint32) map[uint32][]int32 {
	result := make(map[uint32][]int32)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int32, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt32) GroupByUint64(f func(el int32) uint64) map[uint64][]int32 {
	result := make(map[uint64][]int32)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int32, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt32) GroupByInterface(f func(el int32) interface{}) map[interface{}][]int32 {
	result := make(map[interface{}][]int32)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int32, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// InsertAt returns the slice with element inserted at given index.
func (s SliceInt32) InsertAt(index int, element int32) ([]int32, error) {
	result := make([]int32, 0, len(s.Data)+1)

	// insert at the end
	if index == len(s.Data) || index == -1 {
		result = append(result, s.Data...)
		result = append(result, element)
		return result, nil
	}

	if index > len(s.Data) {
		return s.Data, ErrOutOfRange
	}
	if index < 0 {
		return s.Data, ErrNegativeValue
	}

	for i, el := range s.Data {
		if i == index {
			result = append(result, element)
		}
		result = append(result, el)
	}
	return result, nil
}

// Intersperse inserts el between each element of arr
func (s SliceInt32) Intersperse(el int32) []int32 {
	if len(s.Data) == 0 {
		return s.Data
	}
	result := make([]int32, 0, len(s.Data)*2-1)
	result = append(result, s.Data[0])
	for _, val := range s.Data[1:] {
		result = append(result, el, val)
	}
	return result
}

// Last returns the last element from the slice
func (s SliceInt32) Last() (int32, error) {
	if len(s.Data) == 0 {
		var tmp int32
		return tmp, ErrEmpty
	}
	return s.Data[len(s.Data)-1], nil
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt32) MapBool(f func(el int32) bool) []bool {
	result := make([]bool, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt32) MapByte(f func(el int32) byte) []byte {
	result := make([]byte, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt32) MapString(f func(el int32) string) []string {
	result := make([]string, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt32) MapFloat32(f func(el int32) float32) []float32 {
	result := make([]float32, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt32) MapFloat64(f func(el int32) float64) []float64 {
	result := make([]float64, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt32) MapInt(f func(el int32) int) []int {
	result := make([]int, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt32) MapInt8(f func(el int32) int8) []int8 {
	result := make([]int8, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt32) MapInt16(f func(el int32) int16) []int16 {
	result := make([]int16, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt32) MapInt32(f func(el int32) int32) []int32 {
	result := make([]int32, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt32) MapInt64(f func(el int32) int64) []int64 {
	result := make([]int64, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt32) MapUint(f func(el int32) uint) []uint {
	result := make([]uint, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt32) MapUint8(f func(el int32) uint8) []uint8 {
	result := make([]uint8, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt32) MapUint16(f func(el int32) uint16) []uint16 {
	result := make([]uint16, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt32) MapUint32(f func(el int32) uint32) []uint32 {
	result := make([]uint32, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt32) MapUint64(f func(el int32) uint64) []uint64 {
	result := make([]uint64, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt32) MapInterface(f func(el int32) interface{}) []interface{} {
	result := make([]interface{}, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Max returns the maximal element from arr
func (s SliceInt32) Max() (int32, error) {
	if len(s.Data) == 0 {
		var tmp int32
		return tmp, ErrEmpty
	}

	max := s.Data[0]
	for _, el := range s.Data[1:] {
		if el > max {
			max = el
		}
	}
	return max, nil
}

// Min returns the minimal element from arr
func (s SliceInt32) Min() (int32, error) {
	if len(s.Data) == 0 {
		var tmp int32
		return tmp, ErrEmpty
	}

	min := s.Data[0]
	for _, el := range s.Data[1:] {
		if el < min {
			min = el
		}
	}
	return min, nil
}

// Permutations returns successive size-length permutations of elements from the slice.
// {1, 2, 3} -> {1, 2}, {1, 3}, {2, 1}, {2, 3}, {3, 1}, {3, 2}
func (s SliceInt32) Permutations(size int) chan []int32 {
	c := make(chan []int32, 1)
	go func() {
		if len(s.Data) > 0 {
			s.permutations(c, size, []int32{}, s.Data)
		}
		close(c)
	}()
	return c
}

// permutations is a core implementation for Permutations
func (s SliceInt32) permutations(c chan []int32, size int, left []int32, right []int32) {
	if len(left) == size || len(right) == 0 {
		c <- left
		return
	}

	for i, el := range right {
		newLeft := make([]int32, 0, len(left)+1)
		newLeft = append(newLeft, left...)
		newLeft = append(newLeft, el)

		newRight := make([]int32, 0, len(right)-1)
		for j, other := range right {
			if j != i {
				newRight = append(newRight, other)
			}
		}
		s.permutations(c, size, newLeft, newRight)
	}
}

// Product returns cortesian product of elements
// {{1, 2}, {3, 4}} -> {1, 3}, {1, 4}, {2, 3}, {2, 4}
func (s SliceInt32) Product(repeat int) chan []int32 {
	c := make(chan []int32, 1)
	go s.product(c, repeat, []int32{}, 0)
	return c
}

// product is a core implementation for Product
func (s SliceInt32) product(c chan []int32, repeat int, left []int32, pos int) {
	// iterate over the last array
	if pos == repeat-1 {
		for _, el := range s.Data {
			result := make([]int32, 0, len(left)+1)
			result = append(result, left...)
			result = append(result, el)
			c <- result
		}
		return
	}

	for _, el := range s.Data {
		result := make([]int32, 0, len(left)+1)
		result = append(result, left...)
		result = append(result, el)
		s.product(c, repeat, result, pos+1)
	}

	if pos == 0 {
		close(c)
	}
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt32) ReduceBool(acc bool, f func(el int32, acc bool) bool) bool {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt32) ReduceByte(acc byte, f func(el int32, acc byte) byte) byte {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt32) ReduceString(acc string, f func(el int32, acc string) string) string {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt32) ReduceFloat32(acc float32, f func(el int32, acc float32) float32) float32 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt32) ReduceFloat64(acc float64, f func(el int32, acc float64) float64) float64 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt32) ReduceInt(acc int, f func(el int32, acc int) int) int {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt32) ReduceInt8(acc int8, f func(el int32, acc int8) int8) int8 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt32) ReduceInt16(acc int16, f func(el int32, acc int16) int16) int16 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt32) ReduceInt32(acc int32, f func(el int32, acc int32) int32) int32 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt32) ReduceInt64(acc int64, f func(el int32, acc int64) int64) int64 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt32) ReduceUint(acc uint, f func(el int32, acc uint) uint) uint {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt32) ReduceUint8(acc uint8, f func(el int32, acc uint8) uint8) uint8 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt32) ReduceUint16(acc uint16, f func(el int32, acc uint16) uint16) uint16 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt32) ReduceUint32(acc uint32, f func(el int32, acc uint32) uint32) uint32 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt32) ReduceUint64(acc uint64, f func(el int32, acc uint64) uint64) uint64 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt32) ReduceInterface(acc interface{}, f func(el int32, acc interface{}) interface{}) interface{} {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt32) ReduceWhileBool(acc bool, f func(el int32, acc bool) (bool, error)) (bool, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt32) ReduceWhileByte(acc byte, f func(el int32, acc byte) (byte, error)) (byte, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt32) ReduceWhileString(acc string, f func(el int32, acc string) (string, error)) (string, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt32) ReduceWhileFloat32(acc float32, f func(el int32, acc float32) (float32, error)) (float32, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt32) ReduceWhileFloat64(acc float64, f func(el int32, acc float64) (float64, error)) (float64, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt32) ReduceWhileInt(acc int, f func(el int32, acc int) (int, error)) (int, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt32) ReduceWhileInt8(acc int8, f func(el int32, acc int8) (int8, error)) (int8, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt32) ReduceWhileInt16(acc int16, f func(el int32, acc int16) (int16, error)) (int16, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt32) ReduceWhileInt32(acc int32, f func(el int32, acc int32) (int32, error)) (int32, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt32) ReduceWhileInt64(acc int64, f func(el int32, acc int64) (int64, error)) (int64, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt32) ReduceWhileUint(acc uint, f func(el int32, acc uint) (uint, error)) (uint, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt32) ReduceWhileUint8(acc uint8, f func(el int32, acc uint8) (uint8, error)) (uint8, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt32) ReduceWhileUint16(acc uint16, f func(el int32, acc uint16) (uint16, error)) (uint16, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt32) ReduceWhileUint32(acc uint32, f func(el int32, acc uint32) (uint32, error)) (uint32, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt32) ReduceWhileUint64(acc uint64, f func(el int32, acc uint64) (uint64, error)) (uint64, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt32) ReduceWhileInterface(acc interface{}, f func(el int32, acc interface{}) (interface{}, error)) (interface{}, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// Reverse returns given arr in reversed order
func (s SliceInt32) Reverse() []int32 {
	if len(s.Data) <= 1 {
		return s.Data
	}
	result := make([]int32, 0, len(s.Data))
	for i := len(s.Data) - 1; i >= 0; i-- {
		result = append(result, s.Data[i])
	}
	return result
}

// Same returns true if all element in arr the same
func (s SliceInt32) Same() bool {
	if len(s.Data) <= 1 {
		return true
	}
	for i := 0; i < len(s.Data)-1; i++ {
		if s.Data[i] != s.Data[i+1] {
			return false
		}
	}
	return true
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt32) ScanBool(acc bool, f func(el int32, acc bool) bool) []bool {
	result := make([]bool, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt32) ScanByte(acc byte, f func(el int32, acc byte) byte) []byte {
	result := make([]byte, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt32) ScanString(acc string, f func(el int32, acc string) string) []string {
	result := make([]string, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt32) ScanFloat32(acc float32, f func(el int32, acc float32) float32) []float32 {
	result := make([]float32, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt32) ScanFloat64(acc float64, f func(el int32, acc float64) float64) []float64 {
	result := make([]float64, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt32) ScanInt(acc int, f func(el int32, acc int) int) []int {
	result := make([]int, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt32) ScanInt8(acc int8, f func(el int32, acc int8) int8) []int8 {
	result := make([]int8, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt32) ScanInt16(acc int16, f func(el int32, acc int16) int16) []int16 {
	result := make([]int16, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt32) ScanInt32(acc int32, f func(el int32, acc int32) int32) []int32 {
	result := make([]int32, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt32) ScanInt64(acc int64, f func(el int32, acc int64) int64) []int64 {
	result := make([]int64, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt32) ScanUint(acc uint, f func(el int32, acc uint) uint) []uint {
	result := make([]uint, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt32) ScanUint8(acc uint8, f func(el int32, acc uint8) uint8) []uint8 {
	result := make([]uint8, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt32) ScanUint16(acc uint16, f func(el int32, acc uint16) uint16) []uint16 {
	result := make([]uint16, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt32) ScanUint32(acc uint32, f func(el int32, acc uint32) uint32) []uint32 {
	result := make([]uint32, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt32) ScanUint64(acc uint64, f func(el int32, acc uint64) uint64) []uint64 {
	result := make([]uint64, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt32) ScanInterface(acc interface{}, f func(el int32, acc interface{}) interface{}) []interface{} {
	result := make([]interface{}, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Shuffle in random order arr elements
func (s SliceInt32) Shuffle() []int32 {
	if len(s.Data) <= 1 {
		return s.Data
	}
	rand.Seed(time.Now().UnixNano())
	swap := func(i, j int) {
		s.Data[i], s.Data[j] = s.Data[j], s.Data[i]
	}
	rand.Shuffle(len(s.Data), swap)
	return s.Data
}

// Sort returns sorted slice
func (s SliceInt32) Sort() []int32 {
	if len(s.Data) <= 1 {
		return s.Data
	}
	less := func(i int, j int) bool {
		return s.Data[i] < s.Data[j]
	}
	sort.SliceStable(s.Data, less)
	return s.Data
}

// Sorted returns true if slice is sorted
func (s SliceInt32) Sorted() bool {
	if len(s.Data) <= 1 {
		return true
	}
	for i := 1; i < len(s.Data); i++ {
		if s.Data[i-1] > s.Data[i] {
			return false
		}
	}
	return true
}

// Split splits arr by sep
func (s SliceInt32) Split(sep int32) [][]int32 {
	result := make([][]int32, 0)
	curr := make([]int32, 0)
	for _, el := range s.Data {
		if el == sep {
			result = append(result, curr)
		} else {
			curr = append(curr, el)
		}
	}
	result = append(result, curr)
	return result
}

// StartsWith returns true if slice starts with the given prefix slice.
// If prefix is empty, it returns true.
func (s SliceInt32) StartsWith(prefix []int32) bool {
	if len(prefix) > len(s.Data) {
		return false
	}
	for i, el := range prefix {
		if el != s.Data[i] {
			return false
		}
	}
	return true
}

// Sum return sum of all elements from arr
func (s SliceInt32) Sum() int32 {
	var sum int32
	for _, el := range s.Data {
		sum += el
	}
	return sum
}

// TakeEvery returns slice of every nth elements
func (s SliceInt32) TakeEvery(nth int) ([]int32, error) {
	if nth <= 0 {
		return s.Data, ErrNonPositiveValue
	}
	result := make([]int32, 0, len(s.Data))
	for i, el := range s.Data {
		if (i+1)%nth == 0 {
			result = append(result, el)
		}
	}
	return result, nil
}

// TakeRandom returns slice of count random elements from the slice
func (s SliceInt32) TakeRandom(count int) ([]int32, error) {
	if count > len(s.Data) {
		return nil, ErrOutOfRange
	}
	if count <= 0 {
		return nil, ErrNonPositiveValue
	}

	rand.Seed(time.Now().UnixNano())
	swap := func(i, j int) {
		s.Data[i], s.Data[j] = s.Data[j], s.Data[i]
	}
	rand.Shuffle(len(s.Data), swap)
	return s.Data[:count], nil
}

// TakeWhile takes elements from arr while f returns true
func (s SliceInt32) TakeWhile(f func(el int32) bool) []int32 {
	result := make([]int32, 0, len(s.Data))
	for _, el := range s.Data {
		if !f(el) {
			return result
		}
		result = append(result, el)
	}
	return result
}

// ToChannel returns channel with elements from the slice
func (s SliceInt32) ToChannel() chan int32 {
	c := make(chan int32, 1)
	go func() {
		for _, el := range s.Data {
			c <- el
		}
		close(c)
	}()
	return c
}

// Uniq returns arr with only first occurences of every element.
func (s SliceInt32) Uniq() []int32 {
	if len(s.Data) <= 1 {
		return s.Data
	}
	added := make(map[int32]struct{})
	nothing := struct{}{}
	result := make([]int32, 0, len(s.Data))
	for _, el := range s.Data {
		_, exists := added[el]
		if !exists {
			result = append(result, el)
			added[el] = nothing
		}
	}
	return result

}

// Window makes sliding window for a given slice:
// ({1,2,3}, 2) -> (1,2), (2,3)
func (s SliceInt32) Window(size int) ([][]int32, error) {
	if size <= 0 {
		return nil, ErrNonPositiveValue
	}
	result := make([][]int32, 0, len(s.Data)/size)
	for i := 0; i <= len(s.Data)-size; i++ {
		chunk := s.Data[i : i+size]
		result = append(result, chunk)
	}
	return result, nil
}

// Without returns the slice with filtered out element
func (s SliceInt32) Without(elements ...int32) []int32 {
	result := make([]int32, 0, len(s.Data))
	for _, el := range s.Data {
		allowed := true
		for _, other := range elements {
			if el == other {
				allowed = false
			}
		}
		if allowed {
			result = append(result, el)
		}
	}
	return result
}

// Concat concatenates given slices into a single slice.
func (s SlicesInt32) Concat() []int32 {
	result := make([]int32, 0)
	for _, arr := range s.Data {
		result = append(result, arr...)
	}
	return result
}

// Product returns cortesian product of elements
// {{1, 2}, {3, 4}} -> {1, 3}, {1, 4}, {2, 3}, {2, 4}
func (s SlicesInt32) Product() chan []int32 {
	c := make(chan []int32, 1)
	go s.product(c, []int32{}, 0)
	return c
}

// product is a core implementation of Product
func (s SlicesInt32) product(c chan []int32, left []int32, pos int) {
	// iterate over the last array
	if pos == len(s.Data)-1 {
		for _, el := range s.Data[pos] {
			result := make([]int32, 0, len(left)+1)
			result = append(result, left...)
			result = append(result, el)
			c <- result
		}
		return
	}

	for _, el := range s.Data[pos] {
		result := make([]int32, 0, len(left)+1)
		result = append(result, left...)
		result = append(result, el)
		s.product(c, result, pos+1)
	}

	if pos == 0 {
		close(c)
	}
}

// Zip returns array of arrays of elements from given arrs
// on the same position
func (s SlicesInt32) Zip() [][]int32 {
	size := len(s.Data[0])
	for _, arr := range s.Data[1:] {
		if len(arr) > size {
			size = len(arr)
		}
	}

	result := make([][]int32, 0, size)
	for i := 0; i <= size; i++ {
		chunk := make([]int32, 0, len(s.Data))
		for _, arr := range s.Data {
			chunk = append(chunk, arr[i])
		}
		result = append(result, chunk)
	}
	return result
}

// Channel is a set of operations with channel
type ChannelInt64 struct {
	Data chan int64
}

// AsyncSlice is a set of operations to work with slice asynchronously
type AsyncSliceInt64 struct {
	Data    []int64
	Workers int
}

// Sequence is a set of operations to generate sequences
type SequenceInt64 struct {
	ctx context.Context
}

// Pair is a set of functions for 2 values that you can pass into reduce-like funcs
type PairInt64 struct {
	// empty
}

// Slice is a set of operations to work with slice
type SliceInt64 struct {
	Data []int64
}

// Slices is a set of operations to work with slice of slices
type SlicesInt64 struct {
	Data [][]int64
}

// Any returns true if f returns true for any element in channel
func (c ChannelInt64) Any(f func(el int64) bool) bool {
	for el := range c.Data {
		if f(el) {
			return true
		}
	}
	return false
}

// All returns true if f returns true for all elements in channel
func (c ChannelInt64) All(f func(el int64) bool) bool {
	for el := range c.Data {
		if !f(el) {
			return false
		}
	}
	return true
}

// ChunkEvery returns channel with slices containing count elements each
func (c ChannelInt64) ChunkEvery(count int) chan []int64 {
	chunks := make(chan []int64, 1)
	go func() {
		chunk := make([]int64, 0, count)
		i := 0
		for el := range c.Data {
			chunk = append(chunk, el)
			i++
			if i%count == 0 {
				i = 0
				chunks <- chunk
				chunk = make([]int64, 0, count)
			}
		}
		if len(chunk) > 0 {
			chunks <- chunk
		}
		close(chunks)
	}()
	return chunks
}

// Count return count of el occurences in channel.
func (c ChannelInt64) Count(el int64) int {
	count := 0
	for val := range c.Data {
		if val == el {
			count++
		}
	}
	return count
}

// Drop drops first n elements from channel c and returns a new channel with the rest.
// It returns channel do be unblocking. If you want array instead, wrap result into TakeAll.
func (c ChannelInt64) Drop(n int) chan int64 {
	result := make(chan int64, 1)
	go func() {
		i := 0
		for el := range c.Data {
			if i >= n {
				result <- el
			}
			i++
		}
		close(result)
	}()
	return result
}

// Each calls f for every element in the channel
func (c ChannelInt64) Each(f func(el int64)) {
	for el := range c.Data {
		f(el)
	}
}

// Filter returns a new channel with elements from input channel
// for which f returns true
func (c ChannelInt64) Filter(f func(el int64) bool) chan int64 {
	result := make(chan int64, 1)
	go func() {
		for el := range c.Data {
			if f(el) {
				result <- el
			}
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt64) MapBool(f func(el int64) bool) chan bool {
	result := make(chan bool, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt64) MapByte(f func(el int64) byte) chan byte {
	result := make(chan byte, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt64) MapString(f func(el int64) string) chan string {
	result := make(chan string, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt64) MapFloat32(f func(el int64) float32) chan float32 {
	result := make(chan float32, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt64) MapFloat64(f func(el int64) float64) chan float64 {
	result := make(chan float64, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt64) MapInt(f func(el int64) int) chan int {
	result := make(chan int, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt64) MapInt8(f func(el int64) int8) chan int8 {
	result := make(chan int8, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt64) MapInt16(f func(el int64) int16) chan int16 {
	result := make(chan int16, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt64) MapInt32(f func(el int64) int32) chan int32 {
	result := make(chan int32, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt64) MapInt64(f func(el int64) int64) chan int64 {
	result := make(chan int64, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt64) MapUint(f func(el int64) uint) chan uint {
	result := make(chan uint, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt64) MapUint8(f func(el int64) uint8) chan uint8 {
	result := make(chan uint8, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt64) MapUint16(f func(el int64) uint16) chan uint16 {
	result := make(chan uint16, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt64) MapUint32(f func(el int64) uint32) chan uint32 {
	result := make(chan uint32, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt64) MapUint64(f func(el int64) uint64) chan uint64 {
	result := make(chan uint64, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInt64) MapInterface(f func(el int64) interface{}) chan interface{} {
	result := make(chan interface{}, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Max returns the maximal element from channel
func (c ChannelInt64) Max() (int64, error) {
	max, ok := <-c.Data
	if !ok {
		return max, ErrEmpty
	}
	for el := range c.Data {
		if el > max {
			max = el
		}
	}
	return max, nil
}

// Min returns the minimal element from channel
func (c ChannelInt64) Min() (int64, error) {
	min, ok := <-c.Data
	if !ok {
		return min, ErrEmpty
	}
	for el := range c.Data {
		if el < min {
			min = el
		}
	}
	return min, nil
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt64) ReduceBool(acc bool, f func(el int64, acc bool) bool) bool {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt64) ReduceByte(acc byte, f func(el int64, acc byte) byte) byte {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt64) ReduceString(acc string, f func(el int64, acc string) string) string {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt64) ReduceFloat32(acc float32, f func(el int64, acc float32) float32) float32 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt64) ReduceFloat64(acc float64, f func(el int64, acc float64) float64) float64 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt64) ReduceInt(acc int, f func(el int64, acc int) int) int {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt64) ReduceInt8(acc int8, f func(el int64, acc int8) int8) int8 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt64) ReduceInt16(acc int16, f func(el int64, acc int16) int16) int16 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt64) ReduceInt32(acc int32, f func(el int64, acc int32) int32) int32 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt64) ReduceInt64(acc int64, f func(el int64, acc int64) int64) int64 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt64) ReduceUint(acc uint, f func(el int64, acc uint) uint) uint {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt64) ReduceUint8(acc uint8, f func(el int64, acc uint8) uint8) uint8 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt64) ReduceUint16(acc uint16, f func(el int64, acc uint16) uint16) uint16 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt64) ReduceUint32(acc uint32, f func(el int64, acc uint32) uint32) uint32 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt64) ReduceUint64(acc uint64, f func(el int64, acc uint64) uint64) uint64 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInt64) ReduceInterface(acc interface{}, f func(el int64, acc interface{}) interface{}) interface{} {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt64) ScanBool(acc bool, f func(el int64, acc bool) bool) chan bool {
	result := make(chan bool, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt64) ScanByte(acc byte, f func(el int64, acc byte) byte) chan byte {
	result := make(chan byte, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt64) ScanString(acc string, f func(el int64, acc string) string) chan string {
	result := make(chan string, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt64) ScanFloat32(acc float32, f func(el int64, acc float32) float32) chan float32 {
	result := make(chan float32, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt64) ScanFloat64(acc float64, f func(el int64, acc float64) float64) chan float64 {
	result := make(chan float64, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt64) ScanInt(acc int, f func(el int64, acc int) int) chan int {
	result := make(chan int, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt64) ScanInt8(acc int8, f func(el int64, acc int8) int8) chan int8 {
	result := make(chan int8, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt64) ScanInt16(acc int16, f func(el int64, acc int16) int16) chan int16 {
	result := make(chan int16, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt64) ScanInt32(acc int32, f func(el int64, acc int32) int32) chan int32 {
	result := make(chan int32, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt64) ScanInt64(acc int64, f func(el int64, acc int64) int64) chan int64 {
	result := make(chan int64, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt64) ScanUint(acc uint, f func(el int64, acc uint) uint) chan uint {
	result := make(chan uint, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt64) ScanUint8(acc uint8, f func(el int64, acc uint8) uint8) chan uint8 {
	result := make(chan uint8, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt64) ScanUint16(acc uint16, f func(el int64, acc uint16) uint16) chan uint16 {
	result := make(chan uint16, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt64) ScanUint32(acc uint32, f func(el int64, acc uint32) uint32) chan uint32 {
	result := make(chan uint32, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt64) ScanUint64(acc uint64, f func(el int64, acc uint64) uint64) chan uint64 {
	result := make(chan uint64, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInt64) ScanInterface(acc interface{}, f func(el int64, acc interface{}) interface{}) chan interface{} {
	result := make(chan interface{}, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Sum returns sum of all elements from channel
func (c ChannelInt64) Sum() int64 {
	var sum int64
	for el := range c.Data {
		sum += el
	}
	return sum
}

// Take takes first count elements from the channel.
func (c ChannelInt64) Take(count int) chan int64 {
	result := make(chan int64, 1)
	go func() {
		defer close(result)
		if count <= 0 {
			return
		}
		i := 0
		for el := range c.Data {
			result <- el
			i++
			if i == count {
				return
			}
		}
	}()
	return result
}

// Tee returns 2 channels with elements from the input channel
func (c ChannelInt64) Tee(count int) []chan int64 {
	channels := make([]chan int64, 0, count)
	for i := 0; i < count; i++ {
		channels = append(channels, make(chan int64, 1))
	}
	go func() {
		for el := range c.Data {
			wg := sync.WaitGroup{}
			putInto := func(ch chan int64) {
				defer wg.Done()
				ch <- el
			}
			wg.Add(count)
			for _, ch := range channels {
				putInto(ch)
			}
			wg.Wait()
		}
		for _, ch := range channels {
			close(ch)
		}
	}()
	return channels
}

// ToSlice returns slice with all elements from channel.
func (c ChannelInt64) ToSlice() []int64 {
	result := make([]int64, 0)
	for val := range c.Data {
		result = append(result, val)
	}
	return result
}

// All returns true if f returns true for all elements in slice
func (s AsyncSliceInt64) All(f func(el int64) bool) bool {
	if len(s.Data) == 0 {
		return true
	}

	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int, result chan<- bool, ctx context.Context) {
		defer wg.Done()
		for {
			select {
			case <-ctx.Done():
				return
			case index, ok := <-jobs:
				if !ok {
					return
				}
				if !f(s.Data[index]) {
					result <- false
					return
				}
			}
		}
	}

	ctx, cancel := context.WithCancel(context.Background())
	// when we're returning the result, cancel all workers
	defer cancel()

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	result := make(chan bool, workers)
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs, result, ctx)
	}

	// close the result channel when all workers have done
	go func() {
		wg.Wait()
		close(result)
	}()

	// schedule the jobs: indices to check
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)

	for range result {
		return false
	}
	return true
}

// Any returns true if f returns true for any element from slice
func (s AsyncSliceInt64) Any(f func(el int64) bool) bool {
	if len(s.Data) == 0 {
		return false
	}

	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int, result chan<- bool, ctx context.Context) {
		defer wg.Done()
		for {
			select {
			case <-ctx.Done():
				return
			case index, ok := <-jobs:
				if !ok {
					return
				}
				if f(s.Data[index]) {
					result <- true
					return
				}
			}
		}
	}

	ctx, cancel := context.WithCancel(context.Background())
	// when we're returning the result, cancel all workers
	defer cancel()

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	result := make(chan bool, workers)
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs, result, ctx)
	}

	// close the result channel when all workers have done
	go func() {
		wg.Wait()
		close(result)
	}()

	// schedule the jobs: indices to check
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)

	for range result {
		return true
	}
	return false
}

// Each calls f for every element from slice
func (s AsyncSliceInt64) Each(f func(el int64)) {
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		defer wg.Done()
		for index := range jobs {
			f(s.Data[index])
		}
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
}

// Filter returns slice of element for which f returns true
func (s AsyncSliceInt64) Filter(f func(el int64) bool) []int64 {
	resultMap := make([]bool, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			if f(s.Data[index]) {
				resultMap[index] = true
			}
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()

	// return filtered results
	result := make([]int64, 0, len(s.Data))
	for i, el := range s.Data {
		if resultMap[i] {
			result = append(result, el)
		}
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt64) MapBool(f func(el int64) bool) []bool {
	result := make([]bool, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt64) MapByte(f func(el int64) byte) []byte {
	result := make([]byte, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt64) MapString(f func(el int64) string) []string {
	result := make([]string, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt64) MapFloat32(f func(el int64) float32) []float32 {
	result := make([]float32, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt64) MapFloat64(f func(el int64) float64) []float64 {
	result := make([]float64, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt64) MapInt(f func(el int64) int) []int {
	result := make([]int, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt64) MapInt8(f func(el int64) int8) []int8 {
	result := make([]int8, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt64) MapInt16(f func(el int64) int16) []int16 {
	result := make([]int16, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt64) MapInt32(f func(el int64) int32) []int32 {
	result := make([]int32, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt64) MapInt64(f func(el int64) int64) []int64 {
	result := make([]int64, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt64) MapUint(f func(el int64) uint) []uint {
	result := make([]uint, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt64) MapUint8(f func(el int64) uint8) []uint8 {
	result := make([]uint8, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt64) MapUint16(f func(el int64) uint16) []uint16 {
	result := make([]uint16, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt64) MapUint32(f func(el int64) uint32) []uint32 {
	result := make([]uint32, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt64) MapUint64(f func(el int64) uint64) []uint64 {
	result := make([]uint64, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInt64) MapInterface(f func(el int64) interface{}) []interface{} {
	result := make([]interface{}, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Reduce reduces slice to a single value with f
func (s AsyncSliceInt64) Reduce(f func(left int64, right int64) int64) int64 {
	if len(s.Data) == 0 {
		var tmp int64
		return tmp
	}

	state := make([]int64, len(s.Data))
	state = append(state, s.Data...)
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int, result chan<- int64) {
		for index := range jobs {
			result <- f(state[index], state[index+1])
		}
		wg.Done()
	}

	for len(state) > 1 {
		// calculate workers count
		workers := s.Workers
		if workers == 0 || workers > len(state) {
			workers = len(state)
		}

		// run workers
		jobs := make(chan int, len(state))
		wg.Add(workers)
		result := make(chan int64, 1)
		for i := 0; i < workers; i++ {
			go worker(jobs, result)
		}

		go func() {
			wg.Wait()
			close(result)
		}()

		// add indices into jobs for workers
		for i := 0; i < len(state)-1; i += 2 {
			jobs <- i
		}
		close(jobs)

		// collect new state
		newState := make([]int64, 0, len(state)/2+len(state)%2)
		for el := range result {
			newState = append(newState, el)
		}
		if len(state)%2 == 1 {
			newState = append(newState, state[len(state)-1])
		}
		// put new state as current state after all
		state = newState
	}

	return state[0]
}

// Count is like Range, but infinite
func (s SequenceInt64) Count(start int64, step int64) chan int64 {
	c := make(chan int64, 1)
	go func() {
		defer close(c)
		for {
			select {
			case <-s.ctx.Done():
				return
			case c <- start:
				start += step
			}
		}
	}()
	return c
}

// Exponential generates elements from start with
// multiplication of value on factor on every step
func (s SequenceInt64) Exponential(start int64, factor int64) chan int64 {
	c := make(chan int64, 1)
	go func() {
		defer close(c)
		for {
			select {
			case <-s.ctx.Done():
				return
			case c <- start:
				start *= factor
			}
		}
	}()
	return c
}

// Iterate returns an infinite list of repeated applications of f to val
func (s SequenceInt64) Iterate(val int64, f func(val int64) int64) chan int64 {
	c := make(chan int64, 1)
	go func() {
		defer close(c)
		for {
			select {
			case <-s.ctx.Done():
				return
			case c <- val:
				val = f(val)
			}
		}
	}()
	return c
}

// Range generates elements from start to end with given step
func (s SequenceInt64) Range(start int64, end int64, step int64) chan int64 {
	c := make(chan int64, 1)
	pos := start <= end
	go func() {
		for pos && (start < end) || !pos && (start > end) {
			c <- start
			start += step
		}
		close(c)
	}()
	return c
}

// Repeat returns channel that produces val infinite times
func (s SequenceInt64) Repeat(val int64) chan int64 {
	c := make(chan int64, 1)
	go func() {
		defer close(c)
		for {
			select {
			case <-s.ctx.Done():
				return
			case c <- val:
				continue
			}
		}
	}()
	return c
}

// Replicate returns channel that produces val n times
func (s SequenceInt64) Replicate(val int64, n int) chan int64 {
	c := make(chan int64, 1)
	go func() {
		for i := 0; i < n; i++ {
			c <- val
		}
		close(c)
	}()
	return c
}

// Min returns minimal value
func (PairInt64) Min(a int64, b int64) int64 {
	if a <= b {
		return a
	}
	return b
}

// Max returns maximal value
func (PairInt64) Max(a int64, b int64) int64 {
	if a > b {
		return a
	}
	return b
}

// Any returns true if f returns true for any element in arr
func (s SliceInt64) Any(f func(el int64) bool) bool {
	for _, el := range s.Data {
		if f(el) {
			return true
		}
	}
	return false
}

// All returns true if f returns true for all elements in arr
func (s SliceInt64) All(f func(el int64) bool) bool {
	for _, el := range s.Data {
		if !f(el) {
			return false
		}
	}
	return true
}

// Choice chooses a random element from the slice
func (s SliceInt64) Choice() (int64, error) {
	if len(s.Data) == 0 {
		var tmp int64
		return tmp, ErrEmpty
	}

	rand.Seed(time.Now().UnixNano())
	i := rand.Intn(len(s.Data))
	return s.Data[i], nil
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt64) ChunkByBool(f func(el int64) bool) [][]int64 {
	chunks := make([][]int64, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int64, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int64, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt64) ChunkByByte(f func(el int64) byte) [][]int64 {
	chunks := make([][]int64, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int64, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int64, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt64) ChunkByString(f func(el int64) string) [][]int64 {
	chunks := make([][]int64, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int64, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int64, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt64) ChunkByFloat32(f func(el int64) float32) [][]int64 {
	chunks := make([][]int64, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int64, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int64, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt64) ChunkByFloat64(f func(el int64) float64) [][]int64 {
	chunks := make([][]int64, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int64, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int64, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt64) ChunkByInt(f func(el int64) int) [][]int64 {
	chunks := make([][]int64, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int64, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int64, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt64) ChunkByInt8(f func(el int64) int8) [][]int64 {
	chunks := make([][]int64, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int64, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int64, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt64) ChunkByInt16(f func(el int64) int16) [][]int64 {
	chunks := make([][]int64, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int64, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int64, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt64) ChunkByInt32(f func(el int64) int32) [][]int64 {
	chunks := make([][]int64, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int64, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int64, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt64) ChunkByInt64(f func(el int64) int64) [][]int64 {
	chunks := make([][]int64, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int64, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int64, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt64) ChunkByUint(f func(el int64) uint) [][]int64 {
	chunks := make([][]int64, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int64, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int64, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt64) ChunkByUint8(f func(el int64) uint8) [][]int64 {
	chunks := make([][]int64, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int64, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int64, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt64) ChunkByUint16(f func(el int64) uint16) [][]int64 {
	chunks := make([][]int64, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int64, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int64, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt64) ChunkByUint32(f func(el int64) uint32) [][]int64 {
	chunks := make([][]int64, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int64, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int64, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt64) ChunkByUint64(f func(el int64) uint64) [][]int64 {
	chunks := make([][]int64, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int64, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int64, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInt64) ChunkByInterface(f func(el int64) interface{}) [][]int64 {
	chunks := make([][]int64, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]int64, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]int64, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkEvery returns slice of slices containing count elements each
func (s SliceInt64) ChunkEvery(count int) ([][]int64, error) {
	chunks := make([][]int64, 0)
	if count <= 0 {
		return chunks, ErrNegativeValue
	}
	chunk := make([]int64, 0, count)
	for i, el := range s.Data {
		chunk = append(chunk, el)
		if (i+1)%count == 0 {
			chunks = append(chunks, chunk)
			chunk = make([]int64, 0, count)
		}
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks, nil
}

// Contains returns true if el in arr.
func (s SliceInt64) Contains(el int64) bool {
	for _, val := range s.Data {
		if val == el {
			return true
		}
	}
	return false
}

// Count return count of el occurences in arr.
func (s SliceInt64) Count(el int64) int {
	count := 0
	for _, val := range s.Data {
		if val == el {
			count++
		}
	}
	return count
}

// CountBy returns how many times f returns true.
func (s SliceInt64) CountBy(f func(el int64) bool) int {
	count := 0
	for _, el := range s.Data {
		if f(el) {
			count++
		}
	}
	return count
}

// Cycle is an infinite loop over slice
func (s SliceInt64) Cycle() chan int64 {
	c := make(chan int64, 1)
	go func() {
		defer close(c)
		if len(s.Data) == 0 {
			return
		}
		for {
			for _, val := range s.Data {
				c <- val
			}
		}
	}()
	return c
}

// Dedup returns a given slice without consecutive duplicated elements
func (s SliceInt64) Dedup() []int64 {
	if len(s.Data) == 0 {
		return s.Data
	}

	result := make([]int64, 0, len(s.Data))
	prev := s.Data[0]
	result = append(result, prev)
	for _, el := range s.Data[1:] {
		if el != prev {
			result = append(result, el)
			prev = el
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt64) DedupByBool(f func(el int64) bool) []int64 {
	result := make([]int64, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt64) DedupByByte(f func(el int64) byte) []int64 {
	result := make([]int64, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt64) DedupByString(f func(el int64) string) []int64 {
	result := make([]int64, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt64) DedupByFloat32(f func(el int64) float32) []int64 {
	result := make([]int64, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt64) DedupByFloat64(f func(el int64) float64) []int64 {
	result := make([]int64, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt64) DedupByInt(f func(el int64) int) []int64 {
	result := make([]int64, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt64) DedupByInt8(f func(el int64) int8) []int64 {
	result := make([]int64, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt64) DedupByInt16(f func(el int64) int16) []int64 {
	result := make([]int64, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt64) DedupByInt32(f func(el int64) int32) []int64 {
	result := make([]int64, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt64) DedupByInt64(f func(el int64) int64) []int64 {
	result := make([]int64, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt64) DedupByUint(f func(el int64) uint) []int64 {
	result := make([]int64, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt64) DedupByUint8(f func(el int64) uint8) []int64 {
	result := make([]int64, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt64) DedupByUint16(f func(el int64) uint16) []int64 {
	result := make([]int64, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt64) DedupByUint32(f func(el int64) uint32) []int64 {
	result := make([]int64, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt64) DedupByUint64(f func(el int64) uint64) []int64 {
	result := make([]int64, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInt64) DedupByInterface(f func(el int64) interface{}) []int64 {
	result := make([]int64, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// Delete deletes the first occurence of the element from the slice
func (s SliceInt64) Delete(element int64) []int64 {
	result := make([]int64, 0, len(s.Data)-1)
	deleted := false
	for _, el := range s.Data {
		if !deleted && el == element {
			continue
		}
		result = append(result, el)
	}
	return result

}

// DeleteAt returns the slice without elements on given positions
func (s SliceInt64) DeleteAt(index int) ([]int64, error) {
	if index >= len(s.Data) {
		return s.Data, ErrOutOfRange
	}

	result := make([]int64, 0, len(s.Data)-1)
	for i, el := range s.Data {
		if i != index {
			result = append(result, el)
		}
	}
	return result, nil
}

// DropEvery returns a slice of every nth element in the enumerable dropped,
// starting with the first element.
func (s SliceInt64) DropEvery(nth int) ([]int64, error) {
	if nth <= 0 {
		return s.Data, ErrNonPositiveValue
	}
	result := make([]int64, 0, len(s.Data)/nth)
	for i, el := range s.Data {
		if (i+1)%nth != 0 {
			result = append(result, el)
		}
	}
	return result, nil
}

// DropWhile drops elements from arr while f returns true
func (s SliceInt64) DropWhile(f func(arr int64) bool) []int64 {
	result := make([]int64, 0, len(s.Data))
	for _, el := range s.Data {
		if !f(el) {
			return result
		}
		result = append(result, el)
	}
	return result
}

// Each calls f for every element from arr
func (s SliceInt64) Each(f func(el int64)) {
	for _, el := range s.Data {
		f(el)
	}
}

// Equal returns true if slices are equal
func (s SliceInt64) Equal(other []int64) bool {
	if len(s.Data) != len(other) {
		return false
	}
	for i, el := range other {
		if s.Data[i] != el {
			return false
		}
	}
	return true
}

// Filter returns slice of T for which F returned true
func (s SliceInt64) Filter(f func(el int64) bool) []int64 {
	result := make([]int64, 0, len(s.Data))
	for _, el := range s.Data {
		if f(el) {
			result = append(result, el)
		}
	}
	return result
}

// Find returns the first element for which f returns true
func (s SliceInt64) Find(f func(el int64) bool) (int64, error) {
	for _, el := range s.Data {
		if f(el) {
			return el, nil
		}
	}
	var tmp int64
	return tmp, ErrNotFound
}

// FindIndex is like Find, but return element index instead of element itself
func (s SliceInt64) FindIndex(f func(el int64) bool) (int, error) {
	for i, el := range s.Data {
		if f(el) {
			return i, nil
		}
	}
	return 0, ErrNotFound
}

// Join concatenates elements of the slice to create a single string.
func (s SliceInt64) Join(sep string) string {
	strs := make([]string, 0, len(s.Data))
	for _, el := range s.Data {
		strs = append(strs, string(el))
	}
	return strings.Join(strs, sep)
}

// GroupBy groups element from array by value returned by f
func (s SliceInt64) GroupByBool(f func(el int64) bool) map[bool][]int64 {
	result := make(map[bool][]int64)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int64, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt64) GroupByByte(f func(el int64) byte) map[byte][]int64 {
	result := make(map[byte][]int64)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int64, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt64) GroupByString(f func(el int64) string) map[string][]int64 {
	result := make(map[string][]int64)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int64, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt64) GroupByFloat32(f func(el int64) float32) map[float32][]int64 {
	result := make(map[float32][]int64)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int64, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt64) GroupByFloat64(f func(el int64) float64) map[float64][]int64 {
	result := make(map[float64][]int64)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int64, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt64) GroupByInt(f func(el int64) int) map[int][]int64 {
	result := make(map[int][]int64)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int64, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt64) GroupByInt8(f func(el int64) int8) map[int8][]int64 {
	result := make(map[int8][]int64)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int64, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt64) GroupByInt16(f func(el int64) int16) map[int16][]int64 {
	result := make(map[int16][]int64)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int64, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt64) GroupByInt32(f func(el int64) int32) map[int32][]int64 {
	result := make(map[int32][]int64)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int64, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt64) GroupByInt64(f func(el int64) int64) map[int64][]int64 {
	result := make(map[int64][]int64)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int64, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt64) GroupByUint(f func(el int64) uint) map[uint][]int64 {
	result := make(map[uint][]int64)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int64, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt64) GroupByUint8(f func(el int64) uint8) map[uint8][]int64 {
	result := make(map[uint8][]int64)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int64, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt64) GroupByUint16(f func(el int64) uint16) map[uint16][]int64 {
	result := make(map[uint16][]int64)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int64, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt64) GroupByUint32(f func(el int64) uint32) map[uint32][]int64 {
	result := make(map[uint32][]int64)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int64, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt64) GroupByUint64(f func(el int64) uint64) map[uint64][]int64 {
	result := make(map[uint64][]int64)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int64, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInt64) GroupByInterface(f func(el int64) interface{}) map[interface{}][]int64 {
	result := make(map[interface{}][]int64)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]int64, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// InsertAt returns the slice with element inserted at given index.
func (s SliceInt64) InsertAt(index int, element int64) ([]int64, error) {
	result := make([]int64, 0, len(s.Data)+1)

	// insert at the end
	if index == len(s.Data) || index == -1 {
		result = append(result, s.Data...)
		result = append(result, element)
		return result, nil
	}

	if index > len(s.Data) {
		return s.Data, ErrOutOfRange
	}
	if index < 0 {
		return s.Data, ErrNegativeValue
	}

	for i, el := range s.Data {
		if i == index {
			result = append(result, element)
		}
		result = append(result, el)
	}
	return result, nil
}

// Intersperse inserts el between each element of arr
func (s SliceInt64) Intersperse(el int64) []int64 {
	if len(s.Data) == 0 {
		return s.Data
	}
	result := make([]int64, 0, len(s.Data)*2-1)
	result = append(result, s.Data[0])
	for _, val := range s.Data[1:] {
		result = append(result, el, val)
	}
	return result
}

// Last returns the last element from the slice
func (s SliceInt64) Last() (int64, error) {
	if len(s.Data) == 0 {
		var tmp int64
		return tmp, ErrEmpty
	}
	return s.Data[len(s.Data)-1], nil
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt64) MapBool(f func(el int64) bool) []bool {
	result := make([]bool, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt64) MapByte(f func(el int64) byte) []byte {
	result := make([]byte, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt64) MapString(f func(el int64) string) []string {
	result := make([]string, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt64) MapFloat32(f func(el int64) float32) []float32 {
	result := make([]float32, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt64) MapFloat64(f func(el int64) float64) []float64 {
	result := make([]float64, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt64) MapInt(f func(el int64) int) []int {
	result := make([]int, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt64) MapInt8(f func(el int64) int8) []int8 {
	result := make([]int8, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt64) MapInt16(f func(el int64) int16) []int16 {
	result := make([]int16, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt64) MapInt32(f func(el int64) int32) []int32 {
	result := make([]int32, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt64) MapInt64(f func(el int64) int64) []int64 {
	result := make([]int64, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt64) MapUint(f func(el int64) uint) []uint {
	result := make([]uint, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt64) MapUint8(f func(el int64) uint8) []uint8 {
	result := make([]uint8, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt64) MapUint16(f func(el int64) uint16) []uint16 {
	result := make([]uint16, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt64) MapUint32(f func(el int64) uint32) []uint32 {
	result := make([]uint32, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt64) MapUint64(f func(el int64) uint64) []uint64 {
	result := make([]uint64, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInt64) MapInterface(f func(el int64) interface{}) []interface{} {
	result := make([]interface{}, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Max returns the maximal element from arr
func (s SliceInt64) Max() (int64, error) {
	if len(s.Data) == 0 {
		var tmp int64
		return tmp, ErrEmpty
	}

	max := s.Data[0]
	for _, el := range s.Data[1:] {
		if el > max {
			max = el
		}
	}
	return max, nil
}

// Min returns the minimal element from arr
func (s SliceInt64) Min() (int64, error) {
	if len(s.Data) == 0 {
		var tmp int64
		return tmp, ErrEmpty
	}

	min := s.Data[0]
	for _, el := range s.Data[1:] {
		if el < min {
			min = el
		}
	}
	return min, nil
}

// Permutations returns successive size-length permutations of elements from the slice.
// {1, 2, 3} -> {1, 2}, {1, 3}, {2, 1}, {2, 3}, {3, 1}, {3, 2}
func (s SliceInt64) Permutations(size int) chan []int64 {
	c := make(chan []int64, 1)
	go func() {
		if len(s.Data) > 0 {
			s.permutations(c, size, []int64{}, s.Data)
		}
		close(c)
	}()
	return c
}

// permutations is a core implementation for Permutations
func (s SliceInt64) permutations(c chan []int64, size int, left []int64, right []int64) {
	if len(left) == size || len(right) == 0 {
		c <- left
		return
	}

	for i, el := range right {
		newLeft := make([]int64, 0, len(left)+1)
		newLeft = append(newLeft, left...)
		newLeft = append(newLeft, el)

		newRight := make([]int64, 0, len(right)-1)
		for j, other := range right {
			if j != i {
				newRight = append(newRight, other)
			}
		}
		s.permutations(c, size, newLeft, newRight)
	}
}

// Product returns cortesian product of elements
// {{1, 2}, {3, 4}} -> {1, 3}, {1, 4}, {2, 3}, {2, 4}
func (s SliceInt64) Product(repeat int) chan []int64 {
	c := make(chan []int64, 1)
	go s.product(c, repeat, []int64{}, 0)
	return c
}

// product is a core implementation for Product
func (s SliceInt64) product(c chan []int64, repeat int, left []int64, pos int) {
	// iterate over the last array
	if pos == repeat-1 {
		for _, el := range s.Data {
			result := make([]int64, 0, len(left)+1)
			result = append(result, left...)
			result = append(result, el)
			c <- result
		}
		return
	}

	for _, el := range s.Data {
		result := make([]int64, 0, len(left)+1)
		result = append(result, left...)
		result = append(result, el)
		s.product(c, repeat, result, pos+1)
	}

	if pos == 0 {
		close(c)
	}
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt64) ReduceBool(acc bool, f func(el int64, acc bool) bool) bool {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt64) ReduceByte(acc byte, f func(el int64, acc byte) byte) byte {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt64) ReduceString(acc string, f func(el int64, acc string) string) string {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt64) ReduceFloat32(acc float32, f func(el int64, acc float32) float32) float32 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt64) ReduceFloat64(acc float64, f func(el int64, acc float64) float64) float64 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt64) ReduceInt(acc int, f func(el int64, acc int) int) int {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt64) ReduceInt8(acc int8, f func(el int64, acc int8) int8) int8 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt64) ReduceInt16(acc int16, f func(el int64, acc int16) int16) int16 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt64) ReduceInt32(acc int32, f func(el int64, acc int32) int32) int32 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt64) ReduceInt64(acc int64, f func(el int64, acc int64) int64) int64 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt64) ReduceUint(acc uint, f func(el int64, acc uint) uint) uint {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt64) ReduceUint8(acc uint8, f func(el int64, acc uint8) uint8) uint8 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt64) ReduceUint16(acc uint16, f func(el int64, acc uint16) uint16) uint16 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt64) ReduceUint32(acc uint32, f func(el int64, acc uint32) uint32) uint32 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt64) ReduceUint64(acc uint64, f func(el int64, acc uint64) uint64) uint64 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInt64) ReduceInterface(acc interface{}, f func(el int64, acc interface{}) interface{}) interface{} {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt64) ReduceWhileBool(acc bool, f func(el int64, acc bool) (bool, error)) (bool, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt64) ReduceWhileByte(acc byte, f func(el int64, acc byte) (byte, error)) (byte, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt64) ReduceWhileString(acc string, f func(el int64, acc string) (string, error)) (string, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt64) ReduceWhileFloat32(acc float32, f func(el int64, acc float32) (float32, error)) (float32, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt64) ReduceWhileFloat64(acc float64, f func(el int64, acc float64) (float64, error)) (float64, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt64) ReduceWhileInt(acc int, f func(el int64, acc int) (int, error)) (int, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt64) ReduceWhileInt8(acc int8, f func(el int64, acc int8) (int8, error)) (int8, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt64) ReduceWhileInt16(acc int16, f func(el int64, acc int16) (int16, error)) (int16, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt64) ReduceWhileInt32(acc int32, f func(el int64, acc int32) (int32, error)) (int32, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt64) ReduceWhileInt64(acc int64, f func(el int64, acc int64) (int64, error)) (int64, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt64) ReduceWhileUint(acc uint, f func(el int64, acc uint) (uint, error)) (uint, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt64) ReduceWhileUint8(acc uint8, f func(el int64, acc uint8) (uint8, error)) (uint8, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt64) ReduceWhileUint16(acc uint16, f func(el int64, acc uint16) (uint16, error)) (uint16, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt64) ReduceWhileUint32(acc uint32, f func(el int64, acc uint32) (uint32, error)) (uint32, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt64) ReduceWhileUint64(acc uint64, f func(el int64, acc uint64) (uint64, error)) (uint64, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInt64) ReduceWhileInterface(acc interface{}, f func(el int64, acc interface{}) (interface{}, error)) (interface{}, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// Reverse returns given arr in reversed order
func (s SliceInt64) Reverse() []int64 {
	if len(s.Data) <= 1 {
		return s.Data
	}
	result := make([]int64, 0, len(s.Data))
	for i := len(s.Data) - 1; i >= 0; i-- {
		result = append(result, s.Data[i])
	}
	return result
}

// Same returns true if all element in arr the same
func (s SliceInt64) Same() bool {
	if len(s.Data) <= 1 {
		return true
	}
	for i := 0; i < len(s.Data)-1; i++ {
		if s.Data[i] != s.Data[i+1] {
			return false
		}
	}
	return true
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt64) ScanBool(acc bool, f func(el int64, acc bool) bool) []bool {
	result := make([]bool, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt64) ScanByte(acc byte, f func(el int64, acc byte) byte) []byte {
	result := make([]byte, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt64) ScanString(acc string, f func(el int64, acc string) string) []string {
	result := make([]string, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt64) ScanFloat32(acc float32, f func(el int64, acc float32) float32) []float32 {
	result := make([]float32, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt64) ScanFloat64(acc float64, f func(el int64, acc float64) float64) []float64 {
	result := make([]float64, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt64) ScanInt(acc int, f func(el int64, acc int) int) []int {
	result := make([]int, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt64) ScanInt8(acc int8, f func(el int64, acc int8) int8) []int8 {
	result := make([]int8, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt64) ScanInt16(acc int16, f func(el int64, acc int16) int16) []int16 {
	result := make([]int16, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt64) ScanInt32(acc int32, f func(el int64, acc int32) int32) []int32 {
	result := make([]int32, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt64) ScanInt64(acc int64, f func(el int64, acc int64) int64) []int64 {
	result := make([]int64, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt64) ScanUint(acc uint, f func(el int64, acc uint) uint) []uint {
	result := make([]uint, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt64) ScanUint8(acc uint8, f func(el int64, acc uint8) uint8) []uint8 {
	result := make([]uint8, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt64) ScanUint16(acc uint16, f func(el int64, acc uint16) uint16) []uint16 {
	result := make([]uint16, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt64) ScanUint32(acc uint32, f func(el int64, acc uint32) uint32) []uint32 {
	result := make([]uint32, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt64) ScanUint64(acc uint64, f func(el int64, acc uint64) uint64) []uint64 {
	result := make([]uint64, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInt64) ScanInterface(acc interface{}, f func(el int64, acc interface{}) interface{}) []interface{} {
	result := make([]interface{}, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Shuffle in random order arr elements
func (s SliceInt64) Shuffle() []int64 {
	if len(s.Data) <= 1 {
		return s.Data
	}
	rand.Seed(time.Now().UnixNano())
	swap := func(i, j int) {
		s.Data[i], s.Data[j] = s.Data[j], s.Data[i]
	}
	rand.Shuffle(len(s.Data), swap)
	return s.Data
}

// Sort returns sorted slice
func (s SliceInt64) Sort() []int64 {
	if len(s.Data) <= 1 {
		return s.Data
	}
	less := func(i int, j int) bool {
		return s.Data[i] < s.Data[j]
	}
	sort.SliceStable(s.Data, less)
	return s.Data
}

// Sorted returns true if slice is sorted
func (s SliceInt64) Sorted() bool {
	if len(s.Data) <= 1 {
		return true
	}
	for i := 1; i < len(s.Data); i++ {
		if s.Data[i-1] > s.Data[i] {
			return false
		}
	}
	return true
}

// Split splits arr by sep
func (s SliceInt64) Split(sep int64) [][]int64 {
	result := make([][]int64, 0)
	curr := make([]int64, 0)
	for _, el := range s.Data {
		if el == sep {
			result = append(result, curr)
		} else {
			curr = append(curr, el)
		}
	}
	result = append(result, curr)
	return result
}

// StartsWith returns true if slice starts with the given prefix slice.
// If prefix is empty, it returns true.
func (s SliceInt64) StartsWith(prefix []int64) bool {
	if len(prefix) > len(s.Data) {
		return false
	}
	for i, el := range prefix {
		if el != s.Data[i] {
			return false
		}
	}
	return true
}

// Sum return sum of all elements from arr
func (s SliceInt64) Sum() int64 {
	var sum int64
	for _, el := range s.Data {
		sum += el
	}
	return sum
}

// TakeEvery returns slice of every nth elements
func (s SliceInt64) TakeEvery(nth int) ([]int64, error) {
	if nth <= 0 {
		return s.Data, ErrNonPositiveValue
	}
	result := make([]int64, 0, len(s.Data))
	for i, el := range s.Data {
		if (i+1)%nth == 0 {
			result = append(result, el)
		}
	}
	return result, nil
}

// TakeRandom returns slice of count random elements from the slice
func (s SliceInt64) TakeRandom(count int) ([]int64, error) {
	if count > len(s.Data) {
		return nil, ErrOutOfRange
	}
	if count <= 0 {
		return nil, ErrNonPositiveValue
	}

	rand.Seed(time.Now().UnixNano())
	swap := func(i, j int) {
		s.Data[i], s.Data[j] = s.Data[j], s.Data[i]
	}
	rand.Shuffle(len(s.Data), swap)
	return s.Data[:count], nil
}

// TakeWhile takes elements from arr while f returns true
func (s SliceInt64) TakeWhile(f func(el int64) bool) []int64 {
	result := make([]int64, 0, len(s.Data))
	for _, el := range s.Data {
		if !f(el) {
			return result
		}
		result = append(result, el)
	}
	return result
}

// ToChannel returns channel with elements from the slice
func (s SliceInt64) ToChannel() chan int64 {
	c := make(chan int64, 1)
	go func() {
		for _, el := range s.Data {
			c <- el
		}
		close(c)
	}()
	return c
}

// Uniq returns arr with only first occurences of every element.
func (s SliceInt64) Uniq() []int64 {
	if len(s.Data) <= 1 {
		return s.Data
	}
	added := make(map[int64]struct{})
	nothing := struct{}{}
	result := make([]int64, 0, len(s.Data))
	for _, el := range s.Data {
		_, exists := added[el]
		if !exists {
			result = append(result, el)
			added[el] = nothing
		}
	}
	return result

}

// Window makes sliding window for a given slice:
// ({1,2,3}, 2) -> (1,2), (2,3)
func (s SliceInt64) Window(size int) ([][]int64, error) {
	if size <= 0 {
		return nil, ErrNonPositiveValue
	}
	result := make([][]int64, 0, len(s.Data)/size)
	for i := 0; i <= len(s.Data)-size; i++ {
		chunk := s.Data[i : i+size]
		result = append(result, chunk)
	}
	return result, nil
}

// Without returns the slice with filtered out element
func (s SliceInt64) Without(elements ...int64) []int64 {
	result := make([]int64, 0, len(s.Data))
	for _, el := range s.Data {
		allowed := true
		for _, other := range elements {
			if el == other {
				allowed = false
			}
		}
		if allowed {
			result = append(result, el)
		}
	}
	return result
}

// Concat concatenates given slices into a single slice.
func (s SlicesInt64) Concat() []int64 {
	result := make([]int64, 0)
	for _, arr := range s.Data {
		result = append(result, arr...)
	}
	return result
}

// Product returns cortesian product of elements
// {{1, 2}, {3, 4}} -> {1, 3}, {1, 4}, {2, 3}, {2, 4}
func (s SlicesInt64) Product() chan []int64 {
	c := make(chan []int64, 1)
	go s.product(c, []int64{}, 0)
	return c
}

// product is a core implementation of Product
func (s SlicesInt64) product(c chan []int64, left []int64, pos int) {
	// iterate over the last array
	if pos == len(s.Data)-1 {
		for _, el := range s.Data[pos] {
			result := make([]int64, 0, len(left)+1)
			result = append(result, left...)
			result = append(result, el)
			c <- result
		}
		return
	}

	for _, el := range s.Data[pos] {
		result := make([]int64, 0, len(left)+1)
		result = append(result, left...)
		result = append(result, el)
		s.product(c, result, pos+1)
	}

	if pos == 0 {
		close(c)
	}
}

// Zip returns array of arrays of elements from given arrs
// on the same position
func (s SlicesInt64) Zip() [][]int64 {
	size := len(s.Data[0])
	for _, arr := range s.Data[1:] {
		if len(arr) > size {
			size = len(arr)
		}
	}

	result := make([][]int64, 0, size)
	for i := 0; i <= size; i++ {
		chunk := make([]int64, 0, len(s.Data))
		for _, arr := range s.Data {
			chunk = append(chunk, arr[i])
		}
		result = append(result, chunk)
	}
	return result
}

// Channel is a set of operations with channel
type ChannelUint struct {
	Data chan uint
}

// AsyncSlice is a set of operations to work with slice asynchronously
type AsyncSliceUint struct {
	Data    []uint
	Workers int
}

// Sequence is a set of operations to generate sequences
type SequenceUint struct {
	ctx context.Context
}

// Pair is a set of functions for 2 values that you can pass into reduce-like funcs
type PairUint struct {
	// empty
}

// Slice is a set of operations to work with slice
type SliceUint struct {
	Data []uint
}

// Slices is a set of operations to work with slice of slices
type SlicesUint struct {
	Data [][]uint
}

// Any returns true if f returns true for any element in channel
func (c ChannelUint) Any(f func(el uint) bool) bool {
	for el := range c.Data {
		if f(el) {
			return true
		}
	}
	return false
}

// All returns true if f returns true for all elements in channel
func (c ChannelUint) All(f func(el uint) bool) bool {
	for el := range c.Data {
		if !f(el) {
			return false
		}
	}
	return true
}

// ChunkEvery returns channel with slices containing count elements each
func (c ChannelUint) ChunkEvery(count int) chan []uint {
	chunks := make(chan []uint, 1)
	go func() {
		chunk := make([]uint, 0, count)
		i := 0
		for el := range c.Data {
			chunk = append(chunk, el)
			i++
			if i%count == 0 {
				i = 0
				chunks <- chunk
				chunk = make([]uint, 0, count)
			}
		}
		if len(chunk) > 0 {
			chunks <- chunk
		}
		close(chunks)
	}()
	return chunks
}

// Count return count of el occurences in channel.
func (c ChannelUint) Count(el uint) int {
	count := 0
	for val := range c.Data {
		if val == el {
			count++
		}
	}
	return count
}

// Drop drops first n elements from channel c and returns a new channel with the rest.
// It returns channel do be unblocking. If you want array instead, wrap result into TakeAll.
func (c ChannelUint) Drop(n int) chan uint {
	result := make(chan uint, 1)
	go func() {
		i := 0
		for el := range c.Data {
			if i >= n {
				result <- el
			}
			i++
		}
		close(result)
	}()
	return result
}

// Each calls f for every element in the channel
func (c ChannelUint) Each(f func(el uint)) {
	for el := range c.Data {
		f(el)
	}
}

// Filter returns a new channel with elements from input channel
// for which f returns true
func (c ChannelUint) Filter(f func(el uint) bool) chan uint {
	result := make(chan uint, 1)
	go func() {
		for el := range c.Data {
			if f(el) {
				result <- el
			}
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint) MapBool(f func(el uint) bool) chan bool {
	result := make(chan bool, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint) MapByte(f func(el uint) byte) chan byte {
	result := make(chan byte, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint) MapString(f func(el uint) string) chan string {
	result := make(chan string, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint) MapFloat32(f func(el uint) float32) chan float32 {
	result := make(chan float32, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint) MapFloat64(f func(el uint) float64) chan float64 {
	result := make(chan float64, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint) MapInt(f func(el uint) int) chan int {
	result := make(chan int, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint) MapInt8(f func(el uint) int8) chan int8 {
	result := make(chan int8, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint) MapInt16(f func(el uint) int16) chan int16 {
	result := make(chan int16, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint) MapInt32(f func(el uint) int32) chan int32 {
	result := make(chan int32, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint) MapInt64(f func(el uint) int64) chan int64 {
	result := make(chan int64, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint) MapUint(f func(el uint) uint) chan uint {
	result := make(chan uint, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint) MapUint8(f func(el uint) uint8) chan uint8 {
	result := make(chan uint8, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint) MapUint16(f func(el uint) uint16) chan uint16 {
	result := make(chan uint16, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint) MapUint32(f func(el uint) uint32) chan uint32 {
	result := make(chan uint32, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint) MapUint64(f func(el uint) uint64) chan uint64 {
	result := make(chan uint64, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint) MapInterface(f func(el uint) interface{}) chan interface{} {
	result := make(chan interface{}, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Max returns the maximal element from channel
func (c ChannelUint) Max() (uint, error) {
	max, ok := <-c.Data
	if !ok {
		return max, ErrEmpty
	}
	for el := range c.Data {
		if el > max {
			max = el
		}
	}
	return max, nil
}

// Min returns the minimal element from channel
func (c ChannelUint) Min() (uint, error) {
	min, ok := <-c.Data
	if !ok {
		return min, ErrEmpty
	}
	for el := range c.Data {
		if el < min {
			min = el
		}
	}
	return min, nil
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint) ReduceBool(acc bool, f func(el uint, acc bool) bool) bool {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint) ReduceByte(acc byte, f func(el uint, acc byte) byte) byte {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint) ReduceString(acc string, f func(el uint, acc string) string) string {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint) ReduceFloat32(acc float32, f func(el uint, acc float32) float32) float32 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint) ReduceFloat64(acc float64, f func(el uint, acc float64) float64) float64 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint) ReduceInt(acc int, f func(el uint, acc int) int) int {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint) ReduceInt8(acc int8, f func(el uint, acc int8) int8) int8 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint) ReduceInt16(acc int16, f func(el uint, acc int16) int16) int16 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint) ReduceInt32(acc int32, f func(el uint, acc int32) int32) int32 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint) ReduceInt64(acc int64, f func(el uint, acc int64) int64) int64 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint) ReduceUint(acc uint, f func(el uint, acc uint) uint) uint {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint) ReduceUint8(acc uint8, f func(el uint, acc uint8) uint8) uint8 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint) ReduceUint16(acc uint16, f func(el uint, acc uint16) uint16) uint16 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint) ReduceUint32(acc uint32, f func(el uint, acc uint32) uint32) uint32 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint) ReduceUint64(acc uint64, f func(el uint, acc uint64) uint64) uint64 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint) ReduceInterface(acc interface{}, f func(el uint, acc interface{}) interface{}) interface{} {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint) ScanBool(acc bool, f func(el uint, acc bool) bool) chan bool {
	result := make(chan bool, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint) ScanByte(acc byte, f func(el uint, acc byte) byte) chan byte {
	result := make(chan byte, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint) ScanString(acc string, f func(el uint, acc string) string) chan string {
	result := make(chan string, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint) ScanFloat32(acc float32, f func(el uint, acc float32) float32) chan float32 {
	result := make(chan float32, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint) ScanFloat64(acc float64, f func(el uint, acc float64) float64) chan float64 {
	result := make(chan float64, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint) ScanInt(acc int, f func(el uint, acc int) int) chan int {
	result := make(chan int, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint) ScanInt8(acc int8, f func(el uint, acc int8) int8) chan int8 {
	result := make(chan int8, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint) ScanInt16(acc int16, f func(el uint, acc int16) int16) chan int16 {
	result := make(chan int16, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint) ScanInt32(acc int32, f func(el uint, acc int32) int32) chan int32 {
	result := make(chan int32, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint) ScanInt64(acc int64, f func(el uint, acc int64) int64) chan int64 {
	result := make(chan int64, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint) ScanUint(acc uint, f func(el uint, acc uint) uint) chan uint {
	result := make(chan uint, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint) ScanUint8(acc uint8, f func(el uint, acc uint8) uint8) chan uint8 {
	result := make(chan uint8, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint) ScanUint16(acc uint16, f func(el uint, acc uint16) uint16) chan uint16 {
	result := make(chan uint16, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint) ScanUint32(acc uint32, f func(el uint, acc uint32) uint32) chan uint32 {
	result := make(chan uint32, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint) ScanUint64(acc uint64, f func(el uint, acc uint64) uint64) chan uint64 {
	result := make(chan uint64, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint) ScanInterface(acc interface{}, f func(el uint, acc interface{}) interface{}) chan interface{} {
	result := make(chan interface{}, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Sum returns sum of all elements from channel
func (c ChannelUint) Sum() uint {
	var sum uint
	for el := range c.Data {
		sum += el
	}
	return sum
}

// Take takes first count elements from the channel.
func (c ChannelUint) Take(count int) chan uint {
	result := make(chan uint, 1)
	go func() {
		defer close(result)
		if count <= 0 {
			return
		}
		i := 0
		for el := range c.Data {
			result <- el
			i++
			if i == count {
				return
			}
		}
	}()
	return result
}

// Tee returns 2 channels with elements from the input channel
func (c ChannelUint) Tee(count int) []chan uint {
	channels := make([]chan uint, 0, count)
	for i := 0; i < count; i++ {
		channels = append(channels, make(chan uint, 1))
	}
	go func() {
		for el := range c.Data {
			wg := sync.WaitGroup{}
			putInto := func(ch chan uint) {
				defer wg.Done()
				ch <- el
			}
			wg.Add(count)
			for _, ch := range channels {
				putInto(ch)
			}
			wg.Wait()
		}
		for _, ch := range channels {
			close(ch)
		}
	}()
	return channels
}

// ToSlice returns slice with all elements from channel.
func (c ChannelUint) ToSlice() []uint {
	result := make([]uint, 0)
	for val := range c.Data {
		result = append(result, val)
	}
	return result
}

// All returns true if f returns true for all elements in slice
func (s AsyncSliceUint) All(f func(el uint) bool) bool {
	if len(s.Data) == 0 {
		return true
	}

	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int, result chan<- bool, ctx context.Context) {
		defer wg.Done()
		for {
			select {
			case <-ctx.Done():
				return
			case index, ok := <-jobs:
				if !ok {
					return
				}
				if !f(s.Data[index]) {
					result <- false
					return
				}
			}
		}
	}

	ctx, cancel := context.WithCancel(context.Background())
	// when we're returning the result, cancel all workers
	defer cancel()

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	result := make(chan bool, workers)
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs, result, ctx)
	}

	// close the result channel when all workers have done
	go func() {
		wg.Wait()
		close(result)
	}()

	// schedule the jobs: indices to check
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)

	for range result {
		return false
	}
	return true
}

// Any returns true if f returns true for any element from slice
func (s AsyncSliceUint) Any(f func(el uint) bool) bool {
	if len(s.Data) == 0 {
		return false
	}

	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int, result chan<- bool, ctx context.Context) {
		defer wg.Done()
		for {
			select {
			case <-ctx.Done():
				return
			case index, ok := <-jobs:
				if !ok {
					return
				}
				if f(s.Data[index]) {
					result <- true
					return
				}
			}
		}
	}

	ctx, cancel := context.WithCancel(context.Background())
	// when we're returning the result, cancel all workers
	defer cancel()

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	result := make(chan bool, workers)
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs, result, ctx)
	}

	// close the result channel when all workers have done
	go func() {
		wg.Wait()
		close(result)
	}()

	// schedule the jobs: indices to check
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)

	for range result {
		return true
	}
	return false
}

// Each calls f for every element from slice
func (s AsyncSliceUint) Each(f func(el uint)) {
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		defer wg.Done()
		for index := range jobs {
			f(s.Data[index])
		}
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
}

// Filter returns slice of element for which f returns true
func (s AsyncSliceUint) Filter(f func(el uint) bool) []uint {
	resultMap := make([]bool, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			if f(s.Data[index]) {
				resultMap[index] = true
			}
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()

	// return filtered results
	result := make([]uint, 0, len(s.Data))
	for i, el := range s.Data {
		if resultMap[i] {
			result = append(result, el)
		}
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint) MapBool(f func(el uint) bool) []bool {
	result := make([]bool, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint) MapByte(f func(el uint) byte) []byte {
	result := make([]byte, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint) MapString(f func(el uint) string) []string {
	result := make([]string, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint) MapFloat32(f func(el uint) float32) []float32 {
	result := make([]float32, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint) MapFloat64(f func(el uint) float64) []float64 {
	result := make([]float64, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint) MapInt(f func(el uint) int) []int {
	result := make([]int, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint) MapInt8(f func(el uint) int8) []int8 {
	result := make([]int8, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint) MapInt16(f func(el uint) int16) []int16 {
	result := make([]int16, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint) MapInt32(f func(el uint) int32) []int32 {
	result := make([]int32, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint) MapInt64(f func(el uint) int64) []int64 {
	result := make([]int64, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint) MapUint(f func(el uint) uint) []uint {
	result := make([]uint, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint) MapUint8(f func(el uint) uint8) []uint8 {
	result := make([]uint8, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint) MapUint16(f func(el uint) uint16) []uint16 {
	result := make([]uint16, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint) MapUint32(f func(el uint) uint32) []uint32 {
	result := make([]uint32, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint) MapUint64(f func(el uint) uint64) []uint64 {
	result := make([]uint64, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint) MapInterface(f func(el uint) interface{}) []interface{} {
	result := make([]interface{}, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Reduce reduces slice to a single value with f
func (s AsyncSliceUint) Reduce(f func(left uint, right uint) uint) uint {
	if len(s.Data) == 0 {
		var tmp uint
		return tmp
	}

	state := make([]uint, len(s.Data))
	state = append(state, s.Data...)
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int, result chan<- uint) {
		for index := range jobs {
			result <- f(state[index], state[index+1])
		}
		wg.Done()
	}

	for len(state) > 1 {
		// calculate workers count
		workers := s.Workers
		if workers == 0 || workers > len(state) {
			workers = len(state)
		}

		// run workers
		jobs := make(chan int, len(state))
		wg.Add(workers)
		result := make(chan uint, 1)
		for i := 0; i < workers; i++ {
			go worker(jobs, result)
		}

		go func() {
			wg.Wait()
			close(result)
		}()

		// add indices into jobs for workers
		for i := 0; i < len(state)-1; i += 2 {
			jobs <- i
		}
		close(jobs)

		// collect new state
		newState := make([]uint, 0, len(state)/2+len(state)%2)
		for el := range result {
			newState = append(newState, el)
		}
		if len(state)%2 == 1 {
			newState = append(newState, state[len(state)-1])
		}
		// put new state as current state after all
		state = newState
	}

	return state[0]
}

// Count is like Range, but infinite
func (s SequenceUint) Count(start uint, step uint) chan uint {
	c := make(chan uint, 1)
	go func() {
		defer close(c)
		for {
			select {
			case <-s.ctx.Done():
				return
			case c <- start:
				start += step
			}
		}
	}()
	return c
}

// Exponential generates elements from start with
// multiplication of value on factor on every step
func (s SequenceUint) Exponential(start uint, factor uint) chan uint {
	c := make(chan uint, 1)
	go func() {
		defer close(c)
		for {
			select {
			case <-s.ctx.Done():
				return
			case c <- start:
				start *= factor
			}
		}
	}()
	return c
}

// Iterate returns an infinite list of repeated applications of f to val
func (s SequenceUint) Iterate(val uint, f func(val uint) uint) chan uint {
	c := make(chan uint, 1)
	go func() {
		defer close(c)
		for {
			select {
			case <-s.ctx.Done():
				return
			case c <- val:
				val = f(val)
			}
		}
	}()
	return c
}

// Range generates elements from start to end with given step
func (s SequenceUint) Range(start uint, end uint, step uint) chan uint {
	c := make(chan uint, 1)
	pos := start <= end
	go func() {
		for pos && (start < end) || !pos && (start > end) {
			c <- start
			start += step
		}
		close(c)
	}()
	return c
}

// Repeat returns channel that produces val infinite times
func (s SequenceUint) Repeat(val uint) chan uint {
	c := make(chan uint, 1)
	go func() {
		defer close(c)
		for {
			select {
			case <-s.ctx.Done():
				return
			case c <- val:
				continue
			}
		}
	}()
	return c
}

// Replicate returns channel that produces val n times
func (s SequenceUint) Replicate(val uint, n int) chan uint {
	c := make(chan uint, 1)
	go func() {
		for i := 0; i < n; i++ {
			c <- val
		}
		close(c)
	}()
	return c
}

// Min returns minimal value
func (PairUint) Min(a uint, b uint) uint {
	if a <= b {
		return a
	}
	return b
}

// Max returns maximal value
func (PairUint) Max(a uint, b uint) uint {
	if a > b {
		return a
	}
	return b
}

// Any returns true if f returns true for any element in arr
func (s SliceUint) Any(f func(el uint) bool) bool {
	for _, el := range s.Data {
		if f(el) {
			return true
		}
	}
	return false
}

// All returns true if f returns true for all elements in arr
func (s SliceUint) All(f func(el uint) bool) bool {
	for _, el := range s.Data {
		if !f(el) {
			return false
		}
	}
	return true
}

// Choice chooses a random element from the slice
func (s SliceUint) Choice() (uint, error) {
	if len(s.Data) == 0 {
		var tmp uint
		return tmp, ErrEmpty
	}

	rand.Seed(time.Now().UnixNano())
	i := rand.Intn(len(s.Data))
	return s.Data[i], nil
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint) ChunkByBool(f func(el uint) bool) [][]uint {
	chunks := make([][]uint, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint) ChunkByByte(f func(el uint) byte) [][]uint {
	chunks := make([][]uint, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint) ChunkByString(f func(el uint) string) [][]uint {
	chunks := make([][]uint, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint) ChunkByFloat32(f func(el uint) float32) [][]uint {
	chunks := make([][]uint, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint) ChunkByFloat64(f func(el uint) float64) [][]uint {
	chunks := make([][]uint, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint) ChunkByInt(f func(el uint) int) [][]uint {
	chunks := make([][]uint, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint) ChunkByInt8(f func(el uint) int8) [][]uint {
	chunks := make([][]uint, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint) ChunkByInt16(f func(el uint) int16) [][]uint {
	chunks := make([][]uint, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint) ChunkByInt32(f func(el uint) int32) [][]uint {
	chunks := make([][]uint, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint) ChunkByInt64(f func(el uint) int64) [][]uint {
	chunks := make([][]uint, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint) ChunkByUint(f func(el uint) uint) [][]uint {
	chunks := make([][]uint, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint) ChunkByUint8(f func(el uint) uint8) [][]uint {
	chunks := make([][]uint, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint) ChunkByUint16(f func(el uint) uint16) [][]uint {
	chunks := make([][]uint, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint) ChunkByUint32(f func(el uint) uint32) [][]uint {
	chunks := make([][]uint, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint) ChunkByUint64(f func(el uint) uint64) [][]uint {
	chunks := make([][]uint, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint) ChunkByInterface(f func(el uint) interface{}) [][]uint {
	chunks := make([][]uint, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkEvery returns slice of slices containing count elements each
func (s SliceUint) ChunkEvery(count int) ([][]uint, error) {
	chunks := make([][]uint, 0)
	if count <= 0 {
		return chunks, ErrNegativeValue
	}
	chunk := make([]uint, 0, count)
	for i, el := range s.Data {
		chunk = append(chunk, el)
		if (i+1)%count == 0 {
			chunks = append(chunks, chunk)
			chunk = make([]uint, 0, count)
		}
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks, nil
}

// Contains returns true if el in arr.
func (s SliceUint) Contains(el uint) bool {
	for _, val := range s.Data {
		if val == el {
			return true
		}
	}
	return false
}

// Count return count of el occurences in arr.
func (s SliceUint) Count(el uint) int {
	count := 0
	for _, val := range s.Data {
		if val == el {
			count++
		}
	}
	return count
}

// CountBy returns how many times f returns true.
func (s SliceUint) CountBy(f func(el uint) bool) int {
	count := 0
	for _, el := range s.Data {
		if f(el) {
			count++
		}
	}
	return count
}

// Cycle is an infinite loop over slice
func (s SliceUint) Cycle() chan uint {
	c := make(chan uint, 1)
	go func() {
		defer close(c)
		if len(s.Data) == 0 {
			return
		}
		for {
			for _, val := range s.Data {
				c <- val
			}
		}
	}()
	return c
}

// Dedup returns a given slice without consecutive duplicated elements
func (s SliceUint) Dedup() []uint {
	if len(s.Data) == 0 {
		return s.Data
	}

	result := make([]uint, 0, len(s.Data))
	prev := s.Data[0]
	result = append(result, prev)
	for _, el := range s.Data[1:] {
		if el != prev {
			result = append(result, el)
			prev = el
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint) DedupByBool(f func(el uint) bool) []uint {
	result := make([]uint, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint) DedupByByte(f func(el uint) byte) []uint {
	result := make([]uint, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint) DedupByString(f func(el uint) string) []uint {
	result := make([]uint, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint) DedupByFloat32(f func(el uint) float32) []uint {
	result := make([]uint, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint) DedupByFloat64(f func(el uint) float64) []uint {
	result := make([]uint, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint) DedupByInt(f func(el uint) int) []uint {
	result := make([]uint, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint) DedupByInt8(f func(el uint) int8) []uint {
	result := make([]uint, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint) DedupByInt16(f func(el uint) int16) []uint {
	result := make([]uint, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint) DedupByInt32(f func(el uint) int32) []uint {
	result := make([]uint, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint) DedupByInt64(f func(el uint) int64) []uint {
	result := make([]uint, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint) DedupByUint(f func(el uint) uint) []uint {
	result := make([]uint, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint) DedupByUint8(f func(el uint) uint8) []uint {
	result := make([]uint, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint) DedupByUint16(f func(el uint) uint16) []uint {
	result := make([]uint, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint) DedupByUint32(f func(el uint) uint32) []uint {
	result := make([]uint, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint) DedupByUint64(f func(el uint) uint64) []uint {
	result := make([]uint, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint) DedupByInterface(f func(el uint) interface{}) []uint {
	result := make([]uint, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// Delete deletes the first occurence of the element from the slice
func (s SliceUint) Delete(element uint) []uint {
	result := make([]uint, 0, len(s.Data)-1)
	deleted := false
	for _, el := range s.Data {
		if !deleted && el == element {
			continue
		}
		result = append(result, el)
	}
	return result

}

// DeleteAt returns the slice without elements on given positions
func (s SliceUint) DeleteAt(index int) ([]uint, error) {
	if index >= len(s.Data) {
		return s.Data, ErrOutOfRange
	}

	result := make([]uint, 0, len(s.Data)-1)
	for i, el := range s.Data {
		if i != index {
			result = append(result, el)
		}
	}
	return result, nil
}

// DropEvery returns a slice of every nth element in the enumerable dropped,
// starting with the first element.
func (s SliceUint) DropEvery(nth int) ([]uint, error) {
	if nth <= 0 {
		return s.Data, ErrNonPositiveValue
	}
	result := make([]uint, 0, len(s.Data)/nth)
	for i, el := range s.Data {
		if (i+1)%nth != 0 {
			result = append(result, el)
		}
	}
	return result, nil
}

// DropWhile drops elements from arr while f returns true
func (s SliceUint) DropWhile(f func(arr uint) bool) []uint {
	result := make([]uint, 0, len(s.Data))
	for _, el := range s.Data {
		if !f(el) {
			return result
		}
		result = append(result, el)
	}
	return result
}

// Each calls f for every element from arr
func (s SliceUint) Each(f func(el uint)) {
	for _, el := range s.Data {
		f(el)
	}
}

// Equal returns true if slices are equal
func (s SliceUint) Equal(other []uint) bool {
	if len(s.Data) != len(other) {
		return false
	}
	for i, el := range other {
		if s.Data[i] != el {
			return false
		}
	}
	return true
}

// Filter returns slice of T for which F returned true
func (s SliceUint) Filter(f func(el uint) bool) []uint {
	result := make([]uint, 0, len(s.Data))
	for _, el := range s.Data {
		if f(el) {
			result = append(result, el)
		}
	}
	return result
}

// Find returns the first element for which f returns true
func (s SliceUint) Find(f func(el uint) bool) (uint, error) {
	for _, el := range s.Data {
		if f(el) {
			return el, nil
		}
	}
	var tmp uint
	return tmp, ErrNotFound
}

// FindIndex is like Find, but return element index instead of element itself
func (s SliceUint) FindIndex(f func(el uint) bool) (int, error) {
	for i, el := range s.Data {
		if f(el) {
			return i, nil
		}
	}
	return 0, ErrNotFound
}

// Join concatenates elements of the slice to create a single string.
func (s SliceUint) Join(sep string) string {
	strs := make([]string, 0, len(s.Data))
	for _, el := range s.Data {
		strs = append(strs, string(el))
	}
	return strings.Join(strs, sep)
}

// GroupBy groups element from array by value returned by f
func (s SliceUint) GroupByBool(f func(el uint) bool) map[bool][]uint {
	result := make(map[bool][]uint)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint) GroupByByte(f func(el uint) byte) map[byte][]uint {
	result := make(map[byte][]uint)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint) GroupByString(f func(el uint) string) map[string][]uint {
	result := make(map[string][]uint)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint) GroupByFloat32(f func(el uint) float32) map[float32][]uint {
	result := make(map[float32][]uint)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint) GroupByFloat64(f func(el uint) float64) map[float64][]uint {
	result := make(map[float64][]uint)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint) GroupByInt(f func(el uint) int) map[int][]uint {
	result := make(map[int][]uint)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint) GroupByInt8(f func(el uint) int8) map[int8][]uint {
	result := make(map[int8][]uint)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint) GroupByInt16(f func(el uint) int16) map[int16][]uint {
	result := make(map[int16][]uint)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint) GroupByInt32(f func(el uint) int32) map[int32][]uint {
	result := make(map[int32][]uint)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint) GroupByInt64(f func(el uint) int64) map[int64][]uint {
	result := make(map[int64][]uint)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint) GroupByUint(f func(el uint) uint) map[uint][]uint {
	result := make(map[uint][]uint)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint) GroupByUint8(f func(el uint) uint8) map[uint8][]uint {
	result := make(map[uint8][]uint)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint) GroupByUint16(f func(el uint) uint16) map[uint16][]uint {
	result := make(map[uint16][]uint)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint) GroupByUint32(f func(el uint) uint32) map[uint32][]uint {
	result := make(map[uint32][]uint)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint) GroupByUint64(f func(el uint) uint64) map[uint64][]uint {
	result := make(map[uint64][]uint)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint) GroupByInterface(f func(el uint) interface{}) map[interface{}][]uint {
	result := make(map[interface{}][]uint)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// InsertAt returns the slice with element inserted at given index.
func (s SliceUint) InsertAt(index int, element uint) ([]uint, error) {
	result := make([]uint, 0, len(s.Data)+1)

	// insert at the end
	if index == len(s.Data) || index == -1 {
		result = append(result, s.Data...)
		result = append(result, element)
		return result, nil
	}

	if index > len(s.Data) {
		return s.Data, ErrOutOfRange
	}
	if index < 0 {
		return s.Data, ErrNegativeValue
	}

	for i, el := range s.Data {
		if i == index {
			result = append(result, element)
		}
		result = append(result, el)
	}
	return result, nil
}

// Intersperse inserts el between each element of arr
func (s SliceUint) Intersperse(el uint) []uint {
	if len(s.Data) == 0 {
		return s.Data
	}
	result := make([]uint, 0, len(s.Data)*2-1)
	result = append(result, s.Data[0])
	for _, val := range s.Data[1:] {
		result = append(result, el, val)
	}
	return result
}

// Last returns the last element from the slice
func (s SliceUint) Last() (uint, error) {
	if len(s.Data) == 0 {
		var tmp uint
		return tmp, ErrEmpty
	}
	return s.Data[len(s.Data)-1], nil
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint) MapBool(f func(el uint) bool) []bool {
	result := make([]bool, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint) MapByte(f func(el uint) byte) []byte {
	result := make([]byte, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint) MapString(f func(el uint) string) []string {
	result := make([]string, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint) MapFloat32(f func(el uint) float32) []float32 {
	result := make([]float32, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint) MapFloat64(f func(el uint) float64) []float64 {
	result := make([]float64, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint) MapInt(f func(el uint) int) []int {
	result := make([]int, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint) MapInt8(f func(el uint) int8) []int8 {
	result := make([]int8, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint) MapInt16(f func(el uint) int16) []int16 {
	result := make([]int16, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint) MapInt32(f func(el uint) int32) []int32 {
	result := make([]int32, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint) MapInt64(f func(el uint) int64) []int64 {
	result := make([]int64, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint) MapUint(f func(el uint) uint) []uint {
	result := make([]uint, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint) MapUint8(f func(el uint) uint8) []uint8 {
	result := make([]uint8, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint) MapUint16(f func(el uint) uint16) []uint16 {
	result := make([]uint16, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint) MapUint32(f func(el uint) uint32) []uint32 {
	result := make([]uint32, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint) MapUint64(f func(el uint) uint64) []uint64 {
	result := make([]uint64, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint) MapInterface(f func(el uint) interface{}) []interface{} {
	result := make([]interface{}, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Max returns the maximal element from arr
func (s SliceUint) Max() (uint, error) {
	if len(s.Data) == 0 {
		var tmp uint
		return tmp, ErrEmpty
	}

	max := s.Data[0]
	for _, el := range s.Data[1:] {
		if el > max {
			max = el
		}
	}
	return max, nil
}

// Min returns the minimal element from arr
func (s SliceUint) Min() (uint, error) {
	if len(s.Data) == 0 {
		var tmp uint
		return tmp, ErrEmpty
	}

	min := s.Data[0]
	for _, el := range s.Data[1:] {
		if el < min {
			min = el
		}
	}
	return min, nil
}

// Permutations returns successive size-length permutations of elements from the slice.
// {1, 2, 3} -> {1, 2}, {1, 3}, {2, 1}, {2, 3}, {3, 1}, {3, 2}
func (s SliceUint) Permutations(size int) chan []uint {
	c := make(chan []uint, 1)
	go func() {
		if len(s.Data) > 0 {
			s.permutations(c, size, []uint{}, s.Data)
		}
		close(c)
	}()
	return c
}

// permutations is a core implementation for Permutations
func (s SliceUint) permutations(c chan []uint, size int, left []uint, right []uint) {
	if len(left) == size || len(right) == 0 {
		c <- left
		return
	}

	for i, el := range right {
		newLeft := make([]uint, 0, len(left)+1)
		newLeft = append(newLeft, left...)
		newLeft = append(newLeft, el)

		newRight := make([]uint, 0, len(right)-1)
		for j, other := range right {
			if j != i {
				newRight = append(newRight, other)
			}
		}
		s.permutations(c, size, newLeft, newRight)
	}
}

// Product returns cortesian product of elements
// {{1, 2}, {3, 4}} -> {1, 3}, {1, 4}, {2, 3}, {2, 4}
func (s SliceUint) Product(repeat int) chan []uint {
	c := make(chan []uint, 1)
	go s.product(c, repeat, []uint{}, 0)
	return c
}

// product is a core implementation for Product
func (s SliceUint) product(c chan []uint, repeat int, left []uint, pos int) {
	// iterate over the last array
	if pos == repeat-1 {
		for _, el := range s.Data {
			result := make([]uint, 0, len(left)+1)
			result = append(result, left...)
			result = append(result, el)
			c <- result
		}
		return
	}

	for _, el := range s.Data {
		result := make([]uint, 0, len(left)+1)
		result = append(result, left...)
		result = append(result, el)
		s.product(c, repeat, result, pos+1)
	}

	if pos == 0 {
		close(c)
	}
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint) ReduceBool(acc bool, f func(el uint, acc bool) bool) bool {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint) ReduceByte(acc byte, f func(el uint, acc byte) byte) byte {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint) ReduceString(acc string, f func(el uint, acc string) string) string {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint) ReduceFloat32(acc float32, f func(el uint, acc float32) float32) float32 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint) ReduceFloat64(acc float64, f func(el uint, acc float64) float64) float64 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint) ReduceInt(acc int, f func(el uint, acc int) int) int {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint) ReduceInt8(acc int8, f func(el uint, acc int8) int8) int8 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint) ReduceInt16(acc int16, f func(el uint, acc int16) int16) int16 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint) ReduceInt32(acc int32, f func(el uint, acc int32) int32) int32 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint) ReduceInt64(acc int64, f func(el uint, acc int64) int64) int64 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint) ReduceUint(acc uint, f func(el uint, acc uint) uint) uint {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint) ReduceUint8(acc uint8, f func(el uint, acc uint8) uint8) uint8 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint) ReduceUint16(acc uint16, f func(el uint, acc uint16) uint16) uint16 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint) ReduceUint32(acc uint32, f func(el uint, acc uint32) uint32) uint32 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint) ReduceUint64(acc uint64, f func(el uint, acc uint64) uint64) uint64 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint) ReduceInterface(acc interface{}, f func(el uint, acc interface{}) interface{}) interface{} {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint) ReduceWhileBool(acc bool, f func(el uint, acc bool) (bool, error)) (bool, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint) ReduceWhileByte(acc byte, f func(el uint, acc byte) (byte, error)) (byte, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint) ReduceWhileString(acc string, f func(el uint, acc string) (string, error)) (string, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint) ReduceWhileFloat32(acc float32, f func(el uint, acc float32) (float32, error)) (float32, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint) ReduceWhileFloat64(acc float64, f func(el uint, acc float64) (float64, error)) (float64, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint) ReduceWhileInt(acc int, f func(el uint, acc int) (int, error)) (int, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint) ReduceWhileInt8(acc int8, f func(el uint, acc int8) (int8, error)) (int8, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint) ReduceWhileInt16(acc int16, f func(el uint, acc int16) (int16, error)) (int16, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint) ReduceWhileInt32(acc int32, f func(el uint, acc int32) (int32, error)) (int32, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint) ReduceWhileInt64(acc int64, f func(el uint, acc int64) (int64, error)) (int64, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint) ReduceWhileUint(acc uint, f func(el uint, acc uint) (uint, error)) (uint, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint) ReduceWhileUint8(acc uint8, f func(el uint, acc uint8) (uint8, error)) (uint8, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint) ReduceWhileUint16(acc uint16, f func(el uint, acc uint16) (uint16, error)) (uint16, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint) ReduceWhileUint32(acc uint32, f func(el uint, acc uint32) (uint32, error)) (uint32, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint) ReduceWhileUint64(acc uint64, f func(el uint, acc uint64) (uint64, error)) (uint64, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint) ReduceWhileInterface(acc interface{}, f func(el uint, acc interface{}) (interface{}, error)) (interface{}, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// Reverse returns given arr in reversed order
func (s SliceUint) Reverse() []uint {
	if len(s.Data) <= 1 {
		return s.Data
	}
	result := make([]uint, 0, len(s.Data))
	for i := len(s.Data) - 1; i >= 0; i-- {
		result = append(result, s.Data[i])
	}
	return result
}

// Same returns true if all element in arr the same
func (s SliceUint) Same() bool {
	if len(s.Data) <= 1 {
		return true
	}
	for i := 0; i < len(s.Data)-1; i++ {
		if s.Data[i] != s.Data[i+1] {
			return false
		}
	}
	return true
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint) ScanBool(acc bool, f func(el uint, acc bool) bool) []bool {
	result := make([]bool, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint) ScanByte(acc byte, f func(el uint, acc byte) byte) []byte {
	result := make([]byte, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint) ScanString(acc string, f func(el uint, acc string) string) []string {
	result := make([]string, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint) ScanFloat32(acc float32, f func(el uint, acc float32) float32) []float32 {
	result := make([]float32, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint) ScanFloat64(acc float64, f func(el uint, acc float64) float64) []float64 {
	result := make([]float64, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint) ScanInt(acc int, f func(el uint, acc int) int) []int {
	result := make([]int, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint) ScanInt8(acc int8, f func(el uint, acc int8) int8) []int8 {
	result := make([]int8, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint) ScanInt16(acc int16, f func(el uint, acc int16) int16) []int16 {
	result := make([]int16, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint) ScanInt32(acc int32, f func(el uint, acc int32) int32) []int32 {
	result := make([]int32, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint) ScanInt64(acc int64, f func(el uint, acc int64) int64) []int64 {
	result := make([]int64, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint) ScanUint(acc uint, f func(el uint, acc uint) uint) []uint {
	result := make([]uint, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint) ScanUint8(acc uint8, f func(el uint, acc uint8) uint8) []uint8 {
	result := make([]uint8, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint) ScanUint16(acc uint16, f func(el uint, acc uint16) uint16) []uint16 {
	result := make([]uint16, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint) ScanUint32(acc uint32, f func(el uint, acc uint32) uint32) []uint32 {
	result := make([]uint32, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint) ScanUint64(acc uint64, f func(el uint, acc uint64) uint64) []uint64 {
	result := make([]uint64, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint) ScanInterface(acc interface{}, f func(el uint, acc interface{}) interface{}) []interface{} {
	result := make([]interface{}, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Shuffle in random order arr elements
func (s SliceUint) Shuffle() []uint {
	if len(s.Data) <= 1 {
		return s.Data
	}
	rand.Seed(time.Now().UnixNano())
	swap := func(i, j int) {
		s.Data[i], s.Data[j] = s.Data[j], s.Data[i]
	}
	rand.Shuffle(len(s.Data), swap)
	return s.Data
}

// Sort returns sorted slice
func (s SliceUint) Sort() []uint {
	if len(s.Data) <= 1 {
		return s.Data
	}
	less := func(i int, j int) bool {
		return s.Data[i] < s.Data[j]
	}
	sort.SliceStable(s.Data, less)
	return s.Data
}

// Sorted returns true if slice is sorted
func (s SliceUint) Sorted() bool {
	if len(s.Data) <= 1 {
		return true
	}
	for i := 1; i < len(s.Data); i++ {
		if s.Data[i-1] > s.Data[i] {
			return false
		}
	}
	return true
}

// Split splits arr by sep
func (s SliceUint) Split(sep uint) [][]uint {
	result := make([][]uint, 0)
	curr := make([]uint, 0)
	for _, el := range s.Data {
		if el == sep {
			result = append(result, curr)
		} else {
			curr = append(curr, el)
		}
	}
	result = append(result, curr)
	return result
}

// StartsWith returns true if slice starts with the given prefix slice.
// If prefix is empty, it returns true.
func (s SliceUint) StartsWith(prefix []uint) bool {
	if len(prefix) > len(s.Data) {
		return false
	}
	for i, el := range prefix {
		if el != s.Data[i] {
			return false
		}
	}
	return true
}

// Sum return sum of all elements from arr
func (s SliceUint) Sum() uint {
	var sum uint
	for _, el := range s.Data {
		sum += el
	}
	return sum
}

// TakeEvery returns slice of every nth elements
func (s SliceUint) TakeEvery(nth int) ([]uint, error) {
	if nth <= 0 {
		return s.Data, ErrNonPositiveValue
	}
	result := make([]uint, 0, len(s.Data))
	for i, el := range s.Data {
		if (i+1)%nth == 0 {
			result = append(result, el)
		}
	}
	return result, nil
}

// TakeRandom returns slice of count random elements from the slice
func (s SliceUint) TakeRandom(count int) ([]uint, error) {
	if count > len(s.Data) {
		return nil, ErrOutOfRange
	}
	if count <= 0 {
		return nil, ErrNonPositiveValue
	}

	rand.Seed(time.Now().UnixNano())
	swap := func(i, j int) {
		s.Data[i], s.Data[j] = s.Data[j], s.Data[i]
	}
	rand.Shuffle(len(s.Data), swap)
	return s.Data[:count], nil
}

// TakeWhile takes elements from arr while f returns true
func (s SliceUint) TakeWhile(f func(el uint) bool) []uint {
	result := make([]uint, 0, len(s.Data))
	for _, el := range s.Data {
		if !f(el) {
			return result
		}
		result = append(result, el)
	}
	return result
}

// ToChannel returns channel with elements from the slice
func (s SliceUint) ToChannel() chan uint {
	c := make(chan uint, 1)
	go func() {
		for _, el := range s.Data {
			c <- el
		}
		close(c)
	}()
	return c
}

// Uniq returns arr with only first occurences of every element.
func (s SliceUint) Uniq() []uint {
	if len(s.Data) <= 1 {
		return s.Data
	}
	added := make(map[uint]struct{})
	nothing := struct{}{}
	result := make([]uint, 0, len(s.Data))
	for _, el := range s.Data {
		_, exists := added[el]
		if !exists {
			result = append(result, el)
			added[el] = nothing
		}
	}
	return result

}

// Window makes sliding window for a given slice:
// ({1,2,3}, 2) -> (1,2), (2,3)
func (s SliceUint) Window(size int) ([][]uint, error) {
	if size <= 0 {
		return nil, ErrNonPositiveValue
	}
	result := make([][]uint, 0, len(s.Data)/size)
	for i := 0; i <= len(s.Data)-size; i++ {
		chunk := s.Data[i : i+size]
		result = append(result, chunk)
	}
	return result, nil
}

// Without returns the slice with filtered out element
func (s SliceUint) Without(elements ...uint) []uint {
	result := make([]uint, 0, len(s.Data))
	for _, el := range s.Data {
		allowed := true
		for _, other := range elements {
			if el == other {
				allowed = false
			}
		}
		if allowed {
			result = append(result, el)
		}
	}
	return result
}

// Concat concatenates given slices into a single slice.
func (s SlicesUint) Concat() []uint {
	result := make([]uint, 0)
	for _, arr := range s.Data {
		result = append(result, arr...)
	}
	return result
}

// Product returns cortesian product of elements
// {{1, 2}, {3, 4}} -> {1, 3}, {1, 4}, {2, 3}, {2, 4}
func (s SlicesUint) Product() chan []uint {
	c := make(chan []uint, 1)
	go s.product(c, []uint{}, 0)
	return c
}

// product is a core implementation of Product
func (s SlicesUint) product(c chan []uint, left []uint, pos int) {
	// iterate over the last array
	if pos == len(s.Data)-1 {
		for _, el := range s.Data[pos] {
			result := make([]uint, 0, len(left)+1)
			result = append(result, left...)
			result = append(result, el)
			c <- result
		}
		return
	}

	for _, el := range s.Data[pos] {
		result := make([]uint, 0, len(left)+1)
		result = append(result, left...)
		result = append(result, el)
		s.product(c, result, pos+1)
	}

	if pos == 0 {
		close(c)
	}
}

// Zip returns array of arrays of elements from given arrs
// on the same position
func (s SlicesUint) Zip() [][]uint {
	size := len(s.Data[0])
	for _, arr := range s.Data[1:] {
		if len(arr) > size {
			size = len(arr)
		}
	}

	result := make([][]uint, 0, size)
	for i := 0; i <= size; i++ {
		chunk := make([]uint, 0, len(s.Data))
		for _, arr := range s.Data {
			chunk = append(chunk, arr[i])
		}
		result = append(result, chunk)
	}
	return result
}

// Channel is a set of operations with channel
type ChannelUint8 struct {
	Data chan uint8
}

// AsyncSlice is a set of operations to work with slice asynchronously
type AsyncSliceUint8 struct {
	Data    []uint8
	Workers int
}

// Sequence is a set of operations to generate sequences
type SequenceUint8 struct {
	ctx context.Context
}

// Pair is a set of functions for 2 values that you can pass into reduce-like funcs
type PairUint8 struct {
	// empty
}

// Slice is a set of operations to work with slice
type SliceUint8 struct {
	Data []uint8
}

// Slices is a set of operations to work with slice of slices
type SlicesUint8 struct {
	Data [][]uint8
}

// Any returns true if f returns true for any element in channel
func (c ChannelUint8) Any(f func(el uint8) bool) bool {
	for el := range c.Data {
		if f(el) {
			return true
		}
	}
	return false
}

// All returns true if f returns true for all elements in channel
func (c ChannelUint8) All(f func(el uint8) bool) bool {
	for el := range c.Data {
		if !f(el) {
			return false
		}
	}
	return true
}

// ChunkEvery returns channel with slices containing count elements each
func (c ChannelUint8) ChunkEvery(count int) chan []uint8 {
	chunks := make(chan []uint8, 1)
	go func() {
		chunk := make([]uint8, 0, count)
		i := 0
		for el := range c.Data {
			chunk = append(chunk, el)
			i++
			if i%count == 0 {
				i = 0
				chunks <- chunk
				chunk = make([]uint8, 0, count)
			}
		}
		if len(chunk) > 0 {
			chunks <- chunk
		}
		close(chunks)
	}()
	return chunks
}

// Count return count of el occurences in channel.
func (c ChannelUint8) Count(el uint8) int {
	count := 0
	for val := range c.Data {
		if val == el {
			count++
		}
	}
	return count
}

// Drop drops first n elements from channel c and returns a new channel with the rest.
// It returns channel do be unblocking. If you want array instead, wrap result into TakeAll.
func (c ChannelUint8) Drop(n int) chan uint8 {
	result := make(chan uint8, 1)
	go func() {
		i := 0
		for el := range c.Data {
			if i >= n {
				result <- el
			}
			i++
		}
		close(result)
	}()
	return result
}

// Each calls f for every element in the channel
func (c ChannelUint8) Each(f func(el uint8)) {
	for el := range c.Data {
		f(el)
	}
}

// Filter returns a new channel with elements from input channel
// for which f returns true
func (c ChannelUint8) Filter(f func(el uint8) bool) chan uint8 {
	result := make(chan uint8, 1)
	go func() {
		for el := range c.Data {
			if f(el) {
				result <- el
			}
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint8) MapBool(f func(el uint8) bool) chan bool {
	result := make(chan bool, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint8) MapByte(f func(el uint8) byte) chan byte {
	result := make(chan byte, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint8) MapString(f func(el uint8) string) chan string {
	result := make(chan string, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint8) MapFloat32(f func(el uint8) float32) chan float32 {
	result := make(chan float32, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint8) MapFloat64(f func(el uint8) float64) chan float64 {
	result := make(chan float64, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint8) MapInt(f func(el uint8) int) chan int {
	result := make(chan int, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint8) MapInt8(f func(el uint8) int8) chan int8 {
	result := make(chan int8, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint8) MapInt16(f func(el uint8) int16) chan int16 {
	result := make(chan int16, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint8) MapInt32(f func(el uint8) int32) chan int32 {
	result := make(chan int32, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint8) MapInt64(f func(el uint8) int64) chan int64 {
	result := make(chan int64, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint8) MapUint(f func(el uint8) uint) chan uint {
	result := make(chan uint, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint8) MapUint8(f func(el uint8) uint8) chan uint8 {
	result := make(chan uint8, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint8) MapUint16(f func(el uint8) uint16) chan uint16 {
	result := make(chan uint16, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint8) MapUint32(f func(el uint8) uint32) chan uint32 {
	result := make(chan uint32, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint8) MapUint64(f func(el uint8) uint64) chan uint64 {
	result := make(chan uint64, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint8) MapInterface(f func(el uint8) interface{}) chan interface{} {
	result := make(chan interface{}, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Max returns the maximal element from channel
func (c ChannelUint8) Max() (uint8, error) {
	max, ok := <-c.Data
	if !ok {
		return max, ErrEmpty
	}
	for el := range c.Data {
		if el > max {
			max = el
		}
	}
	return max, nil
}

// Min returns the minimal element from channel
func (c ChannelUint8) Min() (uint8, error) {
	min, ok := <-c.Data
	if !ok {
		return min, ErrEmpty
	}
	for el := range c.Data {
		if el < min {
			min = el
		}
	}
	return min, nil
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint8) ReduceBool(acc bool, f func(el uint8, acc bool) bool) bool {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint8) ReduceByte(acc byte, f func(el uint8, acc byte) byte) byte {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint8) ReduceString(acc string, f func(el uint8, acc string) string) string {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint8) ReduceFloat32(acc float32, f func(el uint8, acc float32) float32) float32 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint8) ReduceFloat64(acc float64, f func(el uint8, acc float64) float64) float64 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint8) ReduceInt(acc int, f func(el uint8, acc int) int) int {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint8) ReduceInt8(acc int8, f func(el uint8, acc int8) int8) int8 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint8) ReduceInt16(acc int16, f func(el uint8, acc int16) int16) int16 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint8) ReduceInt32(acc int32, f func(el uint8, acc int32) int32) int32 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint8) ReduceInt64(acc int64, f func(el uint8, acc int64) int64) int64 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint8) ReduceUint(acc uint, f func(el uint8, acc uint) uint) uint {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint8) ReduceUint8(acc uint8, f func(el uint8, acc uint8) uint8) uint8 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint8) ReduceUint16(acc uint16, f func(el uint8, acc uint16) uint16) uint16 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint8) ReduceUint32(acc uint32, f func(el uint8, acc uint32) uint32) uint32 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint8) ReduceUint64(acc uint64, f func(el uint8, acc uint64) uint64) uint64 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint8) ReduceInterface(acc interface{}, f func(el uint8, acc interface{}) interface{}) interface{} {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint8) ScanBool(acc bool, f func(el uint8, acc bool) bool) chan bool {
	result := make(chan bool, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint8) ScanByte(acc byte, f func(el uint8, acc byte) byte) chan byte {
	result := make(chan byte, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint8) ScanString(acc string, f func(el uint8, acc string) string) chan string {
	result := make(chan string, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint8) ScanFloat32(acc float32, f func(el uint8, acc float32) float32) chan float32 {
	result := make(chan float32, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint8) ScanFloat64(acc float64, f func(el uint8, acc float64) float64) chan float64 {
	result := make(chan float64, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint8) ScanInt(acc int, f func(el uint8, acc int) int) chan int {
	result := make(chan int, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint8) ScanInt8(acc int8, f func(el uint8, acc int8) int8) chan int8 {
	result := make(chan int8, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint8) ScanInt16(acc int16, f func(el uint8, acc int16) int16) chan int16 {
	result := make(chan int16, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint8) ScanInt32(acc int32, f func(el uint8, acc int32) int32) chan int32 {
	result := make(chan int32, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint8) ScanInt64(acc int64, f func(el uint8, acc int64) int64) chan int64 {
	result := make(chan int64, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint8) ScanUint(acc uint, f func(el uint8, acc uint) uint) chan uint {
	result := make(chan uint, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint8) ScanUint8(acc uint8, f func(el uint8, acc uint8) uint8) chan uint8 {
	result := make(chan uint8, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint8) ScanUint16(acc uint16, f func(el uint8, acc uint16) uint16) chan uint16 {
	result := make(chan uint16, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint8) ScanUint32(acc uint32, f func(el uint8, acc uint32) uint32) chan uint32 {
	result := make(chan uint32, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint8) ScanUint64(acc uint64, f func(el uint8, acc uint64) uint64) chan uint64 {
	result := make(chan uint64, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint8) ScanInterface(acc interface{}, f func(el uint8, acc interface{}) interface{}) chan interface{} {
	result := make(chan interface{}, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Sum returns sum of all elements from channel
func (c ChannelUint8) Sum() uint8 {
	var sum uint8
	for el := range c.Data {
		sum += el
	}
	return sum
}

// Take takes first count elements from the channel.
func (c ChannelUint8) Take(count int) chan uint8 {
	result := make(chan uint8, 1)
	go func() {
		defer close(result)
		if count <= 0 {
			return
		}
		i := 0
		for el := range c.Data {
			result <- el
			i++
			if i == count {
				return
			}
		}
	}()
	return result
}

// Tee returns 2 channels with elements from the input channel
func (c ChannelUint8) Tee(count int) []chan uint8 {
	channels := make([]chan uint8, 0, count)
	for i := 0; i < count; i++ {
		channels = append(channels, make(chan uint8, 1))
	}
	go func() {
		for el := range c.Data {
			wg := sync.WaitGroup{}
			putInto := func(ch chan uint8) {
				defer wg.Done()
				ch <- el
			}
			wg.Add(count)
			for _, ch := range channels {
				putInto(ch)
			}
			wg.Wait()
		}
		for _, ch := range channels {
			close(ch)
		}
	}()
	return channels
}

// ToSlice returns slice with all elements from channel.
func (c ChannelUint8) ToSlice() []uint8 {
	result := make([]uint8, 0)
	for val := range c.Data {
		result = append(result, val)
	}
	return result
}

// All returns true if f returns true for all elements in slice
func (s AsyncSliceUint8) All(f func(el uint8) bool) bool {
	if len(s.Data) == 0 {
		return true
	}

	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int, result chan<- bool, ctx context.Context) {
		defer wg.Done()
		for {
			select {
			case <-ctx.Done():
				return
			case index, ok := <-jobs:
				if !ok {
					return
				}
				if !f(s.Data[index]) {
					result <- false
					return
				}
			}
		}
	}

	ctx, cancel := context.WithCancel(context.Background())
	// when we're returning the result, cancel all workers
	defer cancel()

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	result := make(chan bool, workers)
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs, result, ctx)
	}

	// close the result channel when all workers have done
	go func() {
		wg.Wait()
		close(result)
	}()

	// schedule the jobs: indices to check
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)

	for range result {
		return false
	}
	return true
}

// Any returns true if f returns true for any element from slice
func (s AsyncSliceUint8) Any(f func(el uint8) bool) bool {
	if len(s.Data) == 0 {
		return false
	}

	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int, result chan<- bool, ctx context.Context) {
		defer wg.Done()
		for {
			select {
			case <-ctx.Done():
				return
			case index, ok := <-jobs:
				if !ok {
					return
				}
				if f(s.Data[index]) {
					result <- true
					return
				}
			}
		}
	}

	ctx, cancel := context.WithCancel(context.Background())
	// when we're returning the result, cancel all workers
	defer cancel()

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	result := make(chan bool, workers)
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs, result, ctx)
	}

	// close the result channel when all workers have done
	go func() {
		wg.Wait()
		close(result)
	}()

	// schedule the jobs: indices to check
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)

	for range result {
		return true
	}
	return false
}

// Each calls f for every element from slice
func (s AsyncSliceUint8) Each(f func(el uint8)) {
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		defer wg.Done()
		for index := range jobs {
			f(s.Data[index])
		}
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
}

// Filter returns slice of element for which f returns true
func (s AsyncSliceUint8) Filter(f func(el uint8) bool) []uint8 {
	resultMap := make([]bool, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			if f(s.Data[index]) {
				resultMap[index] = true
			}
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()

	// return filtered results
	result := make([]uint8, 0, len(s.Data))
	for i, el := range s.Data {
		if resultMap[i] {
			result = append(result, el)
		}
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint8) MapBool(f func(el uint8) bool) []bool {
	result := make([]bool, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint8) MapByte(f func(el uint8) byte) []byte {
	result := make([]byte, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint8) MapString(f func(el uint8) string) []string {
	result := make([]string, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint8) MapFloat32(f func(el uint8) float32) []float32 {
	result := make([]float32, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint8) MapFloat64(f func(el uint8) float64) []float64 {
	result := make([]float64, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint8) MapInt(f func(el uint8) int) []int {
	result := make([]int, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint8) MapInt8(f func(el uint8) int8) []int8 {
	result := make([]int8, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint8) MapInt16(f func(el uint8) int16) []int16 {
	result := make([]int16, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint8) MapInt32(f func(el uint8) int32) []int32 {
	result := make([]int32, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint8) MapInt64(f func(el uint8) int64) []int64 {
	result := make([]int64, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint8) MapUint(f func(el uint8) uint) []uint {
	result := make([]uint, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint8) MapUint8(f func(el uint8) uint8) []uint8 {
	result := make([]uint8, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint8) MapUint16(f func(el uint8) uint16) []uint16 {
	result := make([]uint16, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint8) MapUint32(f func(el uint8) uint32) []uint32 {
	result := make([]uint32, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint8) MapUint64(f func(el uint8) uint64) []uint64 {
	result := make([]uint64, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint8) MapInterface(f func(el uint8) interface{}) []interface{} {
	result := make([]interface{}, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Reduce reduces slice to a single value with f
func (s AsyncSliceUint8) Reduce(f func(left uint8, right uint8) uint8) uint8 {
	if len(s.Data) == 0 {
		var tmp uint8
		return tmp
	}

	state := make([]uint8, len(s.Data))
	state = append(state, s.Data...)
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int, result chan<- uint8) {
		for index := range jobs {
			result <- f(state[index], state[index+1])
		}
		wg.Done()
	}

	for len(state) > 1 {
		// calculate workers count
		workers := s.Workers
		if workers == 0 || workers > len(state) {
			workers = len(state)
		}

		// run workers
		jobs := make(chan int, len(state))
		wg.Add(workers)
		result := make(chan uint8, 1)
		for i := 0; i < workers; i++ {
			go worker(jobs, result)
		}

		go func() {
			wg.Wait()
			close(result)
		}()

		// add indices into jobs for workers
		for i := 0; i < len(state)-1; i += 2 {
			jobs <- i
		}
		close(jobs)

		// collect new state
		newState := make([]uint8, 0, len(state)/2+len(state)%2)
		for el := range result {
			newState = append(newState, el)
		}
		if len(state)%2 == 1 {
			newState = append(newState, state[len(state)-1])
		}
		// put new state as current state after all
		state = newState
	}

	return state[0]
}

// Count is like Range, but infinite
func (s SequenceUint8) Count(start uint8, step uint8) chan uint8 {
	c := make(chan uint8, 1)
	go func() {
		defer close(c)
		for {
			select {
			case <-s.ctx.Done():
				return
			case c <- start:
				start += step
			}
		}
	}()
	return c
}

// Exponential generates elements from start with
// multiplication of value on factor on every step
func (s SequenceUint8) Exponential(start uint8, factor uint8) chan uint8 {
	c := make(chan uint8, 1)
	go func() {
		defer close(c)
		for {
			select {
			case <-s.ctx.Done():
				return
			case c <- start:
				start *= factor
			}
		}
	}()
	return c
}

// Iterate returns an infinite list of repeated applications of f to val
func (s SequenceUint8) Iterate(val uint8, f func(val uint8) uint8) chan uint8 {
	c := make(chan uint8, 1)
	go func() {
		defer close(c)
		for {
			select {
			case <-s.ctx.Done():
				return
			case c <- val:
				val = f(val)
			}
		}
	}()
	return c
}

// Range generates elements from start to end with given step
func (s SequenceUint8) Range(start uint8, end uint8, step uint8) chan uint8 {
	c := make(chan uint8, 1)
	pos := start <= end
	go func() {
		for pos && (start < end) || !pos && (start > end) {
			c <- start
			start += step
		}
		close(c)
	}()
	return c
}

// Repeat returns channel that produces val infinite times
func (s SequenceUint8) Repeat(val uint8) chan uint8 {
	c := make(chan uint8, 1)
	go func() {
		defer close(c)
		for {
			select {
			case <-s.ctx.Done():
				return
			case c <- val:
				continue
			}
		}
	}()
	return c
}

// Replicate returns channel that produces val n times
func (s SequenceUint8) Replicate(val uint8, n int) chan uint8 {
	c := make(chan uint8, 1)
	go func() {
		for i := 0; i < n; i++ {
			c <- val
		}
		close(c)
	}()
	return c
}

// Min returns minimal value
func (PairUint8) Min(a uint8, b uint8) uint8 {
	if a <= b {
		return a
	}
	return b
}

// Max returns maximal value
func (PairUint8) Max(a uint8, b uint8) uint8 {
	if a > b {
		return a
	}
	return b
}

// Any returns true if f returns true for any element in arr
func (s SliceUint8) Any(f func(el uint8) bool) bool {
	for _, el := range s.Data {
		if f(el) {
			return true
		}
	}
	return false
}

// All returns true if f returns true for all elements in arr
func (s SliceUint8) All(f func(el uint8) bool) bool {
	for _, el := range s.Data {
		if !f(el) {
			return false
		}
	}
	return true
}

// Choice chooses a random element from the slice
func (s SliceUint8) Choice() (uint8, error) {
	if len(s.Data) == 0 {
		var tmp uint8
		return tmp, ErrEmpty
	}

	rand.Seed(time.Now().UnixNano())
	i := rand.Intn(len(s.Data))
	return s.Data[i], nil
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint8) ChunkByBool(f func(el uint8) bool) [][]uint8 {
	chunks := make([][]uint8, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint8, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint8, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint8) ChunkByByte(f func(el uint8) byte) [][]uint8 {
	chunks := make([][]uint8, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint8, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint8, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint8) ChunkByString(f func(el uint8) string) [][]uint8 {
	chunks := make([][]uint8, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint8, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint8, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint8) ChunkByFloat32(f func(el uint8) float32) [][]uint8 {
	chunks := make([][]uint8, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint8, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint8, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint8) ChunkByFloat64(f func(el uint8) float64) [][]uint8 {
	chunks := make([][]uint8, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint8, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint8, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint8) ChunkByInt(f func(el uint8) int) [][]uint8 {
	chunks := make([][]uint8, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint8, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint8, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint8) ChunkByInt8(f func(el uint8) int8) [][]uint8 {
	chunks := make([][]uint8, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint8, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint8, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint8) ChunkByInt16(f func(el uint8) int16) [][]uint8 {
	chunks := make([][]uint8, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint8, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint8, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint8) ChunkByInt32(f func(el uint8) int32) [][]uint8 {
	chunks := make([][]uint8, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint8, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint8, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint8) ChunkByInt64(f func(el uint8) int64) [][]uint8 {
	chunks := make([][]uint8, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint8, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint8, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint8) ChunkByUint(f func(el uint8) uint) [][]uint8 {
	chunks := make([][]uint8, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint8, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint8, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint8) ChunkByUint8(f func(el uint8) uint8) [][]uint8 {
	chunks := make([][]uint8, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint8, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint8, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint8) ChunkByUint16(f func(el uint8) uint16) [][]uint8 {
	chunks := make([][]uint8, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint8, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint8, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint8) ChunkByUint32(f func(el uint8) uint32) [][]uint8 {
	chunks := make([][]uint8, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint8, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint8, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint8) ChunkByUint64(f func(el uint8) uint64) [][]uint8 {
	chunks := make([][]uint8, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint8, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint8, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint8) ChunkByInterface(f func(el uint8) interface{}) [][]uint8 {
	chunks := make([][]uint8, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint8, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint8, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkEvery returns slice of slices containing count elements each
func (s SliceUint8) ChunkEvery(count int) ([][]uint8, error) {
	chunks := make([][]uint8, 0)
	if count <= 0 {
		return chunks, ErrNegativeValue
	}
	chunk := make([]uint8, 0, count)
	for i, el := range s.Data {
		chunk = append(chunk, el)
		if (i+1)%count == 0 {
			chunks = append(chunks, chunk)
			chunk = make([]uint8, 0, count)
		}
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks, nil
}

// Contains returns true if el in arr.
func (s SliceUint8) Contains(el uint8) bool {
	for _, val := range s.Data {
		if val == el {
			return true
		}
	}
	return false
}

// Count return count of el occurences in arr.
func (s SliceUint8) Count(el uint8) int {
	count := 0
	for _, val := range s.Data {
		if val == el {
			count++
		}
	}
	return count
}

// CountBy returns how many times f returns true.
func (s SliceUint8) CountBy(f func(el uint8) bool) int {
	count := 0
	for _, el := range s.Data {
		if f(el) {
			count++
		}
	}
	return count
}

// Cycle is an infinite loop over slice
func (s SliceUint8) Cycle() chan uint8 {
	c := make(chan uint8, 1)
	go func() {
		defer close(c)
		if len(s.Data) == 0 {
			return
		}
		for {
			for _, val := range s.Data {
				c <- val
			}
		}
	}()
	return c
}

// Dedup returns a given slice without consecutive duplicated elements
func (s SliceUint8) Dedup() []uint8 {
	if len(s.Data) == 0 {
		return s.Data
	}

	result := make([]uint8, 0, len(s.Data))
	prev := s.Data[0]
	result = append(result, prev)
	for _, el := range s.Data[1:] {
		if el != prev {
			result = append(result, el)
			prev = el
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint8) DedupByBool(f func(el uint8) bool) []uint8 {
	result := make([]uint8, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint8) DedupByByte(f func(el uint8) byte) []uint8 {
	result := make([]uint8, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint8) DedupByString(f func(el uint8) string) []uint8 {
	result := make([]uint8, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint8) DedupByFloat32(f func(el uint8) float32) []uint8 {
	result := make([]uint8, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint8) DedupByFloat64(f func(el uint8) float64) []uint8 {
	result := make([]uint8, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint8) DedupByInt(f func(el uint8) int) []uint8 {
	result := make([]uint8, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint8) DedupByInt8(f func(el uint8) int8) []uint8 {
	result := make([]uint8, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint8) DedupByInt16(f func(el uint8) int16) []uint8 {
	result := make([]uint8, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint8) DedupByInt32(f func(el uint8) int32) []uint8 {
	result := make([]uint8, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint8) DedupByInt64(f func(el uint8) int64) []uint8 {
	result := make([]uint8, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint8) DedupByUint(f func(el uint8) uint) []uint8 {
	result := make([]uint8, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint8) DedupByUint8(f func(el uint8) uint8) []uint8 {
	result := make([]uint8, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint8) DedupByUint16(f func(el uint8) uint16) []uint8 {
	result := make([]uint8, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint8) DedupByUint32(f func(el uint8) uint32) []uint8 {
	result := make([]uint8, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint8) DedupByUint64(f func(el uint8) uint64) []uint8 {
	result := make([]uint8, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint8) DedupByInterface(f func(el uint8) interface{}) []uint8 {
	result := make([]uint8, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// Delete deletes the first occurence of the element from the slice
func (s SliceUint8) Delete(element uint8) []uint8 {
	result := make([]uint8, 0, len(s.Data)-1)
	deleted := false
	for _, el := range s.Data {
		if !deleted && el == element {
			continue
		}
		result = append(result, el)
	}
	return result

}

// DeleteAt returns the slice without elements on given positions
func (s SliceUint8) DeleteAt(index int) ([]uint8, error) {
	if index >= len(s.Data) {
		return s.Data, ErrOutOfRange
	}

	result := make([]uint8, 0, len(s.Data)-1)
	for i, el := range s.Data {
		if i != index {
			result = append(result, el)
		}
	}
	return result, nil
}

// DropEvery returns a slice of every nth element in the enumerable dropped,
// starting with the first element.
func (s SliceUint8) DropEvery(nth int) ([]uint8, error) {
	if nth <= 0 {
		return s.Data, ErrNonPositiveValue
	}
	result := make([]uint8, 0, len(s.Data)/nth)
	for i, el := range s.Data {
		if (i+1)%nth != 0 {
			result = append(result, el)
		}
	}
	return result, nil
}

// DropWhile drops elements from arr while f returns true
func (s SliceUint8) DropWhile(f func(arr uint8) bool) []uint8 {
	result := make([]uint8, 0, len(s.Data))
	for _, el := range s.Data {
		if !f(el) {
			return result
		}
		result = append(result, el)
	}
	return result
}

// Each calls f for every element from arr
func (s SliceUint8) Each(f func(el uint8)) {
	for _, el := range s.Data {
		f(el)
	}
}

// Equal returns true if slices are equal
func (s SliceUint8) Equal(other []uint8) bool {
	if len(s.Data) != len(other) {
		return false
	}
	for i, el := range other {
		if s.Data[i] != el {
			return false
		}
	}
	return true
}

// Filter returns slice of T for which F returned true
func (s SliceUint8) Filter(f func(el uint8) bool) []uint8 {
	result := make([]uint8, 0, len(s.Data))
	for _, el := range s.Data {
		if f(el) {
			result = append(result, el)
		}
	}
	return result
}

// Find returns the first element for which f returns true
func (s SliceUint8) Find(f func(el uint8) bool) (uint8, error) {
	for _, el := range s.Data {
		if f(el) {
			return el, nil
		}
	}
	var tmp uint8
	return tmp, ErrNotFound
}

// FindIndex is like Find, but return element index instead of element itself
func (s SliceUint8) FindIndex(f func(el uint8) bool) (int, error) {
	for i, el := range s.Data {
		if f(el) {
			return i, nil
		}
	}
	return 0, ErrNotFound
}

// Join concatenates elements of the slice to create a single string.
func (s SliceUint8) Join(sep string) string {
	strs := make([]string, 0, len(s.Data))
	for _, el := range s.Data {
		strs = append(strs, string(el))
	}
	return strings.Join(strs, sep)
}

// GroupBy groups element from array by value returned by f
func (s SliceUint8) GroupByBool(f func(el uint8) bool) map[bool][]uint8 {
	result := make(map[bool][]uint8)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint8, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint8) GroupByByte(f func(el uint8) byte) map[byte][]uint8 {
	result := make(map[byte][]uint8)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint8, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint8) GroupByString(f func(el uint8) string) map[string][]uint8 {
	result := make(map[string][]uint8)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint8, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint8) GroupByFloat32(f func(el uint8) float32) map[float32][]uint8 {
	result := make(map[float32][]uint8)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint8, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint8) GroupByFloat64(f func(el uint8) float64) map[float64][]uint8 {
	result := make(map[float64][]uint8)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint8, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint8) GroupByInt(f func(el uint8) int) map[int][]uint8 {
	result := make(map[int][]uint8)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint8, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint8) GroupByInt8(f func(el uint8) int8) map[int8][]uint8 {
	result := make(map[int8][]uint8)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint8, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint8) GroupByInt16(f func(el uint8) int16) map[int16][]uint8 {
	result := make(map[int16][]uint8)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint8, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint8) GroupByInt32(f func(el uint8) int32) map[int32][]uint8 {
	result := make(map[int32][]uint8)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint8, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint8) GroupByInt64(f func(el uint8) int64) map[int64][]uint8 {
	result := make(map[int64][]uint8)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint8, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint8) GroupByUint(f func(el uint8) uint) map[uint][]uint8 {
	result := make(map[uint][]uint8)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint8, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint8) GroupByUint8(f func(el uint8) uint8) map[uint8][]uint8 {
	result := make(map[uint8][]uint8)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint8, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint8) GroupByUint16(f func(el uint8) uint16) map[uint16][]uint8 {
	result := make(map[uint16][]uint8)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint8, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint8) GroupByUint32(f func(el uint8) uint32) map[uint32][]uint8 {
	result := make(map[uint32][]uint8)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint8, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint8) GroupByUint64(f func(el uint8) uint64) map[uint64][]uint8 {
	result := make(map[uint64][]uint8)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint8, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint8) GroupByInterface(f func(el uint8) interface{}) map[interface{}][]uint8 {
	result := make(map[interface{}][]uint8)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint8, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// InsertAt returns the slice with element inserted at given index.
func (s SliceUint8) InsertAt(index int, element uint8) ([]uint8, error) {
	result := make([]uint8, 0, len(s.Data)+1)

	// insert at the end
	if index == len(s.Data) || index == -1 {
		result = append(result, s.Data...)
		result = append(result, element)
		return result, nil
	}

	if index > len(s.Data) {
		return s.Data, ErrOutOfRange
	}
	if index < 0 {
		return s.Data, ErrNegativeValue
	}

	for i, el := range s.Data {
		if i == index {
			result = append(result, element)
		}
		result = append(result, el)
	}
	return result, nil
}

// Intersperse inserts el between each element of arr
func (s SliceUint8) Intersperse(el uint8) []uint8 {
	if len(s.Data) == 0 {
		return s.Data
	}
	result := make([]uint8, 0, len(s.Data)*2-1)
	result = append(result, s.Data[0])
	for _, val := range s.Data[1:] {
		result = append(result, el, val)
	}
	return result
}

// Last returns the last element from the slice
func (s SliceUint8) Last() (uint8, error) {
	if len(s.Data) == 0 {
		var tmp uint8
		return tmp, ErrEmpty
	}
	return s.Data[len(s.Data)-1], nil
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint8) MapBool(f func(el uint8) bool) []bool {
	result := make([]bool, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint8) MapByte(f func(el uint8) byte) []byte {
	result := make([]byte, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint8) MapString(f func(el uint8) string) []string {
	result := make([]string, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint8) MapFloat32(f func(el uint8) float32) []float32 {
	result := make([]float32, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint8) MapFloat64(f func(el uint8) float64) []float64 {
	result := make([]float64, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint8) MapInt(f func(el uint8) int) []int {
	result := make([]int, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint8) MapInt8(f func(el uint8) int8) []int8 {
	result := make([]int8, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint8) MapInt16(f func(el uint8) int16) []int16 {
	result := make([]int16, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint8) MapInt32(f func(el uint8) int32) []int32 {
	result := make([]int32, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint8) MapInt64(f func(el uint8) int64) []int64 {
	result := make([]int64, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint8) MapUint(f func(el uint8) uint) []uint {
	result := make([]uint, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint8) MapUint8(f func(el uint8) uint8) []uint8 {
	result := make([]uint8, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint8) MapUint16(f func(el uint8) uint16) []uint16 {
	result := make([]uint16, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint8) MapUint32(f func(el uint8) uint32) []uint32 {
	result := make([]uint32, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint8) MapUint64(f func(el uint8) uint64) []uint64 {
	result := make([]uint64, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint8) MapInterface(f func(el uint8) interface{}) []interface{} {
	result := make([]interface{}, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Max returns the maximal element from arr
func (s SliceUint8) Max() (uint8, error) {
	if len(s.Data) == 0 {
		var tmp uint8
		return tmp, ErrEmpty
	}

	max := s.Data[0]
	for _, el := range s.Data[1:] {
		if el > max {
			max = el
		}
	}
	return max, nil
}

// Min returns the minimal element from arr
func (s SliceUint8) Min() (uint8, error) {
	if len(s.Data) == 0 {
		var tmp uint8
		return tmp, ErrEmpty
	}

	min := s.Data[0]
	for _, el := range s.Data[1:] {
		if el < min {
			min = el
		}
	}
	return min, nil
}

// Permutations returns successive size-length permutations of elements from the slice.
// {1, 2, 3} -> {1, 2}, {1, 3}, {2, 1}, {2, 3}, {3, 1}, {3, 2}
func (s SliceUint8) Permutations(size int) chan []uint8 {
	c := make(chan []uint8, 1)
	go func() {
		if len(s.Data) > 0 {
			s.permutations(c, size, []uint8{}, s.Data)
		}
		close(c)
	}()
	return c
}

// permutations is a core implementation for Permutations
func (s SliceUint8) permutations(c chan []uint8, size int, left []uint8, right []uint8) {
	if len(left) == size || len(right) == 0 {
		c <- left
		return
	}

	for i, el := range right {
		newLeft := make([]uint8, 0, len(left)+1)
		newLeft = append(newLeft, left...)
		newLeft = append(newLeft, el)

		newRight := make([]uint8, 0, len(right)-1)
		for j, other := range right {
			if j != i {
				newRight = append(newRight, other)
			}
		}
		s.permutations(c, size, newLeft, newRight)
	}
}

// Product returns cortesian product of elements
// {{1, 2}, {3, 4}} -> {1, 3}, {1, 4}, {2, 3}, {2, 4}
func (s SliceUint8) Product(repeat int) chan []uint8 {
	c := make(chan []uint8, 1)
	go s.product(c, repeat, []uint8{}, 0)
	return c
}

// product is a core implementation for Product
func (s SliceUint8) product(c chan []uint8, repeat int, left []uint8, pos int) {
	// iterate over the last array
	if pos == repeat-1 {
		for _, el := range s.Data {
			result := make([]uint8, 0, len(left)+1)
			result = append(result, left...)
			result = append(result, el)
			c <- result
		}
		return
	}

	for _, el := range s.Data {
		result := make([]uint8, 0, len(left)+1)
		result = append(result, left...)
		result = append(result, el)
		s.product(c, repeat, result, pos+1)
	}

	if pos == 0 {
		close(c)
	}
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint8) ReduceBool(acc bool, f func(el uint8, acc bool) bool) bool {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint8) ReduceByte(acc byte, f func(el uint8, acc byte) byte) byte {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint8) ReduceString(acc string, f func(el uint8, acc string) string) string {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint8) ReduceFloat32(acc float32, f func(el uint8, acc float32) float32) float32 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint8) ReduceFloat64(acc float64, f func(el uint8, acc float64) float64) float64 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint8) ReduceInt(acc int, f func(el uint8, acc int) int) int {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint8) ReduceInt8(acc int8, f func(el uint8, acc int8) int8) int8 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint8) ReduceInt16(acc int16, f func(el uint8, acc int16) int16) int16 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint8) ReduceInt32(acc int32, f func(el uint8, acc int32) int32) int32 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint8) ReduceInt64(acc int64, f func(el uint8, acc int64) int64) int64 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint8) ReduceUint(acc uint, f func(el uint8, acc uint) uint) uint {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint8) ReduceUint8(acc uint8, f func(el uint8, acc uint8) uint8) uint8 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint8) ReduceUint16(acc uint16, f func(el uint8, acc uint16) uint16) uint16 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint8) ReduceUint32(acc uint32, f func(el uint8, acc uint32) uint32) uint32 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint8) ReduceUint64(acc uint64, f func(el uint8, acc uint64) uint64) uint64 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint8) ReduceInterface(acc interface{}, f func(el uint8, acc interface{}) interface{}) interface{} {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint8) ReduceWhileBool(acc bool, f func(el uint8, acc bool) (bool, error)) (bool, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint8) ReduceWhileByte(acc byte, f func(el uint8, acc byte) (byte, error)) (byte, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint8) ReduceWhileString(acc string, f func(el uint8, acc string) (string, error)) (string, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint8) ReduceWhileFloat32(acc float32, f func(el uint8, acc float32) (float32, error)) (float32, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint8) ReduceWhileFloat64(acc float64, f func(el uint8, acc float64) (float64, error)) (float64, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint8) ReduceWhileInt(acc int, f func(el uint8, acc int) (int, error)) (int, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint8) ReduceWhileInt8(acc int8, f func(el uint8, acc int8) (int8, error)) (int8, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint8) ReduceWhileInt16(acc int16, f func(el uint8, acc int16) (int16, error)) (int16, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint8) ReduceWhileInt32(acc int32, f func(el uint8, acc int32) (int32, error)) (int32, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint8) ReduceWhileInt64(acc int64, f func(el uint8, acc int64) (int64, error)) (int64, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint8) ReduceWhileUint(acc uint, f func(el uint8, acc uint) (uint, error)) (uint, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint8) ReduceWhileUint8(acc uint8, f func(el uint8, acc uint8) (uint8, error)) (uint8, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint8) ReduceWhileUint16(acc uint16, f func(el uint8, acc uint16) (uint16, error)) (uint16, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint8) ReduceWhileUint32(acc uint32, f func(el uint8, acc uint32) (uint32, error)) (uint32, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint8) ReduceWhileUint64(acc uint64, f func(el uint8, acc uint64) (uint64, error)) (uint64, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint8) ReduceWhileInterface(acc interface{}, f func(el uint8, acc interface{}) (interface{}, error)) (interface{}, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// Reverse returns given arr in reversed order
func (s SliceUint8) Reverse() []uint8 {
	if len(s.Data) <= 1 {
		return s.Data
	}
	result := make([]uint8, 0, len(s.Data))
	for i := len(s.Data) - 1; i >= 0; i-- {
		result = append(result, s.Data[i])
	}
	return result
}

// Same returns true if all element in arr the same
func (s SliceUint8) Same() bool {
	if len(s.Data) <= 1 {
		return true
	}
	for i := 0; i < len(s.Data)-1; i++ {
		if s.Data[i] != s.Data[i+1] {
			return false
		}
	}
	return true
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint8) ScanBool(acc bool, f func(el uint8, acc bool) bool) []bool {
	result := make([]bool, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint8) ScanByte(acc byte, f func(el uint8, acc byte) byte) []byte {
	result := make([]byte, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint8) ScanString(acc string, f func(el uint8, acc string) string) []string {
	result := make([]string, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint8) ScanFloat32(acc float32, f func(el uint8, acc float32) float32) []float32 {
	result := make([]float32, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint8) ScanFloat64(acc float64, f func(el uint8, acc float64) float64) []float64 {
	result := make([]float64, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint8) ScanInt(acc int, f func(el uint8, acc int) int) []int {
	result := make([]int, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint8) ScanInt8(acc int8, f func(el uint8, acc int8) int8) []int8 {
	result := make([]int8, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint8) ScanInt16(acc int16, f func(el uint8, acc int16) int16) []int16 {
	result := make([]int16, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint8) ScanInt32(acc int32, f func(el uint8, acc int32) int32) []int32 {
	result := make([]int32, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint8) ScanInt64(acc int64, f func(el uint8, acc int64) int64) []int64 {
	result := make([]int64, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint8) ScanUint(acc uint, f func(el uint8, acc uint) uint) []uint {
	result := make([]uint, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint8) ScanUint8(acc uint8, f func(el uint8, acc uint8) uint8) []uint8 {
	result := make([]uint8, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint8) ScanUint16(acc uint16, f func(el uint8, acc uint16) uint16) []uint16 {
	result := make([]uint16, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint8) ScanUint32(acc uint32, f func(el uint8, acc uint32) uint32) []uint32 {
	result := make([]uint32, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint8) ScanUint64(acc uint64, f func(el uint8, acc uint64) uint64) []uint64 {
	result := make([]uint64, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint8) ScanInterface(acc interface{}, f func(el uint8, acc interface{}) interface{}) []interface{} {
	result := make([]interface{}, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Shuffle in random order arr elements
func (s SliceUint8) Shuffle() []uint8 {
	if len(s.Data) <= 1 {
		return s.Data
	}
	rand.Seed(time.Now().UnixNano())
	swap := func(i, j int) {
		s.Data[i], s.Data[j] = s.Data[j], s.Data[i]
	}
	rand.Shuffle(len(s.Data), swap)
	return s.Data
}

// Sort returns sorted slice
func (s SliceUint8) Sort() []uint8 {
	if len(s.Data) <= 1 {
		return s.Data
	}
	less := func(i int, j int) bool {
		return s.Data[i] < s.Data[j]
	}
	sort.SliceStable(s.Data, less)
	return s.Data
}

// Sorted returns true if slice is sorted
func (s SliceUint8) Sorted() bool {
	if len(s.Data) <= 1 {
		return true
	}
	for i := 1; i < len(s.Data); i++ {
		if s.Data[i-1] > s.Data[i] {
			return false
		}
	}
	return true
}

// Split splits arr by sep
func (s SliceUint8) Split(sep uint8) [][]uint8 {
	result := make([][]uint8, 0)
	curr := make([]uint8, 0)
	for _, el := range s.Data {
		if el == sep {
			result = append(result, curr)
		} else {
			curr = append(curr, el)
		}
	}
	result = append(result, curr)
	return result
}

// StartsWith returns true if slice starts with the given prefix slice.
// If prefix is empty, it returns true.
func (s SliceUint8) StartsWith(prefix []uint8) bool {
	if len(prefix) > len(s.Data) {
		return false
	}
	for i, el := range prefix {
		if el != s.Data[i] {
			return false
		}
	}
	return true
}

// Sum return sum of all elements from arr
func (s SliceUint8) Sum() uint8 {
	var sum uint8
	for _, el := range s.Data {
		sum += el
	}
	return sum
}

// TakeEvery returns slice of every nth elements
func (s SliceUint8) TakeEvery(nth int) ([]uint8, error) {
	if nth <= 0 {
		return s.Data, ErrNonPositiveValue
	}
	result := make([]uint8, 0, len(s.Data))
	for i, el := range s.Data {
		if (i+1)%nth == 0 {
			result = append(result, el)
		}
	}
	return result, nil
}

// TakeRandom returns slice of count random elements from the slice
func (s SliceUint8) TakeRandom(count int) ([]uint8, error) {
	if count > len(s.Data) {
		return nil, ErrOutOfRange
	}
	if count <= 0 {
		return nil, ErrNonPositiveValue
	}

	rand.Seed(time.Now().UnixNano())
	swap := func(i, j int) {
		s.Data[i], s.Data[j] = s.Data[j], s.Data[i]
	}
	rand.Shuffle(len(s.Data), swap)
	return s.Data[:count], nil
}

// TakeWhile takes elements from arr while f returns true
func (s SliceUint8) TakeWhile(f func(el uint8) bool) []uint8 {
	result := make([]uint8, 0, len(s.Data))
	for _, el := range s.Data {
		if !f(el) {
			return result
		}
		result = append(result, el)
	}
	return result
}

// ToChannel returns channel with elements from the slice
func (s SliceUint8) ToChannel() chan uint8 {
	c := make(chan uint8, 1)
	go func() {
		for _, el := range s.Data {
			c <- el
		}
		close(c)
	}()
	return c
}

// Uniq returns arr with only first occurences of every element.
func (s SliceUint8) Uniq() []uint8 {
	if len(s.Data) <= 1 {
		return s.Data
	}
	added := make(map[uint8]struct{})
	nothing := struct{}{}
	result := make([]uint8, 0, len(s.Data))
	for _, el := range s.Data {
		_, exists := added[el]
		if !exists {
			result = append(result, el)
			added[el] = nothing
		}
	}
	return result

}

// Window makes sliding window for a given slice:
// ({1,2,3}, 2) -> (1,2), (2,3)
func (s SliceUint8) Window(size int) ([][]uint8, error) {
	if size <= 0 {
		return nil, ErrNonPositiveValue
	}
	result := make([][]uint8, 0, len(s.Data)/size)
	for i := 0; i <= len(s.Data)-size; i++ {
		chunk := s.Data[i : i+size]
		result = append(result, chunk)
	}
	return result, nil
}

// Without returns the slice with filtered out element
func (s SliceUint8) Without(elements ...uint8) []uint8 {
	result := make([]uint8, 0, len(s.Data))
	for _, el := range s.Data {
		allowed := true
		for _, other := range elements {
			if el == other {
				allowed = false
			}
		}
		if allowed {
			result = append(result, el)
		}
	}
	return result
}

// Concat concatenates given slices into a single slice.
func (s SlicesUint8) Concat() []uint8 {
	result := make([]uint8, 0)
	for _, arr := range s.Data {
		result = append(result, arr...)
	}
	return result
}

// Product returns cortesian product of elements
// {{1, 2}, {3, 4}} -> {1, 3}, {1, 4}, {2, 3}, {2, 4}
func (s SlicesUint8) Product() chan []uint8 {
	c := make(chan []uint8, 1)
	go s.product(c, []uint8{}, 0)
	return c
}

// product is a core implementation of Product
func (s SlicesUint8) product(c chan []uint8, left []uint8, pos int) {
	// iterate over the last array
	if pos == len(s.Data)-1 {
		for _, el := range s.Data[pos] {
			result := make([]uint8, 0, len(left)+1)
			result = append(result, left...)
			result = append(result, el)
			c <- result
		}
		return
	}

	for _, el := range s.Data[pos] {
		result := make([]uint8, 0, len(left)+1)
		result = append(result, left...)
		result = append(result, el)
		s.product(c, result, pos+1)
	}

	if pos == 0 {
		close(c)
	}
}

// Zip returns array of arrays of elements from given arrs
// on the same position
func (s SlicesUint8) Zip() [][]uint8 {
	size := len(s.Data[0])
	for _, arr := range s.Data[1:] {
		if len(arr) > size {
			size = len(arr)
		}
	}

	result := make([][]uint8, 0, size)
	for i := 0; i <= size; i++ {
		chunk := make([]uint8, 0, len(s.Data))
		for _, arr := range s.Data {
			chunk = append(chunk, arr[i])
		}
		result = append(result, chunk)
	}
	return result
}

// Channel is a set of operations with channel
type ChannelUint16 struct {
	Data chan uint16
}

// AsyncSlice is a set of operations to work with slice asynchronously
type AsyncSliceUint16 struct {
	Data    []uint16
	Workers int
}

// Sequence is a set of operations to generate sequences
type SequenceUint16 struct {
	ctx context.Context
}

// Pair is a set of functions for 2 values that you can pass into reduce-like funcs
type PairUint16 struct {
	// empty
}

// Slice is a set of operations to work with slice
type SliceUint16 struct {
	Data []uint16
}

// Slices is a set of operations to work with slice of slices
type SlicesUint16 struct {
	Data [][]uint16
}

// Any returns true if f returns true for any element in channel
func (c ChannelUint16) Any(f func(el uint16) bool) bool {
	for el := range c.Data {
		if f(el) {
			return true
		}
	}
	return false
}

// All returns true if f returns true for all elements in channel
func (c ChannelUint16) All(f func(el uint16) bool) bool {
	for el := range c.Data {
		if !f(el) {
			return false
		}
	}
	return true
}

// ChunkEvery returns channel with slices containing count elements each
func (c ChannelUint16) ChunkEvery(count int) chan []uint16 {
	chunks := make(chan []uint16, 1)
	go func() {
		chunk := make([]uint16, 0, count)
		i := 0
		for el := range c.Data {
			chunk = append(chunk, el)
			i++
			if i%count == 0 {
				i = 0
				chunks <- chunk
				chunk = make([]uint16, 0, count)
			}
		}
		if len(chunk) > 0 {
			chunks <- chunk
		}
		close(chunks)
	}()
	return chunks
}

// Count return count of el occurences in channel.
func (c ChannelUint16) Count(el uint16) int {
	count := 0
	for val := range c.Data {
		if val == el {
			count++
		}
	}
	return count
}

// Drop drops first n elements from channel c and returns a new channel with the rest.
// It returns channel do be unblocking. If you want array instead, wrap result into TakeAll.
func (c ChannelUint16) Drop(n int) chan uint16 {
	result := make(chan uint16, 1)
	go func() {
		i := 0
		for el := range c.Data {
			if i >= n {
				result <- el
			}
			i++
		}
		close(result)
	}()
	return result
}

// Each calls f for every element in the channel
func (c ChannelUint16) Each(f func(el uint16)) {
	for el := range c.Data {
		f(el)
	}
}

// Filter returns a new channel with elements from input channel
// for which f returns true
func (c ChannelUint16) Filter(f func(el uint16) bool) chan uint16 {
	result := make(chan uint16, 1)
	go func() {
		for el := range c.Data {
			if f(el) {
				result <- el
			}
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint16) MapBool(f func(el uint16) bool) chan bool {
	result := make(chan bool, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint16) MapByte(f func(el uint16) byte) chan byte {
	result := make(chan byte, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint16) MapString(f func(el uint16) string) chan string {
	result := make(chan string, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint16) MapFloat32(f func(el uint16) float32) chan float32 {
	result := make(chan float32, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint16) MapFloat64(f func(el uint16) float64) chan float64 {
	result := make(chan float64, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint16) MapInt(f func(el uint16) int) chan int {
	result := make(chan int, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint16) MapInt8(f func(el uint16) int8) chan int8 {
	result := make(chan int8, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint16) MapInt16(f func(el uint16) int16) chan int16 {
	result := make(chan int16, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint16) MapInt32(f func(el uint16) int32) chan int32 {
	result := make(chan int32, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint16) MapInt64(f func(el uint16) int64) chan int64 {
	result := make(chan int64, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint16) MapUint(f func(el uint16) uint) chan uint {
	result := make(chan uint, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint16) MapUint8(f func(el uint16) uint8) chan uint8 {
	result := make(chan uint8, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint16) MapUint16(f func(el uint16) uint16) chan uint16 {
	result := make(chan uint16, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint16) MapUint32(f func(el uint16) uint32) chan uint32 {
	result := make(chan uint32, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint16) MapUint64(f func(el uint16) uint64) chan uint64 {
	result := make(chan uint64, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint16) MapInterface(f func(el uint16) interface{}) chan interface{} {
	result := make(chan interface{}, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Max returns the maximal element from channel
func (c ChannelUint16) Max() (uint16, error) {
	max, ok := <-c.Data
	if !ok {
		return max, ErrEmpty
	}
	for el := range c.Data {
		if el > max {
			max = el
		}
	}
	return max, nil
}

// Min returns the minimal element from channel
func (c ChannelUint16) Min() (uint16, error) {
	min, ok := <-c.Data
	if !ok {
		return min, ErrEmpty
	}
	for el := range c.Data {
		if el < min {
			min = el
		}
	}
	return min, nil
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint16) ReduceBool(acc bool, f func(el uint16, acc bool) bool) bool {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint16) ReduceByte(acc byte, f func(el uint16, acc byte) byte) byte {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint16) ReduceString(acc string, f func(el uint16, acc string) string) string {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint16) ReduceFloat32(acc float32, f func(el uint16, acc float32) float32) float32 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint16) ReduceFloat64(acc float64, f func(el uint16, acc float64) float64) float64 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint16) ReduceInt(acc int, f func(el uint16, acc int) int) int {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint16) ReduceInt8(acc int8, f func(el uint16, acc int8) int8) int8 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint16) ReduceInt16(acc int16, f func(el uint16, acc int16) int16) int16 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint16) ReduceInt32(acc int32, f func(el uint16, acc int32) int32) int32 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint16) ReduceInt64(acc int64, f func(el uint16, acc int64) int64) int64 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint16) ReduceUint(acc uint, f func(el uint16, acc uint) uint) uint {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint16) ReduceUint8(acc uint8, f func(el uint16, acc uint8) uint8) uint8 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint16) ReduceUint16(acc uint16, f func(el uint16, acc uint16) uint16) uint16 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint16) ReduceUint32(acc uint32, f func(el uint16, acc uint32) uint32) uint32 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint16) ReduceUint64(acc uint64, f func(el uint16, acc uint64) uint64) uint64 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint16) ReduceInterface(acc interface{}, f func(el uint16, acc interface{}) interface{}) interface{} {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint16) ScanBool(acc bool, f func(el uint16, acc bool) bool) chan bool {
	result := make(chan bool, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint16) ScanByte(acc byte, f func(el uint16, acc byte) byte) chan byte {
	result := make(chan byte, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint16) ScanString(acc string, f func(el uint16, acc string) string) chan string {
	result := make(chan string, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint16) ScanFloat32(acc float32, f func(el uint16, acc float32) float32) chan float32 {
	result := make(chan float32, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint16) ScanFloat64(acc float64, f func(el uint16, acc float64) float64) chan float64 {
	result := make(chan float64, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint16) ScanInt(acc int, f func(el uint16, acc int) int) chan int {
	result := make(chan int, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint16) ScanInt8(acc int8, f func(el uint16, acc int8) int8) chan int8 {
	result := make(chan int8, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint16) ScanInt16(acc int16, f func(el uint16, acc int16) int16) chan int16 {
	result := make(chan int16, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint16) ScanInt32(acc int32, f func(el uint16, acc int32) int32) chan int32 {
	result := make(chan int32, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint16) ScanInt64(acc int64, f func(el uint16, acc int64) int64) chan int64 {
	result := make(chan int64, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint16) ScanUint(acc uint, f func(el uint16, acc uint) uint) chan uint {
	result := make(chan uint, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint16) ScanUint8(acc uint8, f func(el uint16, acc uint8) uint8) chan uint8 {
	result := make(chan uint8, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint16) ScanUint16(acc uint16, f func(el uint16, acc uint16) uint16) chan uint16 {
	result := make(chan uint16, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint16) ScanUint32(acc uint32, f func(el uint16, acc uint32) uint32) chan uint32 {
	result := make(chan uint32, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint16) ScanUint64(acc uint64, f func(el uint16, acc uint64) uint64) chan uint64 {
	result := make(chan uint64, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint16) ScanInterface(acc interface{}, f func(el uint16, acc interface{}) interface{}) chan interface{} {
	result := make(chan interface{}, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Sum returns sum of all elements from channel
func (c ChannelUint16) Sum() uint16 {
	var sum uint16
	for el := range c.Data {
		sum += el
	}
	return sum
}

// Take takes first count elements from the channel.
func (c ChannelUint16) Take(count int) chan uint16 {
	result := make(chan uint16, 1)
	go func() {
		defer close(result)
		if count <= 0 {
			return
		}
		i := 0
		for el := range c.Data {
			result <- el
			i++
			if i == count {
				return
			}
		}
	}()
	return result
}

// Tee returns 2 channels with elements from the input channel
func (c ChannelUint16) Tee(count int) []chan uint16 {
	channels := make([]chan uint16, 0, count)
	for i := 0; i < count; i++ {
		channels = append(channels, make(chan uint16, 1))
	}
	go func() {
		for el := range c.Data {
			wg := sync.WaitGroup{}
			putInto := func(ch chan uint16) {
				defer wg.Done()
				ch <- el
			}
			wg.Add(count)
			for _, ch := range channels {
				putInto(ch)
			}
			wg.Wait()
		}
		for _, ch := range channels {
			close(ch)
		}
	}()
	return channels
}

// ToSlice returns slice with all elements from channel.
func (c ChannelUint16) ToSlice() []uint16 {
	result := make([]uint16, 0)
	for val := range c.Data {
		result = append(result, val)
	}
	return result
}

// All returns true if f returns true for all elements in slice
func (s AsyncSliceUint16) All(f func(el uint16) bool) bool {
	if len(s.Data) == 0 {
		return true
	}

	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int, result chan<- bool, ctx context.Context) {
		defer wg.Done()
		for {
			select {
			case <-ctx.Done():
				return
			case index, ok := <-jobs:
				if !ok {
					return
				}
				if !f(s.Data[index]) {
					result <- false
					return
				}
			}
		}
	}

	ctx, cancel := context.WithCancel(context.Background())
	// when we're returning the result, cancel all workers
	defer cancel()

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	result := make(chan bool, workers)
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs, result, ctx)
	}

	// close the result channel when all workers have done
	go func() {
		wg.Wait()
		close(result)
	}()

	// schedule the jobs: indices to check
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)

	for range result {
		return false
	}
	return true
}

// Any returns true if f returns true for any element from slice
func (s AsyncSliceUint16) Any(f func(el uint16) bool) bool {
	if len(s.Data) == 0 {
		return false
	}

	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int, result chan<- bool, ctx context.Context) {
		defer wg.Done()
		for {
			select {
			case <-ctx.Done():
				return
			case index, ok := <-jobs:
				if !ok {
					return
				}
				if f(s.Data[index]) {
					result <- true
					return
				}
			}
		}
	}

	ctx, cancel := context.WithCancel(context.Background())
	// when we're returning the result, cancel all workers
	defer cancel()

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	result := make(chan bool, workers)
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs, result, ctx)
	}

	// close the result channel when all workers have done
	go func() {
		wg.Wait()
		close(result)
	}()

	// schedule the jobs: indices to check
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)

	for range result {
		return true
	}
	return false
}

// Each calls f for every element from slice
func (s AsyncSliceUint16) Each(f func(el uint16)) {
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		defer wg.Done()
		for index := range jobs {
			f(s.Data[index])
		}
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
}

// Filter returns slice of element for which f returns true
func (s AsyncSliceUint16) Filter(f func(el uint16) bool) []uint16 {
	resultMap := make([]bool, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			if f(s.Data[index]) {
				resultMap[index] = true
			}
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()

	// return filtered results
	result := make([]uint16, 0, len(s.Data))
	for i, el := range s.Data {
		if resultMap[i] {
			result = append(result, el)
		}
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint16) MapBool(f func(el uint16) bool) []bool {
	result := make([]bool, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint16) MapByte(f func(el uint16) byte) []byte {
	result := make([]byte, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint16) MapString(f func(el uint16) string) []string {
	result := make([]string, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint16) MapFloat32(f func(el uint16) float32) []float32 {
	result := make([]float32, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint16) MapFloat64(f func(el uint16) float64) []float64 {
	result := make([]float64, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint16) MapInt(f func(el uint16) int) []int {
	result := make([]int, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint16) MapInt8(f func(el uint16) int8) []int8 {
	result := make([]int8, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint16) MapInt16(f func(el uint16) int16) []int16 {
	result := make([]int16, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint16) MapInt32(f func(el uint16) int32) []int32 {
	result := make([]int32, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint16) MapInt64(f func(el uint16) int64) []int64 {
	result := make([]int64, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint16) MapUint(f func(el uint16) uint) []uint {
	result := make([]uint, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint16) MapUint8(f func(el uint16) uint8) []uint8 {
	result := make([]uint8, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint16) MapUint16(f func(el uint16) uint16) []uint16 {
	result := make([]uint16, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint16) MapUint32(f func(el uint16) uint32) []uint32 {
	result := make([]uint32, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint16) MapUint64(f func(el uint16) uint64) []uint64 {
	result := make([]uint64, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint16) MapInterface(f func(el uint16) interface{}) []interface{} {
	result := make([]interface{}, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Reduce reduces slice to a single value with f
func (s AsyncSliceUint16) Reduce(f func(left uint16, right uint16) uint16) uint16 {
	if len(s.Data) == 0 {
		var tmp uint16
		return tmp
	}

	state := make([]uint16, len(s.Data))
	state = append(state, s.Data...)
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int, result chan<- uint16) {
		for index := range jobs {
			result <- f(state[index], state[index+1])
		}
		wg.Done()
	}

	for len(state) > 1 {
		// calculate workers count
		workers := s.Workers
		if workers == 0 || workers > len(state) {
			workers = len(state)
		}

		// run workers
		jobs := make(chan int, len(state))
		wg.Add(workers)
		result := make(chan uint16, 1)
		for i := 0; i < workers; i++ {
			go worker(jobs, result)
		}

		go func() {
			wg.Wait()
			close(result)
		}()

		// add indices into jobs for workers
		for i := 0; i < len(state)-1; i += 2 {
			jobs <- i
		}
		close(jobs)

		// collect new state
		newState := make([]uint16, 0, len(state)/2+len(state)%2)
		for el := range result {
			newState = append(newState, el)
		}
		if len(state)%2 == 1 {
			newState = append(newState, state[len(state)-1])
		}
		// put new state as current state after all
		state = newState
	}

	return state[0]
}

// Count is like Range, but infinite
func (s SequenceUint16) Count(start uint16, step uint16) chan uint16 {
	c := make(chan uint16, 1)
	go func() {
		defer close(c)
		for {
			select {
			case <-s.ctx.Done():
				return
			case c <- start:
				start += step
			}
		}
	}()
	return c
}

// Exponential generates elements from start with
// multiplication of value on factor on every step
func (s SequenceUint16) Exponential(start uint16, factor uint16) chan uint16 {
	c := make(chan uint16, 1)
	go func() {
		defer close(c)
		for {
			select {
			case <-s.ctx.Done():
				return
			case c <- start:
				start *= factor
			}
		}
	}()
	return c
}

// Iterate returns an infinite list of repeated applications of f to val
func (s SequenceUint16) Iterate(val uint16, f func(val uint16) uint16) chan uint16 {
	c := make(chan uint16, 1)
	go func() {
		defer close(c)
		for {
			select {
			case <-s.ctx.Done():
				return
			case c <- val:
				val = f(val)
			}
		}
	}()
	return c
}

// Range generates elements from start to end with given step
func (s SequenceUint16) Range(start uint16, end uint16, step uint16) chan uint16 {
	c := make(chan uint16, 1)
	pos := start <= end
	go func() {
		for pos && (start < end) || !pos && (start > end) {
			c <- start
			start += step
		}
		close(c)
	}()
	return c
}

// Repeat returns channel that produces val infinite times
func (s SequenceUint16) Repeat(val uint16) chan uint16 {
	c := make(chan uint16, 1)
	go func() {
		defer close(c)
		for {
			select {
			case <-s.ctx.Done():
				return
			case c <- val:
				continue
			}
		}
	}()
	return c
}

// Replicate returns channel that produces val n times
func (s SequenceUint16) Replicate(val uint16, n int) chan uint16 {
	c := make(chan uint16, 1)
	go func() {
		for i := 0; i < n; i++ {
			c <- val
		}
		close(c)
	}()
	return c
}

// Min returns minimal value
func (PairUint16) Min(a uint16, b uint16) uint16 {
	if a <= b {
		return a
	}
	return b
}

// Max returns maximal value
func (PairUint16) Max(a uint16, b uint16) uint16 {
	if a > b {
		return a
	}
	return b
}

// Any returns true if f returns true for any element in arr
func (s SliceUint16) Any(f func(el uint16) bool) bool {
	for _, el := range s.Data {
		if f(el) {
			return true
		}
	}
	return false
}

// All returns true if f returns true for all elements in arr
func (s SliceUint16) All(f func(el uint16) bool) bool {
	for _, el := range s.Data {
		if !f(el) {
			return false
		}
	}
	return true
}

// Choice chooses a random element from the slice
func (s SliceUint16) Choice() (uint16, error) {
	if len(s.Data) == 0 {
		var tmp uint16
		return tmp, ErrEmpty
	}

	rand.Seed(time.Now().UnixNano())
	i := rand.Intn(len(s.Data))
	return s.Data[i], nil
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint16) ChunkByBool(f func(el uint16) bool) [][]uint16 {
	chunks := make([][]uint16, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint16, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint16, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint16) ChunkByByte(f func(el uint16) byte) [][]uint16 {
	chunks := make([][]uint16, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint16, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint16, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint16) ChunkByString(f func(el uint16) string) [][]uint16 {
	chunks := make([][]uint16, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint16, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint16, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint16) ChunkByFloat32(f func(el uint16) float32) [][]uint16 {
	chunks := make([][]uint16, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint16, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint16, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint16) ChunkByFloat64(f func(el uint16) float64) [][]uint16 {
	chunks := make([][]uint16, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint16, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint16, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint16) ChunkByInt(f func(el uint16) int) [][]uint16 {
	chunks := make([][]uint16, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint16, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint16, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint16) ChunkByInt8(f func(el uint16) int8) [][]uint16 {
	chunks := make([][]uint16, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint16, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint16, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint16) ChunkByInt16(f func(el uint16) int16) [][]uint16 {
	chunks := make([][]uint16, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint16, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint16, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint16) ChunkByInt32(f func(el uint16) int32) [][]uint16 {
	chunks := make([][]uint16, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint16, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint16, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint16) ChunkByInt64(f func(el uint16) int64) [][]uint16 {
	chunks := make([][]uint16, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint16, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint16, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint16) ChunkByUint(f func(el uint16) uint) [][]uint16 {
	chunks := make([][]uint16, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint16, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint16, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint16) ChunkByUint8(f func(el uint16) uint8) [][]uint16 {
	chunks := make([][]uint16, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint16, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint16, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint16) ChunkByUint16(f func(el uint16) uint16) [][]uint16 {
	chunks := make([][]uint16, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint16, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint16, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint16) ChunkByUint32(f func(el uint16) uint32) [][]uint16 {
	chunks := make([][]uint16, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint16, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint16, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint16) ChunkByUint64(f func(el uint16) uint64) [][]uint16 {
	chunks := make([][]uint16, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint16, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint16, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint16) ChunkByInterface(f func(el uint16) interface{}) [][]uint16 {
	chunks := make([][]uint16, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint16, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint16, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkEvery returns slice of slices containing count elements each
func (s SliceUint16) ChunkEvery(count int) ([][]uint16, error) {
	chunks := make([][]uint16, 0)
	if count <= 0 {
		return chunks, ErrNegativeValue
	}
	chunk := make([]uint16, 0, count)
	for i, el := range s.Data {
		chunk = append(chunk, el)
		if (i+1)%count == 0 {
			chunks = append(chunks, chunk)
			chunk = make([]uint16, 0, count)
		}
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks, nil
}

// Contains returns true if el in arr.
func (s SliceUint16) Contains(el uint16) bool {
	for _, val := range s.Data {
		if val == el {
			return true
		}
	}
	return false
}

// Count return count of el occurences in arr.
func (s SliceUint16) Count(el uint16) int {
	count := 0
	for _, val := range s.Data {
		if val == el {
			count++
		}
	}
	return count
}

// CountBy returns how many times f returns true.
func (s SliceUint16) CountBy(f func(el uint16) bool) int {
	count := 0
	for _, el := range s.Data {
		if f(el) {
			count++
		}
	}
	return count
}

// Cycle is an infinite loop over slice
func (s SliceUint16) Cycle() chan uint16 {
	c := make(chan uint16, 1)
	go func() {
		defer close(c)
		if len(s.Data) == 0 {
			return
		}
		for {
			for _, val := range s.Data {
				c <- val
			}
		}
	}()
	return c
}

// Dedup returns a given slice without consecutive duplicated elements
func (s SliceUint16) Dedup() []uint16 {
	if len(s.Data) == 0 {
		return s.Data
	}

	result := make([]uint16, 0, len(s.Data))
	prev := s.Data[0]
	result = append(result, prev)
	for _, el := range s.Data[1:] {
		if el != prev {
			result = append(result, el)
			prev = el
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint16) DedupByBool(f func(el uint16) bool) []uint16 {
	result := make([]uint16, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint16) DedupByByte(f func(el uint16) byte) []uint16 {
	result := make([]uint16, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint16) DedupByString(f func(el uint16) string) []uint16 {
	result := make([]uint16, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint16) DedupByFloat32(f func(el uint16) float32) []uint16 {
	result := make([]uint16, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint16) DedupByFloat64(f func(el uint16) float64) []uint16 {
	result := make([]uint16, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint16) DedupByInt(f func(el uint16) int) []uint16 {
	result := make([]uint16, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint16) DedupByInt8(f func(el uint16) int8) []uint16 {
	result := make([]uint16, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint16) DedupByInt16(f func(el uint16) int16) []uint16 {
	result := make([]uint16, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint16) DedupByInt32(f func(el uint16) int32) []uint16 {
	result := make([]uint16, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint16) DedupByInt64(f func(el uint16) int64) []uint16 {
	result := make([]uint16, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint16) DedupByUint(f func(el uint16) uint) []uint16 {
	result := make([]uint16, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint16) DedupByUint8(f func(el uint16) uint8) []uint16 {
	result := make([]uint16, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint16) DedupByUint16(f func(el uint16) uint16) []uint16 {
	result := make([]uint16, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint16) DedupByUint32(f func(el uint16) uint32) []uint16 {
	result := make([]uint16, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint16) DedupByUint64(f func(el uint16) uint64) []uint16 {
	result := make([]uint16, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint16) DedupByInterface(f func(el uint16) interface{}) []uint16 {
	result := make([]uint16, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// Delete deletes the first occurence of the element from the slice
func (s SliceUint16) Delete(element uint16) []uint16 {
	result := make([]uint16, 0, len(s.Data)-1)
	deleted := false
	for _, el := range s.Data {
		if !deleted && el == element {
			continue
		}
		result = append(result, el)
	}
	return result

}

// DeleteAt returns the slice without elements on given positions
func (s SliceUint16) DeleteAt(index int) ([]uint16, error) {
	if index >= len(s.Data) {
		return s.Data, ErrOutOfRange
	}

	result := make([]uint16, 0, len(s.Data)-1)
	for i, el := range s.Data {
		if i != index {
			result = append(result, el)
		}
	}
	return result, nil
}

// DropEvery returns a slice of every nth element in the enumerable dropped,
// starting with the first element.
func (s SliceUint16) DropEvery(nth int) ([]uint16, error) {
	if nth <= 0 {
		return s.Data, ErrNonPositiveValue
	}
	result := make([]uint16, 0, len(s.Data)/nth)
	for i, el := range s.Data {
		if (i+1)%nth != 0 {
			result = append(result, el)
		}
	}
	return result, nil
}

// DropWhile drops elements from arr while f returns true
func (s SliceUint16) DropWhile(f func(arr uint16) bool) []uint16 {
	result := make([]uint16, 0, len(s.Data))
	for _, el := range s.Data {
		if !f(el) {
			return result
		}
		result = append(result, el)
	}
	return result
}

// Each calls f for every element from arr
func (s SliceUint16) Each(f func(el uint16)) {
	for _, el := range s.Data {
		f(el)
	}
}

// Equal returns true if slices are equal
func (s SliceUint16) Equal(other []uint16) bool {
	if len(s.Data) != len(other) {
		return false
	}
	for i, el := range other {
		if s.Data[i] != el {
			return false
		}
	}
	return true
}

// Filter returns slice of T for which F returned true
func (s SliceUint16) Filter(f func(el uint16) bool) []uint16 {
	result := make([]uint16, 0, len(s.Data))
	for _, el := range s.Data {
		if f(el) {
			result = append(result, el)
		}
	}
	return result
}

// Find returns the first element for which f returns true
func (s SliceUint16) Find(f func(el uint16) bool) (uint16, error) {
	for _, el := range s.Data {
		if f(el) {
			return el, nil
		}
	}
	var tmp uint16
	return tmp, ErrNotFound
}

// FindIndex is like Find, but return element index instead of element itself
func (s SliceUint16) FindIndex(f func(el uint16) bool) (int, error) {
	for i, el := range s.Data {
		if f(el) {
			return i, nil
		}
	}
	return 0, ErrNotFound
}

// Join concatenates elements of the slice to create a single string.
func (s SliceUint16) Join(sep string) string {
	strs := make([]string, 0, len(s.Data))
	for _, el := range s.Data {
		strs = append(strs, string(el))
	}
	return strings.Join(strs, sep)
}

// GroupBy groups element from array by value returned by f
func (s SliceUint16) GroupByBool(f func(el uint16) bool) map[bool][]uint16 {
	result := make(map[bool][]uint16)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint16, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint16) GroupByByte(f func(el uint16) byte) map[byte][]uint16 {
	result := make(map[byte][]uint16)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint16, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint16) GroupByString(f func(el uint16) string) map[string][]uint16 {
	result := make(map[string][]uint16)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint16, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint16) GroupByFloat32(f func(el uint16) float32) map[float32][]uint16 {
	result := make(map[float32][]uint16)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint16, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint16) GroupByFloat64(f func(el uint16) float64) map[float64][]uint16 {
	result := make(map[float64][]uint16)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint16, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint16) GroupByInt(f func(el uint16) int) map[int][]uint16 {
	result := make(map[int][]uint16)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint16, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint16) GroupByInt8(f func(el uint16) int8) map[int8][]uint16 {
	result := make(map[int8][]uint16)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint16, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint16) GroupByInt16(f func(el uint16) int16) map[int16][]uint16 {
	result := make(map[int16][]uint16)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint16, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint16) GroupByInt32(f func(el uint16) int32) map[int32][]uint16 {
	result := make(map[int32][]uint16)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint16, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint16) GroupByInt64(f func(el uint16) int64) map[int64][]uint16 {
	result := make(map[int64][]uint16)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint16, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint16) GroupByUint(f func(el uint16) uint) map[uint][]uint16 {
	result := make(map[uint][]uint16)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint16, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint16) GroupByUint8(f func(el uint16) uint8) map[uint8][]uint16 {
	result := make(map[uint8][]uint16)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint16, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint16) GroupByUint16(f func(el uint16) uint16) map[uint16][]uint16 {
	result := make(map[uint16][]uint16)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint16, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint16) GroupByUint32(f func(el uint16) uint32) map[uint32][]uint16 {
	result := make(map[uint32][]uint16)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint16, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint16) GroupByUint64(f func(el uint16) uint64) map[uint64][]uint16 {
	result := make(map[uint64][]uint16)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint16, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint16) GroupByInterface(f func(el uint16) interface{}) map[interface{}][]uint16 {
	result := make(map[interface{}][]uint16)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint16, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// InsertAt returns the slice with element inserted at given index.
func (s SliceUint16) InsertAt(index int, element uint16) ([]uint16, error) {
	result := make([]uint16, 0, len(s.Data)+1)

	// insert at the end
	if index == len(s.Data) || index == -1 {
		result = append(result, s.Data...)
		result = append(result, element)
		return result, nil
	}

	if index > len(s.Data) {
		return s.Data, ErrOutOfRange
	}
	if index < 0 {
		return s.Data, ErrNegativeValue
	}

	for i, el := range s.Data {
		if i == index {
			result = append(result, element)
		}
		result = append(result, el)
	}
	return result, nil
}

// Intersperse inserts el between each element of arr
func (s SliceUint16) Intersperse(el uint16) []uint16 {
	if len(s.Data) == 0 {
		return s.Data
	}
	result := make([]uint16, 0, len(s.Data)*2-1)
	result = append(result, s.Data[0])
	for _, val := range s.Data[1:] {
		result = append(result, el, val)
	}
	return result
}

// Last returns the last element from the slice
func (s SliceUint16) Last() (uint16, error) {
	if len(s.Data) == 0 {
		var tmp uint16
		return tmp, ErrEmpty
	}
	return s.Data[len(s.Data)-1], nil
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint16) MapBool(f func(el uint16) bool) []bool {
	result := make([]bool, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint16) MapByte(f func(el uint16) byte) []byte {
	result := make([]byte, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint16) MapString(f func(el uint16) string) []string {
	result := make([]string, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint16) MapFloat32(f func(el uint16) float32) []float32 {
	result := make([]float32, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint16) MapFloat64(f func(el uint16) float64) []float64 {
	result := make([]float64, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint16) MapInt(f func(el uint16) int) []int {
	result := make([]int, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint16) MapInt8(f func(el uint16) int8) []int8 {
	result := make([]int8, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint16) MapInt16(f func(el uint16) int16) []int16 {
	result := make([]int16, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint16) MapInt32(f func(el uint16) int32) []int32 {
	result := make([]int32, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint16) MapInt64(f func(el uint16) int64) []int64 {
	result := make([]int64, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint16) MapUint(f func(el uint16) uint) []uint {
	result := make([]uint, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint16) MapUint8(f func(el uint16) uint8) []uint8 {
	result := make([]uint8, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint16) MapUint16(f func(el uint16) uint16) []uint16 {
	result := make([]uint16, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint16) MapUint32(f func(el uint16) uint32) []uint32 {
	result := make([]uint32, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint16) MapUint64(f func(el uint16) uint64) []uint64 {
	result := make([]uint64, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint16) MapInterface(f func(el uint16) interface{}) []interface{} {
	result := make([]interface{}, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Max returns the maximal element from arr
func (s SliceUint16) Max() (uint16, error) {
	if len(s.Data) == 0 {
		var tmp uint16
		return tmp, ErrEmpty
	}

	max := s.Data[0]
	for _, el := range s.Data[1:] {
		if el > max {
			max = el
		}
	}
	return max, nil
}

// Min returns the minimal element from arr
func (s SliceUint16) Min() (uint16, error) {
	if len(s.Data) == 0 {
		var tmp uint16
		return tmp, ErrEmpty
	}

	min := s.Data[0]
	for _, el := range s.Data[1:] {
		if el < min {
			min = el
		}
	}
	return min, nil
}

// Permutations returns successive size-length permutations of elements from the slice.
// {1, 2, 3} -> {1, 2}, {1, 3}, {2, 1}, {2, 3}, {3, 1}, {3, 2}
func (s SliceUint16) Permutations(size int) chan []uint16 {
	c := make(chan []uint16, 1)
	go func() {
		if len(s.Data) > 0 {
			s.permutations(c, size, []uint16{}, s.Data)
		}
		close(c)
	}()
	return c
}

// permutations is a core implementation for Permutations
func (s SliceUint16) permutations(c chan []uint16, size int, left []uint16, right []uint16) {
	if len(left) == size || len(right) == 0 {
		c <- left
		return
	}

	for i, el := range right {
		newLeft := make([]uint16, 0, len(left)+1)
		newLeft = append(newLeft, left...)
		newLeft = append(newLeft, el)

		newRight := make([]uint16, 0, len(right)-1)
		for j, other := range right {
			if j != i {
				newRight = append(newRight, other)
			}
		}
		s.permutations(c, size, newLeft, newRight)
	}
}

// Product returns cortesian product of elements
// {{1, 2}, {3, 4}} -> {1, 3}, {1, 4}, {2, 3}, {2, 4}
func (s SliceUint16) Product(repeat int) chan []uint16 {
	c := make(chan []uint16, 1)
	go s.product(c, repeat, []uint16{}, 0)
	return c
}

// product is a core implementation for Product
func (s SliceUint16) product(c chan []uint16, repeat int, left []uint16, pos int) {
	// iterate over the last array
	if pos == repeat-1 {
		for _, el := range s.Data {
			result := make([]uint16, 0, len(left)+1)
			result = append(result, left...)
			result = append(result, el)
			c <- result
		}
		return
	}

	for _, el := range s.Data {
		result := make([]uint16, 0, len(left)+1)
		result = append(result, left...)
		result = append(result, el)
		s.product(c, repeat, result, pos+1)
	}

	if pos == 0 {
		close(c)
	}
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint16) ReduceBool(acc bool, f func(el uint16, acc bool) bool) bool {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint16) ReduceByte(acc byte, f func(el uint16, acc byte) byte) byte {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint16) ReduceString(acc string, f func(el uint16, acc string) string) string {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint16) ReduceFloat32(acc float32, f func(el uint16, acc float32) float32) float32 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint16) ReduceFloat64(acc float64, f func(el uint16, acc float64) float64) float64 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint16) ReduceInt(acc int, f func(el uint16, acc int) int) int {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint16) ReduceInt8(acc int8, f func(el uint16, acc int8) int8) int8 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint16) ReduceInt16(acc int16, f func(el uint16, acc int16) int16) int16 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint16) ReduceInt32(acc int32, f func(el uint16, acc int32) int32) int32 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint16) ReduceInt64(acc int64, f func(el uint16, acc int64) int64) int64 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint16) ReduceUint(acc uint, f func(el uint16, acc uint) uint) uint {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint16) ReduceUint8(acc uint8, f func(el uint16, acc uint8) uint8) uint8 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint16) ReduceUint16(acc uint16, f func(el uint16, acc uint16) uint16) uint16 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint16) ReduceUint32(acc uint32, f func(el uint16, acc uint32) uint32) uint32 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint16) ReduceUint64(acc uint64, f func(el uint16, acc uint64) uint64) uint64 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint16) ReduceInterface(acc interface{}, f func(el uint16, acc interface{}) interface{}) interface{} {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint16) ReduceWhileBool(acc bool, f func(el uint16, acc bool) (bool, error)) (bool, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint16) ReduceWhileByte(acc byte, f func(el uint16, acc byte) (byte, error)) (byte, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint16) ReduceWhileString(acc string, f func(el uint16, acc string) (string, error)) (string, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint16) ReduceWhileFloat32(acc float32, f func(el uint16, acc float32) (float32, error)) (float32, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint16) ReduceWhileFloat64(acc float64, f func(el uint16, acc float64) (float64, error)) (float64, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint16) ReduceWhileInt(acc int, f func(el uint16, acc int) (int, error)) (int, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint16) ReduceWhileInt8(acc int8, f func(el uint16, acc int8) (int8, error)) (int8, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint16) ReduceWhileInt16(acc int16, f func(el uint16, acc int16) (int16, error)) (int16, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint16) ReduceWhileInt32(acc int32, f func(el uint16, acc int32) (int32, error)) (int32, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint16) ReduceWhileInt64(acc int64, f func(el uint16, acc int64) (int64, error)) (int64, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint16) ReduceWhileUint(acc uint, f func(el uint16, acc uint) (uint, error)) (uint, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint16) ReduceWhileUint8(acc uint8, f func(el uint16, acc uint8) (uint8, error)) (uint8, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint16) ReduceWhileUint16(acc uint16, f func(el uint16, acc uint16) (uint16, error)) (uint16, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint16) ReduceWhileUint32(acc uint32, f func(el uint16, acc uint32) (uint32, error)) (uint32, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint16) ReduceWhileUint64(acc uint64, f func(el uint16, acc uint64) (uint64, error)) (uint64, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint16) ReduceWhileInterface(acc interface{}, f func(el uint16, acc interface{}) (interface{}, error)) (interface{}, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// Reverse returns given arr in reversed order
func (s SliceUint16) Reverse() []uint16 {
	if len(s.Data) <= 1 {
		return s.Data
	}
	result := make([]uint16, 0, len(s.Data))
	for i := len(s.Data) - 1; i >= 0; i-- {
		result = append(result, s.Data[i])
	}
	return result
}

// Same returns true if all element in arr the same
func (s SliceUint16) Same() bool {
	if len(s.Data) <= 1 {
		return true
	}
	for i := 0; i < len(s.Data)-1; i++ {
		if s.Data[i] != s.Data[i+1] {
			return false
		}
	}
	return true
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint16) ScanBool(acc bool, f func(el uint16, acc bool) bool) []bool {
	result := make([]bool, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint16) ScanByte(acc byte, f func(el uint16, acc byte) byte) []byte {
	result := make([]byte, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint16) ScanString(acc string, f func(el uint16, acc string) string) []string {
	result := make([]string, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint16) ScanFloat32(acc float32, f func(el uint16, acc float32) float32) []float32 {
	result := make([]float32, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint16) ScanFloat64(acc float64, f func(el uint16, acc float64) float64) []float64 {
	result := make([]float64, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint16) ScanInt(acc int, f func(el uint16, acc int) int) []int {
	result := make([]int, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint16) ScanInt8(acc int8, f func(el uint16, acc int8) int8) []int8 {
	result := make([]int8, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint16) ScanInt16(acc int16, f func(el uint16, acc int16) int16) []int16 {
	result := make([]int16, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint16) ScanInt32(acc int32, f func(el uint16, acc int32) int32) []int32 {
	result := make([]int32, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint16) ScanInt64(acc int64, f func(el uint16, acc int64) int64) []int64 {
	result := make([]int64, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint16) ScanUint(acc uint, f func(el uint16, acc uint) uint) []uint {
	result := make([]uint, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint16) ScanUint8(acc uint8, f func(el uint16, acc uint8) uint8) []uint8 {
	result := make([]uint8, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint16) ScanUint16(acc uint16, f func(el uint16, acc uint16) uint16) []uint16 {
	result := make([]uint16, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint16) ScanUint32(acc uint32, f func(el uint16, acc uint32) uint32) []uint32 {
	result := make([]uint32, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint16) ScanUint64(acc uint64, f func(el uint16, acc uint64) uint64) []uint64 {
	result := make([]uint64, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint16) ScanInterface(acc interface{}, f func(el uint16, acc interface{}) interface{}) []interface{} {
	result := make([]interface{}, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Shuffle in random order arr elements
func (s SliceUint16) Shuffle() []uint16 {
	if len(s.Data) <= 1 {
		return s.Data
	}
	rand.Seed(time.Now().UnixNano())
	swap := func(i, j int) {
		s.Data[i], s.Data[j] = s.Data[j], s.Data[i]
	}
	rand.Shuffle(len(s.Data), swap)
	return s.Data
}

// Sort returns sorted slice
func (s SliceUint16) Sort() []uint16 {
	if len(s.Data) <= 1 {
		return s.Data
	}
	less := func(i int, j int) bool {
		return s.Data[i] < s.Data[j]
	}
	sort.SliceStable(s.Data, less)
	return s.Data
}

// Sorted returns true if slice is sorted
func (s SliceUint16) Sorted() bool {
	if len(s.Data) <= 1 {
		return true
	}
	for i := 1; i < len(s.Data); i++ {
		if s.Data[i-1] > s.Data[i] {
			return false
		}
	}
	return true
}

// Split splits arr by sep
func (s SliceUint16) Split(sep uint16) [][]uint16 {
	result := make([][]uint16, 0)
	curr := make([]uint16, 0)
	for _, el := range s.Data {
		if el == sep {
			result = append(result, curr)
		} else {
			curr = append(curr, el)
		}
	}
	result = append(result, curr)
	return result
}

// StartsWith returns true if slice starts with the given prefix slice.
// If prefix is empty, it returns true.
func (s SliceUint16) StartsWith(prefix []uint16) bool {
	if len(prefix) > len(s.Data) {
		return false
	}
	for i, el := range prefix {
		if el != s.Data[i] {
			return false
		}
	}
	return true
}

// Sum return sum of all elements from arr
func (s SliceUint16) Sum() uint16 {
	var sum uint16
	for _, el := range s.Data {
		sum += el
	}
	return sum
}

// TakeEvery returns slice of every nth elements
func (s SliceUint16) TakeEvery(nth int) ([]uint16, error) {
	if nth <= 0 {
		return s.Data, ErrNonPositiveValue
	}
	result := make([]uint16, 0, len(s.Data))
	for i, el := range s.Data {
		if (i+1)%nth == 0 {
			result = append(result, el)
		}
	}
	return result, nil
}

// TakeRandom returns slice of count random elements from the slice
func (s SliceUint16) TakeRandom(count int) ([]uint16, error) {
	if count > len(s.Data) {
		return nil, ErrOutOfRange
	}
	if count <= 0 {
		return nil, ErrNonPositiveValue
	}

	rand.Seed(time.Now().UnixNano())
	swap := func(i, j int) {
		s.Data[i], s.Data[j] = s.Data[j], s.Data[i]
	}
	rand.Shuffle(len(s.Data), swap)
	return s.Data[:count], nil
}

// TakeWhile takes elements from arr while f returns true
func (s SliceUint16) TakeWhile(f func(el uint16) bool) []uint16 {
	result := make([]uint16, 0, len(s.Data))
	for _, el := range s.Data {
		if !f(el) {
			return result
		}
		result = append(result, el)
	}
	return result
}

// ToChannel returns channel with elements from the slice
func (s SliceUint16) ToChannel() chan uint16 {
	c := make(chan uint16, 1)
	go func() {
		for _, el := range s.Data {
			c <- el
		}
		close(c)
	}()
	return c
}

// Uniq returns arr with only first occurences of every element.
func (s SliceUint16) Uniq() []uint16 {
	if len(s.Data) <= 1 {
		return s.Data
	}
	added := make(map[uint16]struct{})
	nothing := struct{}{}
	result := make([]uint16, 0, len(s.Data))
	for _, el := range s.Data {
		_, exists := added[el]
		if !exists {
			result = append(result, el)
			added[el] = nothing
		}
	}
	return result

}

// Window makes sliding window for a given slice:
// ({1,2,3}, 2) -> (1,2), (2,3)
func (s SliceUint16) Window(size int) ([][]uint16, error) {
	if size <= 0 {
		return nil, ErrNonPositiveValue
	}
	result := make([][]uint16, 0, len(s.Data)/size)
	for i := 0; i <= len(s.Data)-size; i++ {
		chunk := s.Data[i : i+size]
		result = append(result, chunk)
	}
	return result, nil
}

// Without returns the slice with filtered out element
func (s SliceUint16) Without(elements ...uint16) []uint16 {
	result := make([]uint16, 0, len(s.Data))
	for _, el := range s.Data {
		allowed := true
		for _, other := range elements {
			if el == other {
				allowed = false
			}
		}
		if allowed {
			result = append(result, el)
		}
	}
	return result
}

// Concat concatenates given slices into a single slice.
func (s SlicesUint16) Concat() []uint16 {
	result := make([]uint16, 0)
	for _, arr := range s.Data {
		result = append(result, arr...)
	}
	return result
}

// Product returns cortesian product of elements
// {{1, 2}, {3, 4}} -> {1, 3}, {1, 4}, {2, 3}, {2, 4}
func (s SlicesUint16) Product() chan []uint16 {
	c := make(chan []uint16, 1)
	go s.product(c, []uint16{}, 0)
	return c
}

// product is a core implementation of Product
func (s SlicesUint16) product(c chan []uint16, left []uint16, pos int) {
	// iterate over the last array
	if pos == len(s.Data)-1 {
		for _, el := range s.Data[pos] {
			result := make([]uint16, 0, len(left)+1)
			result = append(result, left...)
			result = append(result, el)
			c <- result
		}
		return
	}

	for _, el := range s.Data[pos] {
		result := make([]uint16, 0, len(left)+1)
		result = append(result, left...)
		result = append(result, el)
		s.product(c, result, pos+1)
	}

	if pos == 0 {
		close(c)
	}
}

// Zip returns array of arrays of elements from given arrs
// on the same position
func (s SlicesUint16) Zip() [][]uint16 {
	size := len(s.Data[0])
	for _, arr := range s.Data[1:] {
		if len(arr) > size {
			size = len(arr)
		}
	}

	result := make([][]uint16, 0, size)
	for i := 0; i <= size; i++ {
		chunk := make([]uint16, 0, len(s.Data))
		for _, arr := range s.Data {
			chunk = append(chunk, arr[i])
		}
		result = append(result, chunk)
	}
	return result
}

// Channel is a set of operations with channel
type ChannelUint32 struct {
	Data chan uint32
}

// AsyncSlice is a set of operations to work with slice asynchronously
type AsyncSliceUint32 struct {
	Data    []uint32
	Workers int
}

// Sequence is a set of operations to generate sequences
type SequenceUint32 struct {
	ctx context.Context
}

// Pair is a set of functions for 2 values that you can pass into reduce-like funcs
type PairUint32 struct {
	// empty
}

// Slice is a set of operations to work with slice
type SliceUint32 struct {
	Data []uint32
}

// Slices is a set of operations to work with slice of slices
type SlicesUint32 struct {
	Data [][]uint32
}

// Any returns true if f returns true for any element in channel
func (c ChannelUint32) Any(f func(el uint32) bool) bool {
	for el := range c.Data {
		if f(el) {
			return true
		}
	}
	return false
}

// All returns true if f returns true for all elements in channel
func (c ChannelUint32) All(f func(el uint32) bool) bool {
	for el := range c.Data {
		if !f(el) {
			return false
		}
	}
	return true
}

// ChunkEvery returns channel with slices containing count elements each
func (c ChannelUint32) ChunkEvery(count int) chan []uint32 {
	chunks := make(chan []uint32, 1)
	go func() {
		chunk := make([]uint32, 0, count)
		i := 0
		for el := range c.Data {
			chunk = append(chunk, el)
			i++
			if i%count == 0 {
				i = 0
				chunks <- chunk
				chunk = make([]uint32, 0, count)
			}
		}
		if len(chunk) > 0 {
			chunks <- chunk
		}
		close(chunks)
	}()
	return chunks
}

// Count return count of el occurences in channel.
func (c ChannelUint32) Count(el uint32) int {
	count := 0
	for val := range c.Data {
		if val == el {
			count++
		}
	}
	return count
}

// Drop drops first n elements from channel c and returns a new channel with the rest.
// It returns channel do be unblocking. If you want array instead, wrap result into TakeAll.
func (c ChannelUint32) Drop(n int) chan uint32 {
	result := make(chan uint32, 1)
	go func() {
		i := 0
		for el := range c.Data {
			if i >= n {
				result <- el
			}
			i++
		}
		close(result)
	}()
	return result
}

// Each calls f for every element in the channel
func (c ChannelUint32) Each(f func(el uint32)) {
	for el := range c.Data {
		f(el)
	}
}

// Filter returns a new channel with elements from input channel
// for which f returns true
func (c ChannelUint32) Filter(f func(el uint32) bool) chan uint32 {
	result := make(chan uint32, 1)
	go func() {
		for el := range c.Data {
			if f(el) {
				result <- el
			}
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint32) MapBool(f func(el uint32) bool) chan bool {
	result := make(chan bool, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint32) MapByte(f func(el uint32) byte) chan byte {
	result := make(chan byte, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint32) MapString(f func(el uint32) string) chan string {
	result := make(chan string, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint32) MapFloat32(f func(el uint32) float32) chan float32 {
	result := make(chan float32, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint32) MapFloat64(f func(el uint32) float64) chan float64 {
	result := make(chan float64, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint32) MapInt(f func(el uint32) int) chan int {
	result := make(chan int, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint32) MapInt8(f func(el uint32) int8) chan int8 {
	result := make(chan int8, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint32) MapInt16(f func(el uint32) int16) chan int16 {
	result := make(chan int16, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint32) MapInt32(f func(el uint32) int32) chan int32 {
	result := make(chan int32, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint32) MapInt64(f func(el uint32) int64) chan int64 {
	result := make(chan int64, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint32) MapUint(f func(el uint32) uint) chan uint {
	result := make(chan uint, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint32) MapUint8(f func(el uint32) uint8) chan uint8 {
	result := make(chan uint8, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint32) MapUint16(f func(el uint32) uint16) chan uint16 {
	result := make(chan uint16, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint32) MapUint32(f func(el uint32) uint32) chan uint32 {
	result := make(chan uint32, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint32) MapUint64(f func(el uint32) uint64) chan uint64 {
	result := make(chan uint64, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint32) MapInterface(f func(el uint32) interface{}) chan interface{} {
	result := make(chan interface{}, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Max returns the maximal element from channel
func (c ChannelUint32) Max() (uint32, error) {
	max, ok := <-c.Data
	if !ok {
		return max, ErrEmpty
	}
	for el := range c.Data {
		if el > max {
			max = el
		}
	}
	return max, nil
}

// Min returns the minimal element from channel
func (c ChannelUint32) Min() (uint32, error) {
	min, ok := <-c.Data
	if !ok {
		return min, ErrEmpty
	}
	for el := range c.Data {
		if el < min {
			min = el
		}
	}
	return min, nil
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint32) ReduceBool(acc bool, f func(el uint32, acc bool) bool) bool {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint32) ReduceByte(acc byte, f func(el uint32, acc byte) byte) byte {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint32) ReduceString(acc string, f func(el uint32, acc string) string) string {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint32) ReduceFloat32(acc float32, f func(el uint32, acc float32) float32) float32 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint32) ReduceFloat64(acc float64, f func(el uint32, acc float64) float64) float64 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint32) ReduceInt(acc int, f func(el uint32, acc int) int) int {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint32) ReduceInt8(acc int8, f func(el uint32, acc int8) int8) int8 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint32) ReduceInt16(acc int16, f func(el uint32, acc int16) int16) int16 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint32) ReduceInt32(acc int32, f func(el uint32, acc int32) int32) int32 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint32) ReduceInt64(acc int64, f func(el uint32, acc int64) int64) int64 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint32) ReduceUint(acc uint, f func(el uint32, acc uint) uint) uint {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint32) ReduceUint8(acc uint8, f func(el uint32, acc uint8) uint8) uint8 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint32) ReduceUint16(acc uint16, f func(el uint32, acc uint16) uint16) uint16 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint32) ReduceUint32(acc uint32, f func(el uint32, acc uint32) uint32) uint32 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint32) ReduceUint64(acc uint64, f func(el uint32, acc uint64) uint64) uint64 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint32) ReduceInterface(acc interface{}, f func(el uint32, acc interface{}) interface{}) interface{} {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint32) ScanBool(acc bool, f func(el uint32, acc bool) bool) chan bool {
	result := make(chan bool, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint32) ScanByte(acc byte, f func(el uint32, acc byte) byte) chan byte {
	result := make(chan byte, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint32) ScanString(acc string, f func(el uint32, acc string) string) chan string {
	result := make(chan string, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint32) ScanFloat32(acc float32, f func(el uint32, acc float32) float32) chan float32 {
	result := make(chan float32, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint32) ScanFloat64(acc float64, f func(el uint32, acc float64) float64) chan float64 {
	result := make(chan float64, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint32) ScanInt(acc int, f func(el uint32, acc int) int) chan int {
	result := make(chan int, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint32) ScanInt8(acc int8, f func(el uint32, acc int8) int8) chan int8 {
	result := make(chan int8, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint32) ScanInt16(acc int16, f func(el uint32, acc int16) int16) chan int16 {
	result := make(chan int16, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint32) ScanInt32(acc int32, f func(el uint32, acc int32) int32) chan int32 {
	result := make(chan int32, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint32) ScanInt64(acc int64, f func(el uint32, acc int64) int64) chan int64 {
	result := make(chan int64, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint32) ScanUint(acc uint, f func(el uint32, acc uint) uint) chan uint {
	result := make(chan uint, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint32) ScanUint8(acc uint8, f func(el uint32, acc uint8) uint8) chan uint8 {
	result := make(chan uint8, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint32) ScanUint16(acc uint16, f func(el uint32, acc uint16) uint16) chan uint16 {
	result := make(chan uint16, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint32) ScanUint32(acc uint32, f func(el uint32, acc uint32) uint32) chan uint32 {
	result := make(chan uint32, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint32) ScanUint64(acc uint64, f func(el uint32, acc uint64) uint64) chan uint64 {
	result := make(chan uint64, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint32) ScanInterface(acc interface{}, f func(el uint32, acc interface{}) interface{}) chan interface{} {
	result := make(chan interface{}, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Sum returns sum of all elements from channel
func (c ChannelUint32) Sum() uint32 {
	var sum uint32
	for el := range c.Data {
		sum += el
	}
	return sum
}

// Take takes first count elements from the channel.
func (c ChannelUint32) Take(count int) chan uint32 {
	result := make(chan uint32, 1)
	go func() {
		defer close(result)
		if count <= 0 {
			return
		}
		i := 0
		for el := range c.Data {
			result <- el
			i++
			if i == count {
				return
			}
		}
	}()
	return result
}

// Tee returns 2 channels with elements from the input channel
func (c ChannelUint32) Tee(count int) []chan uint32 {
	channels := make([]chan uint32, 0, count)
	for i := 0; i < count; i++ {
		channels = append(channels, make(chan uint32, 1))
	}
	go func() {
		for el := range c.Data {
			wg := sync.WaitGroup{}
			putInto := func(ch chan uint32) {
				defer wg.Done()
				ch <- el
			}
			wg.Add(count)
			for _, ch := range channels {
				putInto(ch)
			}
			wg.Wait()
		}
		for _, ch := range channels {
			close(ch)
		}
	}()
	return channels
}

// ToSlice returns slice with all elements from channel.
func (c ChannelUint32) ToSlice() []uint32 {
	result := make([]uint32, 0)
	for val := range c.Data {
		result = append(result, val)
	}
	return result
}

// All returns true if f returns true for all elements in slice
func (s AsyncSliceUint32) All(f func(el uint32) bool) bool {
	if len(s.Data) == 0 {
		return true
	}

	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int, result chan<- bool, ctx context.Context) {
		defer wg.Done()
		for {
			select {
			case <-ctx.Done():
				return
			case index, ok := <-jobs:
				if !ok {
					return
				}
				if !f(s.Data[index]) {
					result <- false
					return
				}
			}
		}
	}

	ctx, cancel := context.WithCancel(context.Background())
	// when we're returning the result, cancel all workers
	defer cancel()

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	result := make(chan bool, workers)
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs, result, ctx)
	}

	// close the result channel when all workers have done
	go func() {
		wg.Wait()
		close(result)
	}()

	// schedule the jobs: indices to check
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)

	for range result {
		return false
	}
	return true
}

// Any returns true if f returns true for any element from slice
func (s AsyncSliceUint32) Any(f func(el uint32) bool) bool {
	if len(s.Data) == 0 {
		return false
	}

	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int, result chan<- bool, ctx context.Context) {
		defer wg.Done()
		for {
			select {
			case <-ctx.Done():
				return
			case index, ok := <-jobs:
				if !ok {
					return
				}
				if f(s.Data[index]) {
					result <- true
					return
				}
			}
		}
	}

	ctx, cancel := context.WithCancel(context.Background())
	// when we're returning the result, cancel all workers
	defer cancel()

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	result := make(chan bool, workers)
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs, result, ctx)
	}

	// close the result channel when all workers have done
	go func() {
		wg.Wait()
		close(result)
	}()

	// schedule the jobs: indices to check
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)

	for range result {
		return true
	}
	return false
}

// Each calls f for every element from slice
func (s AsyncSliceUint32) Each(f func(el uint32)) {
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		defer wg.Done()
		for index := range jobs {
			f(s.Data[index])
		}
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
}

// Filter returns slice of element for which f returns true
func (s AsyncSliceUint32) Filter(f func(el uint32) bool) []uint32 {
	resultMap := make([]bool, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			if f(s.Data[index]) {
				resultMap[index] = true
			}
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()

	// return filtered results
	result := make([]uint32, 0, len(s.Data))
	for i, el := range s.Data {
		if resultMap[i] {
			result = append(result, el)
		}
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint32) MapBool(f func(el uint32) bool) []bool {
	result := make([]bool, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint32) MapByte(f func(el uint32) byte) []byte {
	result := make([]byte, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint32) MapString(f func(el uint32) string) []string {
	result := make([]string, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint32) MapFloat32(f func(el uint32) float32) []float32 {
	result := make([]float32, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint32) MapFloat64(f func(el uint32) float64) []float64 {
	result := make([]float64, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint32) MapInt(f func(el uint32) int) []int {
	result := make([]int, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint32) MapInt8(f func(el uint32) int8) []int8 {
	result := make([]int8, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint32) MapInt16(f func(el uint32) int16) []int16 {
	result := make([]int16, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint32) MapInt32(f func(el uint32) int32) []int32 {
	result := make([]int32, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint32) MapInt64(f func(el uint32) int64) []int64 {
	result := make([]int64, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint32) MapUint(f func(el uint32) uint) []uint {
	result := make([]uint, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint32) MapUint8(f func(el uint32) uint8) []uint8 {
	result := make([]uint8, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint32) MapUint16(f func(el uint32) uint16) []uint16 {
	result := make([]uint16, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint32) MapUint32(f func(el uint32) uint32) []uint32 {
	result := make([]uint32, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint32) MapUint64(f func(el uint32) uint64) []uint64 {
	result := make([]uint64, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint32) MapInterface(f func(el uint32) interface{}) []interface{} {
	result := make([]interface{}, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Reduce reduces slice to a single value with f
func (s AsyncSliceUint32) Reduce(f func(left uint32, right uint32) uint32) uint32 {
	if len(s.Data) == 0 {
		var tmp uint32
		return tmp
	}

	state := make([]uint32, len(s.Data))
	state = append(state, s.Data...)
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int, result chan<- uint32) {
		for index := range jobs {
			result <- f(state[index], state[index+1])
		}
		wg.Done()
	}

	for len(state) > 1 {
		// calculate workers count
		workers := s.Workers
		if workers == 0 || workers > len(state) {
			workers = len(state)
		}

		// run workers
		jobs := make(chan int, len(state))
		wg.Add(workers)
		result := make(chan uint32, 1)
		for i := 0; i < workers; i++ {
			go worker(jobs, result)
		}

		go func() {
			wg.Wait()
			close(result)
		}()

		// add indices into jobs for workers
		for i := 0; i < len(state)-1; i += 2 {
			jobs <- i
		}
		close(jobs)

		// collect new state
		newState := make([]uint32, 0, len(state)/2+len(state)%2)
		for el := range result {
			newState = append(newState, el)
		}
		if len(state)%2 == 1 {
			newState = append(newState, state[len(state)-1])
		}
		// put new state as current state after all
		state = newState
	}

	return state[0]
}

// Count is like Range, but infinite
func (s SequenceUint32) Count(start uint32, step uint32) chan uint32 {
	c := make(chan uint32, 1)
	go func() {
		defer close(c)
		for {
			select {
			case <-s.ctx.Done():
				return
			case c <- start:
				start += step
			}
		}
	}()
	return c
}

// Exponential generates elements from start with
// multiplication of value on factor on every step
func (s SequenceUint32) Exponential(start uint32, factor uint32) chan uint32 {
	c := make(chan uint32, 1)
	go func() {
		defer close(c)
		for {
			select {
			case <-s.ctx.Done():
				return
			case c <- start:
				start *= factor
			}
		}
	}()
	return c
}

// Iterate returns an infinite list of repeated applications of f to val
func (s SequenceUint32) Iterate(val uint32, f func(val uint32) uint32) chan uint32 {
	c := make(chan uint32, 1)
	go func() {
		defer close(c)
		for {
			select {
			case <-s.ctx.Done():
				return
			case c <- val:
				val = f(val)
			}
		}
	}()
	return c
}

// Range generates elements from start to end with given step
func (s SequenceUint32) Range(start uint32, end uint32, step uint32) chan uint32 {
	c := make(chan uint32, 1)
	pos := start <= end
	go func() {
		for pos && (start < end) || !pos && (start > end) {
			c <- start
			start += step
		}
		close(c)
	}()
	return c
}

// Repeat returns channel that produces val infinite times
func (s SequenceUint32) Repeat(val uint32) chan uint32 {
	c := make(chan uint32, 1)
	go func() {
		defer close(c)
		for {
			select {
			case <-s.ctx.Done():
				return
			case c <- val:
				continue
			}
		}
	}()
	return c
}

// Replicate returns channel that produces val n times
func (s SequenceUint32) Replicate(val uint32, n int) chan uint32 {
	c := make(chan uint32, 1)
	go func() {
		for i := 0; i < n; i++ {
			c <- val
		}
		close(c)
	}()
	return c
}

// Min returns minimal value
func (PairUint32) Min(a uint32, b uint32) uint32 {
	if a <= b {
		return a
	}
	return b
}

// Max returns maximal value
func (PairUint32) Max(a uint32, b uint32) uint32 {
	if a > b {
		return a
	}
	return b
}

// Any returns true if f returns true for any element in arr
func (s SliceUint32) Any(f func(el uint32) bool) bool {
	for _, el := range s.Data {
		if f(el) {
			return true
		}
	}
	return false
}

// All returns true if f returns true for all elements in arr
func (s SliceUint32) All(f func(el uint32) bool) bool {
	for _, el := range s.Data {
		if !f(el) {
			return false
		}
	}
	return true
}

// Choice chooses a random element from the slice
func (s SliceUint32) Choice() (uint32, error) {
	if len(s.Data) == 0 {
		var tmp uint32
		return tmp, ErrEmpty
	}

	rand.Seed(time.Now().UnixNano())
	i := rand.Intn(len(s.Data))
	return s.Data[i], nil
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint32) ChunkByBool(f func(el uint32) bool) [][]uint32 {
	chunks := make([][]uint32, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint32, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint32, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint32) ChunkByByte(f func(el uint32) byte) [][]uint32 {
	chunks := make([][]uint32, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint32, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint32, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint32) ChunkByString(f func(el uint32) string) [][]uint32 {
	chunks := make([][]uint32, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint32, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint32, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint32) ChunkByFloat32(f func(el uint32) float32) [][]uint32 {
	chunks := make([][]uint32, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint32, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint32, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint32) ChunkByFloat64(f func(el uint32) float64) [][]uint32 {
	chunks := make([][]uint32, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint32, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint32, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint32) ChunkByInt(f func(el uint32) int) [][]uint32 {
	chunks := make([][]uint32, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint32, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint32, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint32) ChunkByInt8(f func(el uint32) int8) [][]uint32 {
	chunks := make([][]uint32, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint32, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint32, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint32) ChunkByInt16(f func(el uint32) int16) [][]uint32 {
	chunks := make([][]uint32, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint32, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint32, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint32) ChunkByInt32(f func(el uint32) int32) [][]uint32 {
	chunks := make([][]uint32, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint32, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint32, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint32) ChunkByInt64(f func(el uint32) int64) [][]uint32 {
	chunks := make([][]uint32, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint32, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint32, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint32) ChunkByUint(f func(el uint32) uint) [][]uint32 {
	chunks := make([][]uint32, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint32, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint32, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint32) ChunkByUint8(f func(el uint32) uint8) [][]uint32 {
	chunks := make([][]uint32, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint32, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint32, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint32) ChunkByUint16(f func(el uint32) uint16) [][]uint32 {
	chunks := make([][]uint32, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint32, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint32, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint32) ChunkByUint32(f func(el uint32) uint32) [][]uint32 {
	chunks := make([][]uint32, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint32, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint32, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint32) ChunkByUint64(f func(el uint32) uint64) [][]uint32 {
	chunks := make([][]uint32, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint32, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint32, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint32) ChunkByInterface(f func(el uint32) interface{}) [][]uint32 {
	chunks := make([][]uint32, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint32, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint32, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkEvery returns slice of slices containing count elements each
func (s SliceUint32) ChunkEvery(count int) ([][]uint32, error) {
	chunks := make([][]uint32, 0)
	if count <= 0 {
		return chunks, ErrNegativeValue
	}
	chunk := make([]uint32, 0, count)
	for i, el := range s.Data {
		chunk = append(chunk, el)
		if (i+1)%count == 0 {
			chunks = append(chunks, chunk)
			chunk = make([]uint32, 0, count)
		}
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks, nil
}

// Contains returns true if el in arr.
func (s SliceUint32) Contains(el uint32) bool {
	for _, val := range s.Data {
		if val == el {
			return true
		}
	}
	return false
}

// Count return count of el occurences in arr.
func (s SliceUint32) Count(el uint32) int {
	count := 0
	for _, val := range s.Data {
		if val == el {
			count++
		}
	}
	return count
}

// CountBy returns how many times f returns true.
func (s SliceUint32) CountBy(f func(el uint32) bool) int {
	count := 0
	for _, el := range s.Data {
		if f(el) {
			count++
		}
	}
	return count
}

// Cycle is an infinite loop over slice
func (s SliceUint32) Cycle() chan uint32 {
	c := make(chan uint32, 1)
	go func() {
		defer close(c)
		if len(s.Data) == 0 {
			return
		}
		for {
			for _, val := range s.Data {
				c <- val
			}
		}
	}()
	return c
}

// Dedup returns a given slice without consecutive duplicated elements
func (s SliceUint32) Dedup() []uint32 {
	if len(s.Data) == 0 {
		return s.Data
	}

	result := make([]uint32, 0, len(s.Data))
	prev := s.Data[0]
	result = append(result, prev)
	for _, el := range s.Data[1:] {
		if el != prev {
			result = append(result, el)
			prev = el
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint32) DedupByBool(f func(el uint32) bool) []uint32 {
	result := make([]uint32, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint32) DedupByByte(f func(el uint32) byte) []uint32 {
	result := make([]uint32, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint32) DedupByString(f func(el uint32) string) []uint32 {
	result := make([]uint32, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint32) DedupByFloat32(f func(el uint32) float32) []uint32 {
	result := make([]uint32, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint32) DedupByFloat64(f func(el uint32) float64) []uint32 {
	result := make([]uint32, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint32) DedupByInt(f func(el uint32) int) []uint32 {
	result := make([]uint32, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint32) DedupByInt8(f func(el uint32) int8) []uint32 {
	result := make([]uint32, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint32) DedupByInt16(f func(el uint32) int16) []uint32 {
	result := make([]uint32, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint32) DedupByInt32(f func(el uint32) int32) []uint32 {
	result := make([]uint32, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint32) DedupByInt64(f func(el uint32) int64) []uint32 {
	result := make([]uint32, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint32) DedupByUint(f func(el uint32) uint) []uint32 {
	result := make([]uint32, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint32) DedupByUint8(f func(el uint32) uint8) []uint32 {
	result := make([]uint32, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint32) DedupByUint16(f func(el uint32) uint16) []uint32 {
	result := make([]uint32, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint32) DedupByUint32(f func(el uint32) uint32) []uint32 {
	result := make([]uint32, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint32) DedupByUint64(f func(el uint32) uint64) []uint32 {
	result := make([]uint32, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint32) DedupByInterface(f func(el uint32) interface{}) []uint32 {
	result := make([]uint32, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// Delete deletes the first occurence of the element from the slice
func (s SliceUint32) Delete(element uint32) []uint32 {
	result := make([]uint32, 0, len(s.Data)-1)
	deleted := false
	for _, el := range s.Data {
		if !deleted && el == element {
			continue
		}
		result = append(result, el)
	}
	return result

}

// DeleteAt returns the slice without elements on given positions
func (s SliceUint32) DeleteAt(index int) ([]uint32, error) {
	if index >= len(s.Data) {
		return s.Data, ErrOutOfRange
	}

	result := make([]uint32, 0, len(s.Data)-1)
	for i, el := range s.Data {
		if i != index {
			result = append(result, el)
		}
	}
	return result, nil
}

// DropEvery returns a slice of every nth element in the enumerable dropped,
// starting with the first element.
func (s SliceUint32) DropEvery(nth int) ([]uint32, error) {
	if nth <= 0 {
		return s.Data, ErrNonPositiveValue
	}
	result := make([]uint32, 0, len(s.Data)/nth)
	for i, el := range s.Data {
		if (i+1)%nth != 0 {
			result = append(result, el)
		}
	}
	return result, nil
}

// DropWhile drops elements from arr while f returns true
func (s SliceUint32) DropWhile(f func(arr uint32) bool) []uint32 {
	result := make([]uint32, 0, len(s.Data))
	for _, el := range s.Data {
		if !f(el) {
			return result
		}
		result = append(result, el)
	}
	return result
}

// Each calls f for every element from arr
func (s SliceUint32) Each(f func(el uint32)) {
	for _, el := range s.Data {
		f(el)
	}
}

// Equal returns true if slices are equal
func (s SliceUint32) Equal(other []uint32) bool {
	if len(s.Data) != len(other) {
		return false
	}
	for i, el := range other {
		if s.Data[i] != el {
			return false
		}
	}
	return true
}

// Filter returns slice of T for which F returned true
func (s SliceUint32) Filter(f func(el uint32) bool) []uint32 {
	result := make([]uint32, 0, len(s.Data))
	for _, el := range s.Data {
		if f(el) {
			result = append(result, el)
		}
	}
	return result
}

// Find returns the first element for which f returns true
func (s SliceUint32) Find(f func(el uint32) bool) (uint32, error) {
	for _, el := range s.Data {
		if f(el) {
			return el, nil
		}
	}
	var tmp uint32
	return tmp, ErrNotFound
}

// FindIndex is like Find, but return element index instead of element itself
func (s SliceUint32) FindIndex(f func(el uint32) bool) (int, error) {
	for i, el := range s.Data {
		if f(el) {
			return i, nil
		}
	}
	return 0, ErrNotFound
}

// Join concatenates elements of the slice to create a single string.
func (s SliceUint32) Join(sep string) string {
	strs := make([]string, 0, len(s.Data))
	for _, el := range s.Data {
		strs = append(strs, string(el))
	}
	return strings.Join(strs, sep)
}

// GroupBy groups element from array by value returned by f
func (s SliceUint32) GroupByBool(f func(el uint32) bool) map[bool][]uint32 {
	result := make(map[bool][]uint32)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint32, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint32) GroupByByte(f func(el uint32) byte) map[byte][]uint32 {
	result := make(map[byte][]uint32)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint32, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint32) GroupByString(f func(el uint32) string) map[string][]uint32 {
	result := make(map[string][]uint32)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint32, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint32) GroupByFloat32(f func(el uint32) float32) map[float32][]uint32 {
	result := make(map[float32][]uint32)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint32, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint32) GroupByFloat64(f func(el uint32) float64) map[float64][]uint32 {
	result := make(map[float64][]uint32)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint32, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint32) GroupByInt(f func(el uint32) int) map[int][]uint32 {
	result := make(map[int][]uint32)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint32, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint32) GroupByInt8(f func(el uint32) int8) map[int8][]uint32 {
	result := make(map[int8][]uint32)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint32, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint32) GroupByInt16(f func(el uint32) int16) map[int16][]uint32 {
	result := make(map[int16][]uint32)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint32, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint32) GroupByInt32(f func(el uint32) int32) map[int32][]uint32 {
	result := make(map[int32][]uint32)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint32, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint32) GroupByInt64(f func(el uint32) int64) map[int64][]uint32 {
	result := make(map[int64][]uint32)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint32, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint32) GroupByUint(f func(el uint32) uint) map[uint][]uint32 {
	result := make(map[uint][]uint32)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint32, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint32) GroupByUint8(f func(el uint32) uint8) map[uint8][]uint32 {
	result := make(map[uint8][]uint32)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint32, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint32) GroupByUint16(f func(el uint32) uint16) map[uint16][]uint32 {
	result := make(map[uint16][]uint32)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint32, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint32) GroupByUint32(f func(el uint32) uint32) map[uint32][]uint32 {
	result := make(map[uint32][]uint32)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint32, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint32) GroupByUint64(f func(el uint32) uint64) map[uint64][]uint32 {
	result := make(map[uint64][]uint32)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint32, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint32) GroupByInterface(f func(el uint32) interface{}) map[interface{}][]uint32 {
	result := make(map[interface{}][]uint32)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint32, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// InsertAt returns the slice with element inserted at given index.
func (s SliceUint32) InsertAt(index int, element uint32) ([]uint32, error) {
	result := make([]uint32, 0, len(s.Data)+1)

	// insert at the end
	if index == len(s.Data) || index == -1 {
		result = append(result, s.Data...)
		result = append(result, element)
		return result, nil
	}

	if index > len(s.Data) {
		return s.Data, ErrOutOfRange
	}
	if index < 0 {
		return s.Data, ErrNegativeValue
	}

	for i, el := range s.Data {
		if i == index {
			result = append(result, element)
		}
		result = append(result, el)
	}
	return result, nil
}

// Intersperse inserts el between each element of arr
func (s SliceUint32) Intersperse(el uint32) []uint32 {
	if len(s.Data) == 0 {
		return s.Data
	}
	result := make([]uint32, 0, len(s.Data)*2-1)
	result = append(result, s.Data[0])
	for _, val := range s.Data[1:] {
		result = append(result, el, val)
	}
	return result
}

// Last returns the last element from the slice
func (s SliceUint32) Last() (uint32, error) {
	if len(s.Data) == 0 {
		var tmp uint32
		return tmp, ErrEmpty
	}
	return s.Data[len(s.Data)-1], nil
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint32) MapBool(f func(el uint32) bool) []bool {
	result := make([]bool, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint32) MapByte(f func(el uint32) byte) []byte {
	result := make([]byte, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint32) MapString(f func(el uint32) string) []string {
	result := make([]string, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint32) MapFloat32(f func(el uint32) float32) []float32 {
	result := make([]float32, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint32) MapFloat64(f func(el uint32) float64) []float64 {
	result := make([]float64, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint32) MapInt(f func(el uint32) int) []int {
	result := make([]int, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint32) MapInt8(f func(el uint32) int8) []int8 {
	result := make([]int8, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint32) MapInt16(f func(el uint32) int16) []int16 {
	result := make([]int16, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint32) MapInt32(f func(el uint32) int32) []int32 {
	result := make([]int32, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint32) MapInt64(f func(el uint32) int64) []int64 {
	result := make([]int64, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint32) MapUint(f func(el uint32) uint) []uint {
	result := make([]uint, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint32) MapUint8(f func(el uint32) uint8) []uint8 {
	result := make([]uint8, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint32) MapUint16(f func(el uint32) uint16) []uint16 {
	result := make([]uint16, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint32) MapUint32(f func(el uint32) uint32) []uint32 {
	result := make([]uint32, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint32) MapUint64(f func(el uint32) uint64) []uint64 {
	result := make([]uint64, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint32) MapInterface(f func(el uint32) interface{}) []interface{} {
	result := make([]interface{}, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Max returns the maximal element from arr
func (s SliceUint32) Max() (uint32, error) {
	if len(s.Data) == 0 {
		var tmp uint32
		return tmp, ErrEmpty
	}

	max := s.Data[0]
	for _, el := range s.Data[1:] {
		if el > max {
			max = el
		}
	}
	return max, nil
}

// Min returns the minimal element from arr
func (s SliceUint32) Min() (uint32, error) {
	if len(s.Data) == 0 {
		var tmp uint32
		return tmp, ErrEmpty
	}

	min := s.Data[0]
	for _, el := range s.Data[1:] {
		if el < min {
			min = el
		}
	}
	return min, nil
}

// Permutations returns successive size-length permutations of elements from the slice.
// {1, 2, 3} -> {1, 2}, {1, 3}, {2, 1}, {2, 3}, {3, 1}, {3, 2}
func (s SliceUint32) Permutations(size int) chan []uint32 {
	c := make(chan []uint32, 1)
	go func() {
		if len(s.Data) > 0 {
			s.permutations(c, size, []uint32{}, s.Data)
		}
		close(c)
	}()
	return c
}

// permutations is a core implementation for Permutations
func (s SliceUint32) permutations(c chan []uint32, size int, left []uint32, right []uint32) {
	if len(left) == size || len(right) == 0 {
		c <- left
		return
	}

	for i, el := range right {
		newLeft := make([]uint32, 0, len(left)+1)
		newLeft = append(newLeft, left...)
		newLeft = append(newLeft, el)

		newRight := make([]uint32, 0, len(right)-1)
		for j, other := range right {
			if j != i {
				newRight = append(newRight, other)
			}
		}
		s.permutations(c, size, newLeft, newRight)
	}
}

// Product returns cortesian product of elements
// {{1, 2}, {3, 4}} -> {1, 3}, {1, 4}, {2, 3}, {2, 4}
func (s SliceUint32) Product(repeat int) chan []uint32 {
	c := make(chan []uint32, 1)
	go s.product(c, repeat, []uint32{}, 0)
	return c
}

// product is a core implementation for Product
func (s SliceUint32) product(c chan []uint32, repeat int, left []uint32, pos int) {
	// iterate over the last array
	if pos == repeat-1 {
		for _, el := range s.Data {
			result := make([]uint32, 0, len(left)+1)
			result = append(result, left...)
			result = append(result, el)
			c <- result
		}
		return
	}

	for _, el := range s.Data {
		result := make([]uint32, 0, len(left)+1)
		result = append(result, left...)
		result = append(result, el)
		s.product(c, repeat, result, pos+1)
	}

	if pos == 0 {
		close(c)
	}
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint32) ReduceBool(acc bool, f func(el uint32, acc bool) bool) bool {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint32) ReduceByte(acc byte, f func(el uint32, acc byte) byte) byte {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint32) ReduceString(acc string, f func(el uint32, acc string) string) string {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint32) ReduceFloat32(acc float32, f func(el uint32, acc float32) float32) float32 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint32) ReduceFloat64(acc float64, f func(el uint32, acc float64) float64) float64 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint32) ReduceInt(acc int, f func(el uint32, acc int) int) int {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint32) ReduceInt8(acc int8, f func(el uint32, acc int8) int8) int8 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint32) ReduceInt16(acc int16, f func(el uint32, acc int16) int16) int16 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint32) ReduceInt32(acc int32, f func(el uint32, acc int32) int32) int32 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint32) ReduceInt64(acc int64, f func(el uint32, acc int64) int64) int64 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint32) ReduceUint(acc uint, f func(el uint32, acc uint) uint) uint {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint32) ReduceUint8(acc uint8, f func(el uint32, acc uint8) uint8) uint8 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint32) ReduceUint16(acc uint16, f func(el uint32, acc uint16) uint16) uint16 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint32) ReduceUint32(acc uint32, f func(el uint32, acc uint32) uint32) uint32 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint32) ReduceUint64(acc uint64, f func(el uint32, acc uint64) uint64) uint64 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint32) ReduceInterface(acc interface{}, f func(el uint32, acc interface{}) interface{}) interface{} {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint32) ReduceWhileBool(acc bool, f func(el uint32, acc bool) (bool, error)) (bool, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint32) ReduceWhileByte(acc byte, f func(el uint32, acc byte) (byte, error)) (byte, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint32) ReduceWhileString(acc string, f func(el uint32, acc string) (string, error)) (string, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint32) ReduceWhileFloat32(acc float32, f func(el uint32, acc float32) (float32, error)) (float32, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint32) ReduceWhileFloat64(acc float64, f func(el uint32, acc float64) (float64, error)) (float64, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint32) ReduceWhileInt(acc int, f func(el uint32, acc int) (int, error)) (int, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint32) ReduceWhileInt8(acc int8, f func(el uint32, acc int8) (int8, error)) (int8, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint32) ReduceWhileInt16(acc int16, f func(el uint32, acc int16) (int16, error)) (int16, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint32) ReduceWhileInt32(acc int32, f func(el uint32, acc int32) (int32, error)) (int32, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint32) ReduceWhileInt64(acc int64, f func(el uint32, acc int64) (int64, error)) (int64, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint32) ReduceWhileUint(acc uint, f func(el uint32, acc uint) (uint, error)) (uint, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint32) ReduceWhileUint8(acc uint8, f func(el uint32, acc uint8) (uint8, error)) (uint8, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint32) ReduceWhileUint16(acc uint16, f func(el uint32, acc uint16) (uint16, error)) (uint16, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint32) ReduceWhileUint32(acc uint32, f func(el uint32, acc uint32) (uint32, error)) (uint32, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint32) ReduceWhileUint64(acc uint64, f func(el uint32, acc uint64) (uint64, error)) (uint64, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint32) ReduceWhileInterface(acc interface{}, f func(el uint32, acc interface{}) (interface{}, error)) (interface{}, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// Reverse returns given arr in reversed order
func (s SliceUint32) Reverse() []uint32 {
	if len(s.Data) <= 1 {
		return s.Data
	}
	result := make([]uint32, 0, len(s.Data))
	for i := len(s.Data) - 1; i >= 0; i-- {
		result = append(result, s.Data[i])
	}
	return result
}

// Same returns true if all element in arr the same
func (s SliceUint32) Same() bool {
	if len(s.Data) <= 1 {
		return true
	}
	for i := 0; i < len(s.Data)-1; i++ {
		if s.Data[i] != s.Data[i+1] {
			return false
		}
	}
	return true
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint32) ScanBool(acc bool, f func(el uint32, acc bool) bool) []bool {
	result := make([]bool, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint32) ScanByte(acc byte, f func(el uint32, acc byte) byte) []byte {
	result := make([]byte, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint32) ScanString(acc string, f func(el uint32, acc string) string) []string {
	result := make([]string, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint32) ScanFloat32(acc float32, f func(el uint32, acc float32) float32) []float32 {
	result := make([]float32, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint32) ScanFloat64(acc float64, f func(el uint32, acc float64) float64) []float64 {
	result := make([]float64, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint32) ScanInt(acc int, f func(el uint32, acc int) int) []int {
	result := make([]int, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint32) ScanInt8(acc int8, f func(el uint32, acc int8) int8) []int8 {
	result := make([]int8, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint32) ScanInt16(acc int16, f func(el uint32, acc int16) int16) []int16 {
	result := make([]int16, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint32) ScanInt32(acc int32, f func(el uint32, acc int32) int32) []int32 {
	result := make([]int32, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint32) ScanInt64(acc int64, f func(el uint32, acc int64) int64) []int64 {
	result := make([]int64, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint32) ScanUint(acc uint, f func(el uint32, acc uint) uint) []uint {
	result := make([]uint, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint32) ScanUint8(acc uint8, f func(el uint32, acc uint8) uint8) []uint8 {
	result := make([]uint8, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint32) ScanUint16(acc uint16, f func(el uint32, acc uint16) uint16) []uint16 {
	result := make([]uint16, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint32) ScanUint32(acc uint32, f func(el uint32, acc uint32) uint32) []uint32 {
	result := make([]uint32, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint32) ScanUint64(acc uint64, f func(el uint32, acc uint64) uint64) []uint64 {
	result := make([]uint64, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint32) ScanInterface(acc interface{}, f func(el uint32, acc interface{}) interface{}) []interface{} {
	result := make([]interface{}, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Shuffle in random order arr elements
func (s SliceUint32) Shuffle() []uint32 {
	if len(s.Data) <= 1 {
		return s.Data
	}
	rand.Seed(time.Now().UnixNano())
	swap := func(i, j int) {
		s.Data[i], s.Data[j] = s.Data[j], s.Data[i]
	}
	rand.Shuffle(len(s.Data), swap)
	return s.Data
}

// Sort returns sorted slice
func (s SliceUint32) Sort() []uint32 {
	if len(s.Data) <= 1 {
		return s.Data
	}
	less := func(i int, j int) bool {
		return s.Data[i] < s.Data[j]
	}
	sort.SliceStable(s.Data, less)
	return s.Data
}

// Sorted returns true if slice is sorted
func (s SliceUint32) Sorted() bool {
	if len(s.Data) <= 1 {
		return true
	}
	for i := 1; i < len(s.Data); i++ {
		if s.Data[i-1] > s.Data[i] {
			return false
		}
	}
	return true
}

// Split splits arr by sep
func (s SliceUint32) Split(sep uint32) [][]uint32 {
	result := make([][]uint32, 0)
	curr := make([]uint32, 0)
	for _, el := range s.Data {
		if el == sep {
			result = append(result, curr)
		} else {
			curr = append(curr, el)
		}
	}
	result = append(result, curr)
	return result
}

// StartsWith returns true if slice starts with the given prefix slice.
// If prefix is empty, it returns true.
func (s SliceUint32) StartsWith(prefix []uint32) bool {
	if len(prefix) > len(s.Data) {
		return false
	}
	for i, el := range prefix {
		if el != s.Data[i] {
			return false
		}
	}
	return true
}

// Sum return sum of all elements from arr
func (s SliceUint32) Sum() uint32 {
	var sum uint32
	for _, el := range s.Data {
		sum += el
	}
	return sum
}

// TakeEvery returns slice of every nth elements
func (s SliceUint32) TakeEvery(nth int) ([]uint32, error) {
	if nth <= 0 {
		return s.Data, ErrNonPositiveValue
	}
	result := make([]uint32, 0, len(s.Data))
	for i, el := range s.Data {
		if (i+1)%nth == 0 {
			result = append(result, el)
		}
	}
	return result, nil
}

// TakeRandom returns slice of count random elements from the slice
func (s SliceUint32) TakeRandom(count int) ([]uint32, error) {
	if count > len(s.Data) {
		return nil, ErrOutOfRange
	}
	if count <= 0 {
		return nil, ErrNonPositiveValue
	}

	rand.Seed(time.Now().UnixNano())
	swap := func(i, j int) {
		s.Data[i], s.Data[j] = s.Data[j], s.Data[i]
	}
	rand.Shuffle(len(s.Data), swap)
	return s.Data[:count], nil
}

// TakeWhile takes elements from arr while f returns true
func (s SliceUint32) TakeWhile(f func(el uint32) bool) []uint32 {
	result := make([]uint32, 0, len(s.Data))
	for _, el := range s.Data {
		if !f(el) {
			return result
		}
		result = append(result, el)
	}
	return result
}

// ToChannel returns channel with elements from the slice
func (s SliceUint32) ToChannel() chan uint32 {
	c := make(chan uint32, 1)
	go func() {
		for _, el := range s.Data {
			c <- el
		}
		close(c)
	}()
	return c
}

// Uniq returns arr with only first occurences of every element.
func (s SliceUint32) Uniq() []uint32 {
	if len(s.Data) <= 1 {
		return s.Data
	}
	added := make(map[uint32]struct{})
	nothing := struct{}{}
	result := make([]uint32, 0, len(s.Data))
	for _, el := range s.Data {
		_, exists := added[el]
		if !exists {
			result = append(result, el)
			added[el] = nothing
		}
	}
	return result

}

// Window makes sliding window for a given slice:
// ({1,2,3}, 2) -> (1,2), (2,3)
func (s SliceUint32) Window(size int) ([][]uint32, error) {
	if size <= 0 {
		return nil, ErrNonPositiveValue
	}
	result := make([][]uint32, 0, len(s.Data)/size)
	for i := 0; i <= len(s.Data)-size; i++ {
		chunk := s.Data[i : i+size]
		result = append(result, chunk)
	}
	return result, nil
}

// Without returns the slice with filtered out element
func (s SliceUint32) Without(elements ...uint32) []uint32 {
	result := make([]uint32, 0, len(s.Data))
	for _, el := range s.Data {
		allowed := true
		for _, other := range elements {
			if el == other {
				allowed = false
			}
		}
		if allowed {
			result = append(result, el)
		}
	}
	return result
}

// Concat concatenates given slices into a single slice.
func (s SlicesUint32) Concat() []uint32 {
	result := make([]uint32, 0)
	for _, arr := range s.Data {
		result = append(result, arr...)
	}
	return result
}

// Product returns cortesian product of elements
// {{1, 2}, {3, 4}} -> {1, 3}, {1, 4}, {2, 3}, {2, 4}
func (s SlicesUint32) Product() chan []uint32 {
	c := make(chan []uint32, 1)
	go s.product(c, []uint32{}, 0)
	return c
}

// product is a core implementation of Product
func (s SlicesUint32) product(c chan []uint32, left []uint32, pos int) {
	// iterate over the last array
	if pos == len(s.Data)-1 {
		for _, el := range s.Data[pos] {
			result := make([]uint32, 0, len(left)+1)
			result = append(result, left...)
			result = append(result, el)
			c <- result
		}
		return
	}

	for _, el := range s.Data[pos] {
		result := make([]uint32, 0, len(left)+1)
		result = append(result, left...)
		result = append(result, el)
		s.product(c, result, pos+1)
	}

	if pos == 0 {
		close(c)
	}
}

// Zip returns array of arrays of elements from given arrs
// on the same position
func (s SlicesUint32) Zip() [][]uint32 {
	size := len(s.Data[0])
	for _, arr := range s.Data[1:] {
		if len(arr) > size {
			size = len(arr)
		}
	}

	result := make([][]uint32, 0, size)
	for i := 0; i <= size; i++ {
		chunk := make([]uint32, 0, len(s.Data))
		for _, arr := range s.Data {
			chunk = append(chunk, arr[i])
		}
		result = append(result, chunk)
	}
	return result
}

// Channel is a set of operations with channel
type ChannelUint64 struct {
	Data chan uint64
}

// AsyncSlice is a set of operations to work with slice asynchronously
type AsyncSliceUint64 struct {
	Data    []uint64
	Workers int
}

// Sequence is a set of operations to generate sequences
type SequenceUint64 struct {
	ctx context.Context
}

// Pair is a set of functions for 2 values that you can pass into reduce-like funcs
type PairUint64 struct {
	// empty
}

// Slice is a set of operations to work with slice
type SliceUint64 struct {
	Data []uint64
}

// Slices is a set of operations to work with slice of slices
type SlicesUint64 struct {
	Data [][]uint64
}

// Any returns true if f returns true for any element in channel
func (c ChannelUint64) Any(f func(el uint64) bool) bool {
	for el := range c.Data {
		if f(el) {
			return true
		}
	}
	return false
}

// All returns true if f returns true for all elements in channel
func (c ChannelUint64) All(f func(el uint64) bool) bool {
	for el := range c.Data {
		if !f(el) {
			return false
		}
	}
	return true
}

// ChunkEvery returns channel with slices containing count elements each
func (c ChannelUint64) ChunkEvery(count int) chan []uint64 {
	chunks := make(chan []uint64, 1)
	go func() {
		chunk := make([]uint64, 0, count)
		i := 0
		for el := range c.Data {
			chunk = append(chunk, el)
			i++
			if i%count == 0 {
				i = 0
				chunks <- chunk
				chunk = make([]uint64, 0, count)
			}
		}
		if len(chunk) > 0 {
			chunks <- chunk
		}
		close(chunks)
	}()
	return chunks
}

// Count return count of el occurences in channel.
func (c ChannelUint64) Count(el uint64) int {
	count := 0
	for val := range c.Data {
		if val == el {
			count++
		}
	}
	return count
}

// Drop drops first n elements from channel c and returns a new channel with the rest.
// It returns channel do be unblocking. If you want array instead, wrap result into TakeAll.
func (c ChannelUint64) Drop(n int) chan uint64 {
	result := make(chan uint64, 1)
	go func() {
		i := 0
		for el := range c.Data {
			if i >= n {
				result <- el
			}
			i++
		}
		close(result)
	}()
	return result
}

// Each calls f for every element in the channel
func (c ChannelUint64) Each(f func(el uint64)) {
	for el := range c.Data {
		f(el)
	}
}

// Filter returns a new channel with elements from input channel
// for which f returns true
func (c ChannelUint64) Filter(f func(el uint64) bool) chan uint64 {
	result := make(chan uint64, 1)
	go func() {
		for el := range c.Data {
			if f(el) {
				result <- el
			}
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint64) MapBool(f func(el uint64) bool) chan bool {
	result := make(chan bool, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint64) MapByte(f func(el uint64) byte) chan byte {
	result := make(chan byte, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint64) MapString(f func(el uint64) string) chan string {
	result := make(chan string, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint64) MapFloat32(f func(el uint64) float32) chan float32 {
	result := make(chan float32, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint64) MapFloat64(f func(el uint64) float64) chan float64 {
	result := make(chan float64, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint64) MapInt(f func(el uint64) int) chan int {
	result := make(chan int, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint64) MapInt8(f func(el uint64) int8) chan int8 {
	result := make(chan int8, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint64) MapInt16(f func(el uint64) int16) chan int16 {
	result := make(chan int16, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint64) MapInt32(f func(el uint64) int32) chan int32 {
	result := make(chan int32, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint64) MapInt64(f func(el uint64) int64) chan int64 {
	result := make(chan int64, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint64) MapUint(f func(el uint64) uint) chan uint {
	result := make(chan uint, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint64) MapUint8(f func(el uint64) uint8) chan uint8 {
	result := make(chan uint8, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint64) MapUint16(f func(el uint64) uint16) chan uint16 {
	result := make(chan uint16, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint64) MapUint32(f func(el uint64) uint32) chan uint32 {
	result := make(chan uint32, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint64) MapUint64(f func(el uint64) uint64) chan uint64 {
	result := make(chan uint64, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelUint64) MapInterface(f func(el uint64) interface{}) chan interface{} {
	result := make(chan interface{}, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Max returns the maximal element from channel
func (c ChannelUint64) Max() (uint64, error) {
	max, ok := <-c.Data
	if !ok {
		return max, ErrEmpty
	}
	for el := range c.Data {
		if el > max {
			max = el
		}
	}
	return max, nil
}

// Min returns the minimal element from channel
func (c ChannelUint64) Min() (uint64, error) {
	min, ok := <-c.Data
	if !ok {
		return min, ErrEmpty
	}
	for el := range c.Data {
		if el < min {
			min = el
		}
	}
	return min, nil
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint64) ReduceBool(acc bool, f func(el uint64, acc bool) bool) bool {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint64) ReduceByte(acc byte, f func(el uint64, acc byte) byte) byte {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint64) ReduceString(acc string, f func(el uint64, acc string) string) string {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint64) ReduceFloat32(acc float32, f func(el uint64, acc float32) float32) float32 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint64) ReduceFloat64(acc float64, f func(el uint64, acc float64) float64) float64 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint64) ReduceInt(acc int, f func(el uint64, acc int) int) int {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint64) ReduceInt8(acc int8, f func(el uint64, acc int8) int8) int8 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint64) ReduceInt16(acc int16, f func(el uint64, acc int16) int16) int16 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint64) ReduceInt32(acc int32, f func(el uint64, acc int32) int32) int32 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint64) ReduceInt64(acc int64, f func(el uint64, acc int64) int64) int64 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint64) ReduceUint(acc uint, f func(el uint64, acc uint) uint) uint {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint64) ReduceUint8(acc uint8, f func(el uint64, acc uint8) uint8) uint8 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint64) ReduceUint16(acc uint16, f func(el uint64, acc uint16) uint16) uint16 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint64) ReduceUint32(acc uint32, f func(el uint64, acc uint32) uint32) uint32 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint64) ReduceUint64(acc uint64, f func(el uint64, acc uint64) uint64) uint64 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelUint64) ReduceInterface(acc interface{}, f func(el uint64, acc interface{}) interface{}) interface{} {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint64) ScanBool(acc bool, f func(el uint64, acc bool) bool) chan bool {
	result := make(chan bool, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint64) ScanByte(acc byte, f func(el uint64, acc byte) byte) chan byte {
	result := make(chan byte, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint64) ScanString(acc string, f func(el uint64, acc string) string) chan string {
	result := make(chan string, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint64) ScanFloat32(acc float32, f func(el uint64, acc float32) float32) chan float32 {
	result := make(chan float32, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint64) ScanFloat64(acc float64, f func(el uint64, acc float64) float64) chan float64 {
	result := make(chan float64, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint64) ScanInt(acc int, f func(el uint64, acc int) int) chan int {
	result := make(chan int, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint64) ScanInt8(acc int8, f func(el uint64, acc int8) int8) chan int8 {
	result := make(chan int8, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint64) ScanInt16(acc int16, f func(el uint64, acc int16) int16) chan int16 {
	result := make(chan int16, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint64) ScanInt32(acc int32, f func(el uint64, acc int32) int32) chan int32 {
	result := make(chan int32, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint64) ScanInt64(acc int64, f func(el uint64, acc int64) int64) chan int64 {
	result := make(chan int64, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint64) ScanUint(acc uint, f func(el uint64, acc uint) uint) chan uint {
	result := make(chan uint, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint64) ScanUint8(acc uint8, f func(el uint64, acc uint8) uint8) chan uint8 {
	result := make(chan uint8, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint64) ScanUint16(acc uint16, f func(el uint64, acc uint16) uint16) chan uint16 {
	result := make(chan uint16, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint64) ScanUint32(acc uint32, f func(el uint64, acc uint32) uint32) chan uint32 {
	result := make(chan uint32, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint64) ScanUint64(acc uint64, f func(el uint64, acc uint64) uint64) chan uint64 {
	result := make(chan uint64, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelUint64) ScanInterface(acc interface{}, f func(el uint64, acc interface{}) interface{}) chan interface{} {
	result := make(chan interface{}, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Sum returns sum of all elements from channel
func (c ChannelUint64) Sum() uint64 {
	var sum uint64
	for el := range c.Data {
		sum += el
	}
	return sum
}

// Take takes first count elements from the channel.
func (c ChannelUint64) Take(count int) chan uint64 {
	result := make(chan uint64, 1)
	go func() {
		defer close(result)
		if count <= 0 {
			return
		}
		i := 0
		for el := range c.Data {
			result <- el
			i++
			if i == count {
				return
			}
		}
	}()
	return result
}

// Tee returns 2 channels with elements from the input channel
func (c ChannelUint64) Tee(count int) []chan uint64 {
	channels := make([]chan uint64, 0, count)
	for i := 0; i < count; i++ {
		channels = append(channels, make(chan uint64, 1))
	}
	go func() {
		for el := range c.Data {
			wg := sync.WaitGroup{}
			putInto := func(ch chan uint64) {
				defer wg.Done()
				ch <- el
			}
			wg.Add(count)
			for _, ch := range channels {
				putInto(ch)
			}
			wg.Wait()
		}
		for _, ch := range channels {
			close(ch)
		}
	}()
	return channels
}

// ToSlice returns slice with all elements from channel.
func (c ChannelUint64) ToSlice() []uint64 {
	result := make([]uint64, 0)
	for val := range c.Data {
		result = append(result, val)
	}
	return result
}

// All returns true if f returns true for all elements in slice
func (s AsyncSliceUint64) All(f func(el uint64) bool) bool {
	if len(s.Data) == 0 {
		return true
	}

	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int, result chan<- bool, ctx context.Context) {
		defer wg.Done()
		for {
			select {
			case <-ctx.Done():
				return
			case index, ok := <-jobs:
				if !ok {
					return
				}
				if !f(s.Data[index]) {
					result <- false
					return
				}
			}
		}
	}

	ctx, cancel := context.WithCancel(context.Background())
	// when we're returning the result, cancel all workers
	defer cancel()

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	result := make(chan bool, workers)
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs, result, ctx)
	}

	// close the result channel when all workers have done
	go func() {
		wg.Wait()
		close(result)
	}()

	// schedule the jobs: indices to check
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)

	for range result {
		return false
	}
	return true
}

// Any returns true if f returns true for any element from slice
func (s AsyncSliceUint64) Any(f func(el uint64) bool) bool {
	if len(s.Data) == 0 {
		return false
	}

	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int, result chan<- bool, ctx context.Context) {
		defer wg.Done()
		for {
			select {
			case <-ctx.Done():
				return
			case index, ok := <-jobs:
				if !ok {
					return
				}
				if f(s.Data[index]) {
					result <- true
					return
				}
			}
		}
	}

	ctx, cancel := context.WithCancel(context.Background())
	// when we're returning the result, cancel all workers
	defer cancel()

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	result := make(chan bool, workers)
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs, result, ctx)
	}

	// close the result channel when all workers have done
	go func() {
		wg.Wait()
		close(result)
	}()

	// schedule the jobs: indices to check
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)

	for range result {
		return true
	}
	return false
}

// Each calls f for every element from slice
func (s AsyncSliceUint64) Each(f func(el uint64)) {
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		defer wg.Done()
		for index := range jobs {
			f(s.Data[index])
		}
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
}

// Filter returns slice of element for which f returns true
func (s AsyncSliceUint64) Filter(f func(el uint64) bool) []uint64 {
	resultMap := make([]bool, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			if f(s.Data[index]) {
				resultMap[index] = true
			}
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()

	// return filtered results
	result := make([]uint64, 0, len(s.Data))
	for i, el := range s.Data {
		if resultMap[i] {
			result = append(result, el)
		}
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint64) MapBool(f func(el uint64) bool) []bool {
	result := make([]bool, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint64) MapByte(f func(el uint64) byte) []byte {
	result := make([]byte, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint64) MapString(f func(el uint64) string) []string {
	result := make([]string, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint64) MapFloat32(f func(el uint64) float32) []float32 {
	result := make([]float32, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint64) MapFloat64(f func(el uint64) float64) []float64 {
	result := make([]float64, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint64) MapInt(f func(el uint64) int) []int {
	result := make([]int, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint64) MapInt8(f func(el uint64) int8) []int8 {
	result := make([]int8, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint64) MapInt16(f func(el uint64) int16) []int16 {
	result := make([]int16, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint64) MapInt32(f func(el uint64) int32) []int32 {
	result := make([]int32, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint64) MapInt64(f func(el uint64) int64) []int64 {
	result := make([]int64, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint64) MapUint(f func(el uint64) uint) []uint {
	result := make([]uint, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint64) MapUint8(f func(el uint64) uint8) []uint8 {
	result := make([]uint8, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint64) MapUint16(f func(el uint64) uint16) []uint16 {
	result := make([]uint16, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint64) MapUint32(f func(el uint64) uint32) []uint32 {
	result := make([]uint32, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint64) MapUint64(f func(el uint64) uint64) []uint64 {
	result := make([]uint64, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceUint64) MapInterface(f func(el uint64) interface{}) []interface{} {
	result := make([]interface{}, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Reduce reduces slice to a single value with f
func (s AsyncSliceUint64) Reduce(f func(left uint64, right uint64) uint64) uint64 {
	if len(s.Data) == 0 {
		var tmp uint64
		return tmp
	}

	state := make([]uint64, len(s.Data))
	state = append(state, s.Data...)
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int, result chan<- uint64) {
		for index := range jobs {
			result <- f(state[index], state[index+1])
		}
		wg.Done()
	}

	for len(state) > 1 {
		// calculate workers count
		workers := s.Workers
		if workers == 0 || workers > len(state) {
			workers = len(state)
		}

		// run workers
		jobs := make(chan int, len(state))
		wg.Add(workers)
		result := make(chan uint64, 1)
		for i := 0; i < workers; i++ {
			go worker(jobs, result)
		}

		go func() {
			wg.Wait()
			close(result)
		}()

		// add indices into jobs for workers
		for i := 0; i < len(state)-1; i += 2 {
			jobs <- i
		}
		close(jobs)

		// collect new state
		newState := make([]uint64, 0, len(state)/2+len(state)%2)
		for el := range result {
			newState = append(newState, el)
		}
		if len(state)%2 == 1 {
			newState = append(newState, state[len(state)-1])
		}
		// put new state as current state after all
		state = newState
	}

	return state[0]
}

// Count is like Range, but infinite
func (s SequenceUint64) Count(start uint64, step uint64) chan uint64 {
	c := make(chan uint64, 1)
	go func() {
		defer close(c)
		for {
			select {
			case <-s.ctx.Done():
				return
			case c <- start:
				start += step
			}
		}
	}()
	return c
}

// Exponential generates elements from start with
// multiplication of value on factor on every step
func (s SequenceUint64) Exponential(start uint64, factor uint64) chan uint64 {
	c := make(chan uint64, 1)
	go func() {
		defer close(c)
		for {
			select {
			case <-s.ctx.Done():
				return
			case c <- start:
				start *= factor
			}
		}
	}()
	return c
}

// Iterate returns an infinite list of repeated applications of f to val
func (s SequenceUint64) Iterate(val uint64, f func(val uint64) uint64) chan uint64 {
	c := make(chan uint64, 1)
	go func() {
		defer close(c)
		for {
			select {
			case <-s.ctx.Done():
				return
			case c <- val:
				val = f(val)
			}
		}
	}()
	return c
}

// Range generates elements from start to end with given step
func (s SequenceUint64) Range(start uint64, end uint64, step uint64) chan uint64 {
	c := make(chan uint64, 1)
	pos := start <= end
	go func() {
		for pos && (start < end) || !pos && (start > end) {
			c <- start
			start += step
		}
		close(c)
	}()
	return c
}

// Repeat returns channel that produces val infinite times
func (s SequenceUint64) Repeat(val uint64) chan uint64 {
	c := make(chan uint64, 1)
	go func() {
		defer close(c)
		for {
			select {
			case <-s.ctx.Done():
				return
			case c <- val:
				continue
			}
		}
	}()
	return c
}

// Replicate returns channel that produces val n times
func (s SequenceUint64) Replicate(val uint64, n int) chan uint64 {
	c := make(chan uint64, 1)
	go func() {
		for i := 0; i < n; i++ {
			c <- val
		}
		close(c)
	}()
	return c
}

// Min returns minimal value
func (PairUint64) Min(a uint64, b uint64) uint64 {
	if a <= b {
		return a
	}
	return b
}

// Max returns maximal value
func (PairUint64) Max(a uint64, b uint64) uint64 {
	if a > b {
		return a
	}
	return b
}

// Any returns true if f returns true for any element in arr
func (s SliceUint64) Any(f func(el uint64) bool) bool {
	for _, el := range s.Data {
		if f(el) {
			return true
		}
	}
	return false
}

// All returns true if f returns true for all elements in arr
func (s SliceUint64) All(f func(el uint64) bool) bool {
	for _, el := range s.Data {
		if !f(el) {
			return false
		}
	}
	return true
}

// Choice chooses a random element from the slice
func (s SliceUint64) Choice() (uint64, error) {
	if len(s.Data) == 0 {
		var tmp uint64
		return tmp, ErrEmpty
	}

	rand.Seed(time.Now().UnixNano())
	i := rand.Intn(len(s.Data))
	return s.Data[i], nil
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint64) ChunkByBool(f func(el uint64) bool) [][]uint64 {
	chunks := make([][]uint64, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint64, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint64, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint64) ChunkByByte(f func(el uint64) byte) [][]uint64 {
	chunks := make([][]uint64, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint64, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint64, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint64) ChunkByString(f func(el uint64) string) [][]uint64 {
	chunks := make([][]uint64, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint64, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint64, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint64) ChunkByFloat32(f func(el uint64) float32) [][]uint64 {
	chunks := make([][]uint64, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint64, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint64, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint64) ChunkByFloat64(f func(el uint64) float64) [][]uint64 {
	chunks := make([][]uint64, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint64, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint64, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint64) ChunkByInt(f func(el uint64) int) [][]uint64 {
	chunks := make([][]uint64, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint64, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint64, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint64) ChunkByInt8(f func(el uint64) int8) [][]uint64 {
	chunks := make([][]uint64, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint64, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint64, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint64) ChunkByInt16(f func(el uint64) int16) [][]uint64 {
	chunks := make([][]uint64, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint64, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint64, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint64) ChunkByInt32(f func(el uint64) int32) [][]uint64 {
	chunks := make([][]uint64, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint64, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint64, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint64) ChunkByInt64(f func(el uint64) int64) [][]uint64 {
	chunks := make([][]uint64, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint64, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint64, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint64) ChunkByUint(f func(el uint64) uint) [][]uint64 {
	chunks := make([][]uint64, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint64, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint64, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint64) ChunkByUint8(f func(el uint64) uint8) [][]uint64 {
	chunks := make([][]uint64, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint64, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint64, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint64) ChunkByUint16(f func(el uint64) uint16) [][]uint64 {
	chunks := make([][]uint64, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint64, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint64, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint64) ChunkByUint32(f func(el uint64) uint32) [][]uint64 {
	chunks := make([][]uint64, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint64, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint64, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint64) ChunkByUint64(f func(el uint64) uint64) [][]uint64 {
	chunks := make([][]uint64, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint64, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint64, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceUint64) ChunkByInterface(f func(el uint64) interface{}) [][]uint64 {
	chunks := make([][]uint64, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]uint64, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]uint64, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkEvery returns slice of slices containing count elements each
func (s SliceUint64) ChunkEvery(count int) ([][]uint64, error) {
	chunks := make([][]uint64, 0)
	if count <= 0 {
		return chunks, ErrNegativeValue
	}
	chunk := make([]uint64, 0, count)
	for i, el := range s.Data {
		chunk = append(chunk, el)
		if (i+1)%count == 0 {
			chunks = append(chunks, chunk)
			chunk = make([]uint64, 0, count)
		}
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks, nil
}

// Contains returns true if el in arr.
func (s SliceUint64) Contains(el uint64) bool {
	for _, val := range s.Data {
		if val == el {
			return true
		}
	}
	return false
}

// Count return count of el occurences in arr.
func (s SliceUint64) Count(el uint64) int {
	count := 0
	for _, val := range s.Data {
		if val == el {
			count++
		}
	}
	return count
}

// CountBy returns how many times f returns true.
func (s SliceUint64) CountBy(f func(el uint64) bool) int {
	count := 0
	for _, el := range s.Data {
		if f(el) {
			count++
		}
	}
	return count
}

// Cycle is an infinite loop over slice
func (s SliceUint64) Cycle() chan uint64 {
	c := make(chan uint64, 1)
	go func() {
		defer close(c)
		if len(s.Data) == 0 {
			return
		}
		for {
			for _, val := range s.Data {
				c <- val
			}
		}
	}()
	return c
}

// Dedup returns a given slice without consecutive duplicated elements
func (s SliceUint64) Dedup() []uint64 {
	if len(s.Data) == 0 {
		return s.Data
	}

	result := make([]uint64, 0, len(s.Data))
	prev := s.Data[0]
	result = append(result, prev)
	for _, el := range s.Data[1:] {
		if el != prev {
			result = append(result, el)
			prev = el
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint64) DedupByBool(f func(el uint64) bool) []uint64 {
	result := make([]uint64, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint64) DedupByByte(f func(el uint64) byte) []uint64 {
	result := make([]uint64, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint64) DedupByString(f func(el uint64) string) []uint64 {
	result := make([]uint64, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint64) DedupByFloat32(f func(el uint64) float32) []uint64 {
	result := make([]uint64, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint64) DedupByFloat64(f func(el uint64) float64) []uint64 {
	result := make([]uint64, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint64) DedupByInt(f func(el uint64) int) []uint64 {
	result := make([]uint64, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint64) DedupByInt8(f func(el uint64) int8) []uint64 {
	result := make([]uint64, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint64) DedupByInt16(f func(el uint64) int16) []uint64 {
	result := make([]uint64, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint64) DedupByInt32(f func(el uint64) int32) []uint64 {
	result := make([]uint64, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint64) DedupByInt64(f func(el uint64) int64) []uint64 {
	result := make([]uint64, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint64) DedupByUint(f func(el uint64) uint) []uint64 {
	result := make([]uint64, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint64) DedupByUint8(f func(el uint64) uint8) []uint64 {
	result := make([]uint64, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint64) DedupByUint16(f func(el uint64) uint16) []uint64 {
	result := make([]uint64, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint64) DedupByUint32(f func(el uint64) uint32) []uint64 {
	result := make([]uint64, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint64) DedupByUint64(f func(el uint64) uint64) []uint64 {
	result := make([]uint64, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceUint64) DedupByInterface(f func(el uint64) interface{}) []uint64 {
	result := make([]uint64, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// Delete deletes the first occurence of the element from the slice
func (s SliceUint64) Delete(element uint64) []uint64 {
	result := make([]uint64, 0, len(s.Data)-1)
	deleted := false
	for _, el := range s.Data {
		if !deleted && el == element {
			continue
		}
		result = append(result, el)
	}
	return result

}

// DeleteAt returns the slice without elements on given positions
func (s SliceUint64) DeleteAt(index int) ([]uint64, error) {
	if index >= len(s.Data) {
		return s.Data, ErrOutOfRange
	}

	result := make([]uint64, 0, len(s.Data)-1)
	for i, el := range s.Data {
		if i != index {
			result = append(result, el)
		}
	}
	return result, nil
}

// DropEvery returns a slice of every nth element in the enumerable dropped,
// starting with the first element.
func (s SliceUint64) DropEvery(nth int) ([]uint64, error) {
	if nth <= 0 {
		return s.Data, ErrNonPositiveValue
	}
	result := make([]uint64, 0, len(s.Data)/nth)
	for i, el := range s.Data {
		if (i+1)%nth != 0 {
			result = append(result, el)
		}
	}
	return result, nil
}

// DropWhile drops elements from arr while f returns true
func (s SliceUint64) DropWhile(f func(arr uint64) bool) []uint64 {
	result := make([]uint64, 0, len(s.Data))
	for _, el := range s.Data {
		if !f(el) {
			return result
		}
		result = append(result, el)
	}
	return result
}

// Each calls f for every element from arr
func (s SliceUint64) Each(f func(el uint64)) {
	for _, el := range s.Data {
		f(el)
	}
}

// Equal returns true if slices are equal
func (s SliceUint64) Equal(other []uint64) bool {
	if len(s.Data) != len(other) {
		return false
	}
	for i, el := range other {
		if s.Data[i] != el {
			return false
		}
	}
	return true
}

// Filter returns slice of T for which F returned true
func (s SliceUint64) Filter(f func(el uint64) bool) []uint64 {
	result := make([]uint64, 0, len(s.Data))
	for _, el := range s.Data {
		if f(el) {
			result = append(result, el)
		}
	}
	return result
}

// Find returns the first element for which f returns true
func (s SliceUint64) Find(f func(el uint64) bool) (uint64, error) {
	for _, el := range s.Data {
		if f(el) {
			return el, nil
		}
	}
	var tmp uint64
	return tmp, ErrNotFound
}

// FindIndex is like Find, but return element index instead of element itself
func (s SliceUint64) FindIndex(f func(el uint64) bool) (int, error) {
	for i, el := range s.Data {
		if f(el) {
			return i, nil
		}
	}
	return 0, ErrNotFound
}

// Join concatenates elements of the slice to create a single string.
func (s SliceUint64) Join(sep string) string {
	strs := make([]string, 0, len(s.Data))
	for _, el := range s.Data {
		strs = append(strs, string(el))
	}
	return strings.Join(strs, sep)
}

// GroupBy groups element from array by value returned by f
func (s SliceUint64) GroupByBool(f func(el uint64) bool) map[bool][]uint64 {
	result := make(map[bool][]uint64)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint64, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint64) GroupByByte(f func(el uint64) byte) map[byte][]uint64 {
	result := make(map[byte][]uint64)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint64, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint64) GroupByString(f func(el uint64) string) map[string][]uint64 {
	result := make(map[string][]uint64)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint64, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint64) GroupByFloat32(f func(el uint64) float32) map[float32][]uint64 {
	result := make(map[float32][]uint64)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint64, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint64) GroupByFloat64(f func(el uint64) float64) map[float64][]uint64 {
	result := make(map[float64][]uint64)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint64, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint64) GroupByInt(f func(el uint64) int) map[int][]uint64 {
	result := make(map[int][]uint64)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint64, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint64) GroupByInt8(f func(el uint64) int8) map[int8][]uint64 {
	result := make(map[int8][]uint64)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint64, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint64) GroupByInt16(f func(el uint64) int16) map[int16][]uint64 {
	result := make(map[int16][]uint64)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint64, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint64) GroupByInt32(f func(el uint64) int32) map[int32][]uint64 {
	result := make(map[int32][]uint64)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint64, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint64) GroupByInt64(f func(el uint64) int64) map[int64][]uint64 {
	result := make(map[int64][]uint64)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint64, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint64) GroupByUint(f func(el uint64) uint) map[uint][]uint64 {
	result := make(map[uint][]uint64)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint64, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint64) GroupByUint8(f func(el uint64) uint8) map[uint8][]uint64 {
	result := make(map[uint8][]uint64)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint64, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint64) GroupByUint16(f func(el uint64) uint16) map[uint16][]uint64 {
	result := make(map[uint16][]uint64)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint64, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint64) GroupByUint32(f func(el uint64) uint32) map[uint32][]uint64 {
	result := make(map[uint32][]uint64)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint64, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint64) GroupByUint64(f func(el uint64) uint64) map[uint64][]uint64 {
	result := make(map[uint64][]uint64)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint64, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceUint64) GroupByInterface(f func(el uint64) interface{}) map[interface{}][]uint64 {
	result := make(map[interface{}][]uint64)
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]uint64, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// InsertAt returns the slice with element inserted at given index.
func (s SliceUint64) InsertAt(index int, element uint64) ([]uint64, error) {
	result := make([]uint64, 0, len(s.Data)+1)

	// insert at the end
	if index == len(s.Data) || index == -1 {
		result = append(result, s.Data...)
		result = append(result, element)
		return result, nil
	}

	if index > len(s.Data) {
		return s.Data, ErrOutOfRange
	}
	if index < 0 {
		return s.Data, ErrNegativeValue
	}

	for i, el := range s.Data {
		if i == index {
			result = append(result, element)
		}
		result = append(result, el)
	}
	return result, nil
}

// Intersperse inserts el between each element of arr
func (s SliceUint64) Intersperse(el uint64) []uint64 {
	if len(s.Data) == 0 {
		return s.Data
	}
	result := make([]uint64, 0, len(s.Data)*2-1)
	result = append(result, s.Data[0])
	for _, val := range s.Data[1:] {
		result = append(result, el, val)
	}
	return result
}

// Last returns the last element from the slice
func (s SliceUint64) Last() (uint64, error) {
	if len(s.Data) == 0 {
		var tmp uint64
		return tmp, ErrEmpty
	}
	return s.Data[len(s.Data)-1], nil
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint64) MapBool(f func(el uint64) bool) []bool {
	result := make([]bool, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint64) MapByte(f func(el uint64) byte) []byte {
	result := make([]byte, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint64) MapString(f func(el uint64) string) []string {
	result := make([]string, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint64) MapFloat32(f func(el uint64) float32) []float32 {
	result := make([]float32, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint64) MapFloat64(f func(el uint64) float64) []float64 {
	result := make([]float64, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint64) MapInt(f func(el uint64) int) []int {
	result := make([]int, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint64) MapInt8(f func(el uint64) int8) []int8 {
	result := make([]int8, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint64) MapInt16(f func(el uint64) int16) []int16 {
	result := make([]int16, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint64) MapInt32(f func(el uint64) int32) []int32 {
	result := make([]int32, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint64) MapInt64(f func(el uint64) int64) []int64 {
	result := make([]int64, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint64) MapUint(f func(el uint64) uint) []uint {
	result := make([]uint, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint64) MapUint8(f func(el uint64) uint8) []uint8 {
	result := make([]uint8, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint64) MapUint16(f func(el uint64) uint16) []uint16 {
	result := make([]uint16, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint64) MapUint32(f func(el uint64) uint32) []uint32 {
	result := make([]uint32, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint64) MapUint64(f func(el uint64) uint64) []uint64 {
	result := make([]uint64, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceUint64) MapInterface(f func(el uint64) interface{}) []interface{} {
	result := make([]interface{}, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Max returns the maximal element from arr
func (s SliceUint64) Max() (uint64, error) {
	if len(s.Data) == 0 {
		var tmp uint64
		return tmp, ErrEmpty
	}

	max := s.Data[0]
	for _, el := range s.Data[1:] {
		if el > max {
			max = el
		}
	}
	return max, nil
}

// Min returns the minimal element from arr
func (s SliceUint64) Min() (uint64, error) {
	if len(s.Data) == 0 {
		var tmp uint64
		return tmp, ErrEmpty
	}

	min := s.Data[0]
	for _, el := range s.Data[1:] {
		if el < min {
			min = el
		}
	}
	return min, nil
}

// Permutations returns successive size-length permutations of elements from the slice.
// {1, 2, 3} -> {1, 2}, {1, 3}, {2, 1}, {2, 3}, {3, 1}, {3, 2}
func (s SliceUint64) Permutations(size int) chan []uint64 {
	c := make(chan []uint64, 1)
	go func() {
		if len(s.Data) > 0 {
			s.permutations(c, size, []uint64{}, s.Data)
		}
		close(c)
	}()
	return c
}

// permutations is a core implementation for Permutations
func (s SliceUint64) permutations(c chan []uint64, size int, left []uint64, right []uint64) {
	if len(left) == size || len(right) == 0 {
		c <- left
		return
	}

	for i, el := range right {
		newLeft := make([]uint64, 0, len(left)+1)
		newLeft = append(newLeft, left...)
		newLeft = append(newLeft, el)

		newRight := make([]uint64, 0, len(right)-1)
		for j, other := range right {
			if j != i {
				newRight = append(newRight, other)
			}
		}
		s.permutations(c, size, newLeft, newRight)
	}
}

// Product returns cortesian product of elements
// {{1, 2}, {3, 4}} -> {1, 3}, {1, 4}, {2, 3}, {2, 4}
func (s SliceUint64) Product(repeat int) chan []uint64 {
	c := make(chan []uint64, 1)
	go s.product(c, repeat, []uint64{}, 0)
	return c
}

// product is a core implementation for Product
func (s SliceUint64) product(c chan []uint64, repeat int, left []uint64, pos int) {
	// iterate over the last array
	if pos == repeat-1 {
		for _, el := range s.Data {
			result := make([]uint64, 0, len(left)+1)
			result = append(result, left...)
			result = append(result, el)
			c <- result
		}
		return
	}

	for _, el := range s.Data {
		result := make([]uint64, 0, len(left)+1)
		result = append(result, left...)
		result = append(result, el)
		s.product(c, repeat, result, pos+1)
	}

	if pos == 0 {
		close(c)
	}
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint64) ReduceBool(acc bool, f func(el uint64, acc bool) bool) bool {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint64) ReduceByte(acc byte, f func(el uint64, acc byte) byte) byte {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint64) ReduceString(acc string, f func(el uint64, acc string) string) string {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint64) ReduceFloat32(acc float32, f func(el uint64, acc float32) float32) float32 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint64) ReduceFloat64(acc float64, f func(el uint64, acc float64) float64) float64 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint64) ReduceInt(acc int, f func(el uint64, acc int) int) int {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint64) ReduceInt8(acc int8, f func(el uint64, acc int8) int8) int8 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint64) ReduceInt16(acc int16, f func(el uint64, acc int16) int16) int16 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint64) ReduceInt32(acc int32, f func(el uint64, acc int32) int32) int32 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint64) ReduceInt64(acc int64, f func(el uint64, acc int64) int64) int64 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint64) ReduceUint(acc uint, f func(el uint64, acc uint) uint) uint {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint64) ReduceUint8(acc uint8, f func(el uint64, acc uint8) uint8) uint8 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint64) ReduceUint16(acc uint16, f func(el uint64, acc uint16) uint16) uint16 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint64) ReduceUint32(acc uint32, f func(el uint64, acc uint32) uint32) uint32 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint64) ReduceUint64(acc uint64, f func(el uint64, acc uint64) uint64) uint64 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceUint64) ReduceInterface(acc interface{}, f func(el uint64, acc interface{}) interface{}) interface{} {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint64) ReduceWhileBool(acc bool, f func(el uint64, acc bool) (bool, error)) (bool, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint64) ReduceWhileByte(acc byte, f func(el uint64, acc byte) (byte, error)) (byte, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint64) ReduceWhileString(acc string, f func(el uint64, acc string) (string, error)) (string, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint64) ReduceWhileFloat32(acc float32, f func(el uint64, acc float32) (float32, error)) (float32, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint64) ReduceWhileFloat64(acc float64, f func(el uint64, acc float64) (float64, error)) (float64, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint64) ReduceWhileInt(acc int, f func(el uint64, acc int) (int, error)) (int, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint64) ReduceWhileInt8(acc int8, f func(el uint64, acc int8) (int8, error)) (int8, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint64) ReduceWhileInt16(acc int16, f func(el uint64, acc int16) (int16, error)) (int16, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint64) ReduceWhileInt32(acc int32, f func(el uint64, acc int32) (int32, error)) (int32, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint64) ReduceWhileInt64(acc int64, f func(el uint64, acc int64) (int64, error)) (int64, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint64) ReduceWhileUint(acc uint, f func(el uint64, acc uint) (uint, error)) (uint, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint64) ReduceWhileUint8(acc uint8, f func(el uint64, acc uint8) (uint8, error)) (uint8, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint64) ReduceWhileUint16(acc uint16, f func(el uint64, acc uint16) (uint16, error)) (uint16, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint64) ReduceWhileUint32(acc uint32, f func(el uint64, acc uint32) (uint32, error)) (uint32, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint64) ReduceWhileUint64(acc uint64, f func(el uint64, acc uint64) (uint64, error)) (uint64, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceUint64) ReduceWhileInterface(acc interface{}, f func(el uint64, acc interface{}) (interface{}, error)) (interface{}, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// Reverse returns given arr in reversed order
func (s SliceUint64) Reverse() []uint64 {
	if len(s.Data) <= 1 {
		return s.Data
	}
	result := make([]uint64, 0, len(s.Data))
	for i := len(s.Data) - 1; i >= 0; i-- {
		result = append(result, s.Data[i])
	}
	return result
}

// Same returns true if all element in arr the same
func (s SliceUint64) Same() bool {
	if len(s.Data) <= 1 {
		return true
	}
	for i := 0; i < len(s.Data)-1; i++ {
		if s.Data[i] != s.Data[i+1] {
			return false
		}
	}
	return true
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint64) ScanBool(acc bool, f func(el uint64, acc bool) bool) []bool {
	result := make([]bool, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint64) ScanByte(acc byte, f func(el uint64, acc byte) byte) []byte {
	result := make([]byte, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint64) ScanString(acc string, f func(el uint64, acc string) string) []string {
	result := make([]string, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint64) ScanFloat32(acc float32, f func(el uint64, acc float32) float32) []float32 {
	result := make([]float32, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint64) ScanFloat64(acc float64, f func(el uint64, acc float64) float64) []float64 {
	result := make([]float64, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint64) ScanInt(acc int, f func(el uint64, acc int) int) []int {
	result := make([]int, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint64) ScanInt8(acc int8, f func(el uint64, acc int8) int8) []int8 {
	result := make([]int8, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint64) ScanInt16(acc int16, f func(el uint64, acc int16) int16) []int16 {
	result := make([]int16, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint64) ScanInt32(acc int32, f func(el uint64, acc int32) int32) []int32 {
	result := make([]int32, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint64) ScanInt64(acc int64, f func(el uint64, acc int64) int64) []int64 {
	result := make([]int64, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint64) ScanUint(acc uint, f func(el uint64, acc uint) uint) []uint {
	result := make([]uint, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint64) ScanUint8(acc uint8, f func(el uint64, acc uint8) uint8) []uint8 {
	result := make([]uint8, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint64) ScanUint16(acc uint16, f func(el uint64, acc uint16) uint16) []uint16 {
	result := make([]uint16, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint64) ScanUint32(acc uint32, f func(el uint64, acc uint32) uint32) []uint32 {
	result := make([]uint32, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint64) ScanUint64(acc uint64, f func(el uint64, acc uint64) uint64) []uint64 {
	result := make([]uint64, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceUint64) ScanInterface(acc interface{}, f func(el uint64, acc interface{}) interface{}) []interface{} {
	result := make([]interface{}, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Shuffle in random order arr elements
func (s SliceUint64) Shuffle() []uint64 {
	if len(s.Data) <= 1 {
		return s.Data
	}
	rand.Seed(time.Now().UnixNano())
	swap := func(i, j int) {
		s.Data[i], s.Data[j] = s.Data[j], s.Data[i]
	}
	rand.Shuffle(len(s.Data), swap)
	return s.Data
}

// Sort returns sorted slice
func (s SliceUint64) Sort() []uint64 {
	if len(s.Data) <= 1 {
		return s.Data
	}
	less := func(i int, j int) bool {
		return s.Data[i] < s.Data[j]
	}
	sort.SliceStable(s.Data, less)
	return s.Data
}

// Sorted returns true if slice is sorted
func (s SliceUint64) Sorted() bool {
	if len(s.Data) <= 1 {
		return true
	}
	for i := 1; i < len(s.Data); i++ {
		if s.Data[i-1] > s.Data[i] {
			return false
		}
	}
	return true
}

// Split splits arr by sep
func (s SliceUint64) Split(sep uint64) [][]uint64 {
	result := make([][]uint64, 0)
	curr := make([]uint64, 0)
	for _, el := range s.Data {
		if el == sep {
			result = append(result, curr)
		} else {
			curr = append(curr, el)
		}
	}
	result = append(result, curr)
	return result
}

// StartsWith returns true if slice starts with the given prefix slice.
// If prefix is empty, it returns true.
func (s SliceUint64) StartsWith(prefix []uint64) bool {
	if len(prefix) > len(s.Data) {
		return false
	}
	for i, el := range prefix {
		if el != s.Data[i] {
			return false
		}
	}
	return true
}

// Sum return sum of all elements from arr
func (s SliceUint64) Sum() uint64 {
	var sum uint64
	for _, el := range s.Data {
		sum += el
	}
	return sum
}

// TakeEvery returns slice of every nth elements
func (s SliceUint64) TakeEvery(nth int) ([]uint64, error) {
	if nth <= 0 {
		return s.Data, ErrNonPositiveValue
	}
	result := make([]uint64, 0, len(s.Data))
	for i, el := range s.Data {
		if (i+1)%nth == 0 {
			result = append(result, el)
		}
	}
	return result, nil
}

// TakeRandom returns slice of count random elements from the slice
func (s SliceUint64) TakeRandom(count int) ([]uint64, error) {
	if count > len(s.Data) {
		return nil, ErrOutOfRange
	}
	if count <= 0 {
		return nil, ErrNonPositiveValue
	}

	rand.Seed(time.Now().UnixNano())
	swap := func(i, j int) {
		s.Data[i], s.Data[j] = s.Data[j], s.Data[i]
	}
	rand.Shuffle(len(s.Data), swap)
	return s.Data[:count], nil
}

// TakeWhile takes elements from arr while f returns true
func (s SliceUint64) TakeWhile(f func(el uint64) bool) []uint64 {
	result := make([]uint64, 0, len(s.Data))
	for _, el := range s.Data {
		if !f(el) {
			return result
		}
		result = append(result, el)
	}
	return result
}

// ToChannel returns channel with elements from the slice
func (s SliceUint64) ToChannel() chan uint64 {
	c := make(chan uint64, 1)
	go func() {
		for _, el := range s.Data {
			c <- el
		}
		close(c)
	}()
	return c
}

// Uniq returns arr with only first occurences of every element.
func (s SliceUint64) Uniq() []uint64 {
	if len(s.Data) <= 1 {
		return s.Data
	}
	added := make(map[uint64]struct{})
	nothing := struct{}{}
	result := make([]uint64, 0, len(s.Data))
	for _, el := range s.Data {
		_, exists := added[el]
		if !exists {
			result = append(result, el)
			added[el] = nothing
		}
	}
	return result

}

// Window makes sliding window for a given slice:
// ({1,2,3}, 2) -> (1,2), (2,3)
func (s SliceUint64) Window(size int) ([][]uint64, error) {
	if size <= 0 {
		return nil, ErrNonPositiveValue
	}
	result := make([][]uint64, 0, len(s.Data)/size)
	for i := 0; i <= len(s.Data)-size; i++ {
		chunk := s.Data[i : i+size]
		result = append(result, chunk)
	}
	return result, nil
}

// Without returns the slice with filtered out element
func (s SliceUint64) Without(elements ...uint64) []uint64 {
	result := make([]uint64, 0, len(s.Data))
	for _, el := range s.Data {
		allowed := true
		for _, other := range elements {
			if el == other {
				allowed = false
			}
		}
		if allowed {
			result = append(result, el)
		}
	}
	return result
}

// Concat concatenates given slices into a single slice.
func (s SlicesUint64) Concat() []uint64 {
	result := make([]uint64, 0)
	for _, arr := range s.Data {
		result = append(result, arr...)
	}
	return result
}

// Product returns cortesian product of elements
// {{1, 2}, {3, 4}} -> {1, 3}, {1, 4}, {2, 3}, {2, 4}
func (s SlicesUint64) Product() chan []uint64 {
	c := make(chan []uint64, 1)
	go s.product(c, []uint64{}, 0)
	return c
}

// product is a core implementation of Product
func (s SlicesUint64) product(c chan []uint64, left []uint64, pos int) {
	// iterate over the last array
	if pos == len(s.Data)-1 {
		for _, el := range s.Data[pos] {
			result := make([]uint64, 0, len(left)+1)
			result = append(result, left...)
			result = append(result, el)
			c <- result
		}
		return
	}

	for _, el := range s.Data[pos] {
		result := make([]uint64, 0, len(left)+1)
		result = append(result, left...)
		result = append(result, el)
		s.product(c, result, pos+1)
	}

	if pos == 0 {
		close(c)
	}
}

// Zip returns array of arrays of elements from given arrs
// on the same position
func (s SlicesUint64) Zip() [][]uint64 {
	size := len(s.Data[0])
	for _, arr := range s.Data[1:] {
		if len(arr) > size {
			size = len(arr)
		}
	}

	result := make([][]uint64, 0, size)
	for i := 0; i <= size; i++ {
		chunk := make([]uint64, 0, len(s.Data))
		for _, arr := range s.Data {
			chunk = append(chunk, arr[i])
		}
		result = append(result, chunk)
	}
	return result
}

// Channel is a set of operations with channel
type ChannelInterface struct {
	Data chan interface{}
}

// AsyncSlice is a set of operations to work with slice asynchronously
type AsyncSliceInterface struct {
	Data    []interface{}
	Workers int
}

// Sequence is a set of operations to generate sequences
type SequenceInterface struct {
	ctx context.Context
}

// Pair is a set of functions for 2 values that you can pass into reduce-like funcs
type PairInterface struct {
	// empty
}

// Slice is a set of operations to work with slice
type SliceInterface struct {
	Data []interface{}
}

// Slices is a set of operations to work with slice of slices
type SlicesInterface struct {
	Data [][]interface{}
}

// Any returns true if f returns true for any element in channel
func (c ChannelInterface) Any(f func(el interface{}) bool) bool {
	for el := range c.Data {
		if f(el) {
			return true
		}
	}
	return false
}

// All returns true if f returns true for all elements in channel
func (c ChannelInterface) All(f func(el interface{}) bool) bool {
	for el := range c.Data {
		if !f(el) {
			return false
		}
	}
	return true
}

// ChunkEvery returns channel with slices containing count elements each
func (c ChannelInterface) ChunkEvery(count int) chan []interface{} {
	chunks := make(chan []interface{}, 1)
	go func() {
		chunk := make([]interface{}, 0, count)
		i := 0
		for el := range c.Data {
			chunk = append(chunk, el)
			i++
			if i%count == 0 {
				i = 0
				chunks <- chunk
				chunk = make([]interface{}, 0, count)
			}
		}
		if len(chunk) > 0 {
			chunks <- chunk
		}
		close(chunks)
	}()
	return chunks
}

// Count return count of el occurences in channel.
func (c ChannelInterface) Count(el interface{}) int {
	count := 0
	for val := range c.Data {
		if val == el {
			count++
		}
	}
	return count
}

// Drop drops first n elements from channel c and returns a new channel with the rest.
// It returns channel do be unblocking. If you want array instead, wrap result into TakeAll.
func (c ChannelInterface) Drop(n int) chan interface{} {
	result := make(chan interface{}, 1)
	go func() {
		i := 0
		for el := range c.Data {
			if i >= n {
				result <- el
			}
			i++
		}
		close(result)
	}()
	return result
}

// Each calls f for every element in the channel
func (c ChannelInterface) Each(f func(el interface{})) {
	for el := range c.Data {
		f(el)
	}
}

// Filter returns a new channel with elements from input channel
// for which f returns true
func (c ChannelInterface) Filter(f func(el interface{}) bool) chan interface{} {
	result := make(chan interface{}, 1)
	go func() {
		for el := range c.Data {
			if f(el) {
				result <- el
			}
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInterface) MapBool(f func(el interface{}) bool) chan bool {
	result := make(chan bool, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInterface) MapByte(f func(el interface{}) byte) chan byte {
	result := make(chan byte, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInterface) MapString(f func(el interface{}) string) chan string {
	result := make(chan string, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInterface) MapFloat32(f func(el interface{}) float32) chan float32 {
	result := make(chan float32, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInterface) MapFloat64(f func(el interface{}) float64) chan float64 {
	result := make(chan float64, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInterface) MapInt(f func(el interface{}) int) chan int {
	result := make(chan int, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInterface) MapInt8(f func(el interface{}) int8) chan int8 {
	result := make(chan int8, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInterface) MapInt16(f func(el interface{}) int16) chan int16 {
	result := make(chan int16, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInterface) MapInt32(f func(el interface{}) int32) chan int32 {
	result := make(chan int32, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInterface) MapInt64(f func(el interface{}) int64) chan int64 {
	result := make(chan int64, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInterface) MapUint(f func(el interface{}) uint) chan uint {
	result := make(chan uint, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInterface) MapUint8(f func(el interface{}) uint8) chan uint8 {
	result := make(chan uint8, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInterface) MapUint16(f func(el interface{}) uint16) chan uint16 {
	result := make(chan uint16, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInterface) MapUint32(f func(el interface{}) uint32) chan uint32 {
	result := make(chan uint32, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInterface) MapUint64(f func(el interface{}) uint64) chan uint64 {
	result := make(chan uint64, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Map applies f to all elements from channel and returns channel with results
func (c ChannelInterface) MapInterface(f func(el interface{}) interface{}) chan interface{} {
	result := make(chan interface{}, 1)
	go func() {
		for el := range c.Data {
			result <- f(el)
		}
		close(result)
	}()
	return result
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInterface) ReduceBool(acc bool, f func(el interface{}, acc bool) bool) bool {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInterface) ReduceByte(acc byte, f func(el interface{}, acc byte) byte) byte {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInterface) ReduceString(acc string, f func(el interface{}, acc string) string) string {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInterface) ReduceFloat32(acc float32, f func(el interface{}, acc float32) float32) float32 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInterface) ReduceFloat64(acc float64, f func(el interface{}, acc float64) float64) float64 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInterface) ReduceInt(acc int, f func(el interface{}, acc int) int) int {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInterface) ReduceInt8(acc int8, f func(el interface{}, acc int8) int8) int8 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInterface) ReduceInt16(acc int16, f func(el interface{}, acc int16) int16) int16 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInterface) ReduceInt32(acc int32, f func(el interface{}, acc int32) int32) int32 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInterface) ReduceInt64(acc int64, f func(el interface{}, acc int64) int64) int64 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInterface) ReduceUint(acc uint, f func(el interface{}, acc uint) uint) uint {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInterface) ReduceUint8(acc uint8, f func(el interface{}, acc uint8) uint8) uint8 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInterface) ReduceUint16(acc uint16, f func(el interface{}, acc uint16) uint16) uint16 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInterface) ReduceUint32(acc uint32, f func(el interface{}, acc uint32) uint32) uint32 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInterface) ReduceUint64(acc uint64, f func(el interface{}, acc uint64) uint64) uint64 {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies f to acc and every element from channel and returns acc
func (c ChannelInterface) ReduceInterface(acc interface{}, f func(el interface{}, acc interface{}) interface{}) interface{} {
	for el := range c.Data {
		acc = f(el, acc)
	}
	return acc
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInterface) ScanBool(acc bool, f func(el interface{}, acc bool) bool) chan bool {
	result := make(chan bool, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInterface) ScanByte(acc byte, f func(el interface{}, acc byte) byte) chan byte {
	result := make(chan byte, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInterface) ScanString(acc string, f func(el interface{}, acc string) string) chan string {
	result := make(chan string, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInterface) ScanFloat32(acc float32, f func(el interface{}, acc float32) float32) chan float32 {
	result := make(chan float32, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInterface) ScanFloat64(acc float64, f func(el interface{}, acc float64) float64) chan float64 {
	result := make(chan float64, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInterface) ScanInt(acc int, f func(el interface{}, acc int) int) chan int {
	result := make(chan int, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInterface) ScanInt8(acc int8, f func(el interface{}, acc int8) int8) chan int8 {
	result := make(chan int8, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInterface) ScanInt16(acc int16, f func(el interface{}, acc int16) int16) chan int16 {
	result := make(chan int16, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInterface) ScanInt32(acc int32, f func(el interface{}, acc int32) int32) chan int32 {
	result := make(chan int32, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInterface) ScanInt64(acc int64, f func(el interface{}, acc int64) int64) chan int64 {
	result := make(chan int64, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInterface) ScanUint(acc uint, f func(el interface{}, acc uint) uint) chan uint {
	result := make(chan uint, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInterface) ScanUint8(acc uint8, f func(el interface{}, acc uint8) uint8) chan uint8 {
	result := make(chan uint8, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInterface) ScanUint16(acc uint16, f func(el interface{}, acc uint16) uint16) chan uint16 {
	result := make(chan uint16, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInterface) ScanUint32(acc uint32, f func(el interface{}, acc uint32) uint32) chan uint32 {
	result := make(chan uint32, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInterface) ScanUint64(acc uint64, f func(el interface{}, acc uint64) uint64) chan uint64 {
	result := make(chan uint64, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Scan is like Reduce, but returns slice of f results
func (c ChannelInterface) ScanInterface(acc interface{}, f func(el interface{}, acc interface{}) interface{}) chan interface{} {
	result := make(chan interface{}, 1)
	go func() {
		for el := range c.Data {
			acc = f(el, acc)
			result <- acc
		}
		close(result)
	}()
	return result
}

// Take takes first count elements from the channel.
func (c ChannelInterface) Take(count int) chan interface{} {
	result := make(chan interface{}, 1)
	go func() {
		defer close(result)
		if count <= 0 {
			return
		}
		i := 0
		for el := range c.Data {
			result <- el
			i++
			if i == count {
				return
			}
		}
	}()
	return result
}

// Tee returns 2 channels with elements from the input channel
func (c ChannelInterface) Tee(count int) []chan interface{} {
	channels := make([]chan interface{}, 0, count)
	for i := 0; i < count; i++ {
		channels = append(channels, make(chan interface{}, 1))
	}
	go func() {
		for el := range c.Data {
			wg := sync.WaitGroup{}
			putInto := func(ch chan interface{}) {
				defer wg.Done()
				ch <- el
			}
			wg.Add(count)
			for _, ch := range channels {
				putInto(ch)
			}
			wg.Wait()
		}
		for _, ch := range channels {
			close(ch)
		}
	}()
	return channels
}

// ToSlice returns slice with all elements from channel.
func (c ChannelInterface) ToSlice() []interface{} {
	result := make([]interface{}, 0)
	for val := range c.Data {
		result = append(result, val)
	}
	return result
}

// All returns true if f returns true for all elements in slice
func (s AsyncSliceInterface) All(f func(el interface{}) bool) bool {
	if len(s.Data) == 0 {
		return true
	}

	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int, result chan<- bool, ctx context.Context) {
		defer wg.Done()
		for {
			select {
			case <-ctx.Done():
				return
			case index, ok := <-jobs:
				if !ok {
					return
				}
				if !f(s.Data[index]) {
					result <- false
					return
				}
			}
		}
	}

	ctx, cancel := context.WithCancel(context.Background())
	// when we're returning the result, cancel all workers
	defer cancel()

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	result := make(chan bool, workers)
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs, result, ctx)
	}

	// close the result channel when all workers have done
	go func() {
		wg.Wait()
		close(result)
	}()

	// schedule the jobs: indices to check
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)

	for range result {
		return false
	}
	return true
}

// Any returns true if f returns true for any element from slice
func (s AsyncSliceInterface) Any(f func(el interface{}) bool) bool {
	if len(s.Data) == 0 {
		return false
	}

	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int, result chan<- bool, ctx context.Context) {
		defer wg.Done()
		for {
			select {
			case <-ctx.Done():
				return
			case index, ok := <-jobs:
				if !ok {
					return
				}
				if f(s.Data[index]) {
					result <- true
					return
				}
			}
		}
	}

	ctx, cancel := context.WithCancel(context.Background())
	// when we're returning the result, cancel all workers
	defer cancel()

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	result := make(chan bool, workers)
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs, result, ctx)
	}

	// close the result channel when all workers have done
	go func() {
		wg.Wait()
		close(result)
	}()

	// schedule the jobs: indices to check
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)

	for range result {
		return true
	}
	return false
}

// Each calls f for every element from slice
func (s AsyncSliceInterface) Each(f func(el interface{})) {
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		defer wg.Done()
		for index := range jobs {
			f(s.Data[index])
		}
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
}

// Filter returns slice of element for which f returns true
func (s AsyncSliceInterface) Filter(f func(el interface{}) bool) []interface{} {
	resultMap := make([]bool, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			if f(s.Data[index]) {
				resultMap[index] = true
			}
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()

	// return filtered results
	result := make([]interface{}, 0, len(s.Data))
	for i, el := range s.Data {
		if resultMap[i] {
			result = append(result, el)
		}
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInterface) MapBool(f func(el interface{}) bool) []bool {
	result := make([]bool, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInterface) MapByte(f func(el interface{}) byte) []byte {
	result := make([]byte, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInterface) MapString(f func(el interface{}) string) []string {
	result := make([]string, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInterface) MapFloat32(f func(el interface{}) float32) []float32 {
	result := make([]float32, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInterface) MapFloat64(f func(el interface{}) float64) []float64 {
	result := make([]float64, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInterface) MapInt(f func(el interface{}) int) []int {
	result := make([]int, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInterface) MapInt8(f func(el interface{}) int8) []int8 {
	result := make([]int8, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInterface) MapInt16(f func(el interface{}) int16) []int16 {
	result := make([]int16, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInterface) MapInt32(f func(el interface{}) int32) []int32 {
	result := make([]int32, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInterface) MapInt64(f func(el interface{}) int64) []int64 {
	result := make([]int64, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInterface) MapUint(f func(el interface{}) uint) []uint {
	result := make([]uint, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInterface) MapUint8(f func(el interface{}) uint8) []uint8 {
	result := make([]uint8, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInterface) MapUint16(f func(el interface{}) uint16) []uint16 {
	result := make([]uint16, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInterface) MapUint32(f func(el interface{}) uint32) []uint32 {
	result := make([]uint32, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInterface) MapUint64(f func(el interface{}) uint64) []uint64 {
	result := make([]uint64, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s AsyncSliceInterface) MapInterface(f func(el interface{}) interface{}) []interface{} {
	result := make([]interface{}, len(s.Data))
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int) {
		for index := range jobs {
			result[index] = f(s.Data[index])
		}
		wg.Done()
	}

	// calculate workers count
	workers := s.Workers
	if workers == 0 || workers > len(s.Data) {
		workers = len(s.Data)
	}

	// run workers
	jobs := make(chan int, len(s.Data))
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go worker(jobs)
	}

	// add indices into jobs for workers
	for i := 0; i < len(s.Data); i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
	return result
}

// Reduce reduces slice to a single value with f
func (s AsyncSliceInterface) Reduce(f func(left interface{}, right interface{}) interface{}) interface{} {
	if len(s.Data) == 0 {
		var tmp interface{}
		return tmp
	}

	state := make([]interface{}, len(s.Data))
	state = append(state, s.Data...)
	wg := sync.WaitGroup{}

	worker := func(jobs <-chan int, result chan<- interface{}) {
		for index := range jobs {
			result <- f(state[index], state[index+1])
		}
		wg.Done()
	}

	for len(state) > 1 {
		// calculate workers count
		workers := s.Workers
		if workers == 0 || workers > len(state) {
			workers = len(state)
		}

		// run workers
		jobs := make(chan int, len(state))
		wg.Add(workers)
		result := make(chan interface{}, 1)
		for i := 0; i < workers; i++ {
			go worker(jobs, result)
		}

		go func() {
			wg.Wait()
			close(result)
		}()

		// add indices into jobs for workers
		for i := 0; i < len(state)-1; i += 2 {
			jobs <- i
		}
		close(jobs)

		// collect new state
		newState := make([]interface{}, 0, len(state)/2+len(state)%2)
		for el := range result {
			newState = append(newState, el)
		}
		if len(state)%2 == 1 {
			newState = append(newState, state[len(state)-1])
		}
		// put new state as current state after all
		state = newState
	}

	return state[0]
}

// Iterate returns an infinite list of repeated applications of f to val
func (s SequenceInterface) Iterate(val interface{}, f func(val interface{}) interface{}) chan interface{} {
	c := make(chan interface{}, 1)
	go func() {
		defer close(c)
		for {
			select {
			case <-s.ctx.Done():
				return
			case c <- val:
				val = f(val)
			}
		}
	}()
	return c
}

// Repeat returns channel that produces val infinite times
func (s SequenceInterface) Repeat(val interface{}) chan interface{} {
	c := make(chan interface{}, 1)
	go func() {
		defer close(c)
		for {
			select {
			case <-s.ctx.Done():
				return
			case c <- val:
				continue
			}
		}
	}()
	return c
}

// Replicate returns channel that produces val n times
func (s SequenceInterface) Replicate(val interface{}, n int) chan interface{} {
	c := make(chan interface{}, 1)
	go func() {
		for i := 0; i < n; i++ {
			c <- val
		}
		close(c)
	}()
	return c
}

// Any returns true if f returns true for any element in arr
func (s SliceInterface) Any(f func(el interface{}) bool) bool {
	for _, el := range s.Data {
		if f(el) {
			return true
		}
	}
	return false
}

// All returns true if f returns true for all elements in arr
func (s SliceInterface) All(f func(el interface{}) bool) bool {
	for _, el := range s.Data {
		if !f(el) {
			return false
		}
	}
	return true
}

// Choice chooses a random element from the slice
func (s SliceInterface) Choice() (interface{}, error) {
	if len(s.Data) == 0 {
		var tmp interface{}
		return tmp, ErrEmpty
	}

	rand.Seed(time.Now().UnixNano())
	i := rand.Intn(len(s.Data))
	return s.Data[i], nil
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInterface) ChunkByBool(f func(el interface{}) bool) [][]interface{} {
	chunks := make([][]interface{}, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]interface{}, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]interface{}, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInterface) ChunkByByte(f func(el interface{}) byte) [][]interface{} {
	chunks := make([][]interface{}, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]interface{}, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]interface{}, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInterface) ChunkByString(f func(el interface{}) string) [][]interface{} {
	chunks := make([][]interface{}, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]interface{}, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]interface{}, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInterface) ChunkByFloat32(f func(el interface{}) float32) [][]interface{} {
	chunks := make([][]interface{}, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]interface{}, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]interface{}, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInterface) ChunkByFloat64(f func(el interface{}) float64) [][]interface{} {
	chunks := make([][]interface{}, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]interface{}, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]interface{}, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInterface) ChunkByInt(f func(el interface{}) int) [][]interface{} {
	chunks := make([][]interface{}, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]interface{}, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]interface{}, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInterface) ChunkByInt8(f func(el interface{}) int8) [][]interface{} {
	chunks := make([][]interface{}, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]interface{}, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]interface{}, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInterface) ChunkByInt16(f func(el interface{}) int16) [][]interface{} {
	chunks := make([][]interface{}, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]interface{}, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]interface{}, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInterface) ChunkByInt32(f func(el interface{}) int32) [][]interface{} {
	chunks := make([][]interface{}, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]interface{}, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]interface{}, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInterface) ChunkByInt64(f func(el interface{}) int64) [][]interface{} {
	chunks := make([][]interface{}, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]interface{}, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]interface{}, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInterface) ChunkByUint(f func(el interface{}) uint) [][]interface{} {
	chunks := make([][]interface{}, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]interface{}, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]interface{}, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInterface) ChunkByUint8(f func(el interface{}) uint8) [][]interface{} {
	chunks := make([][]interface{}, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]interface{}, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]interface{}, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInterface) ChunkByUint16(f func(el interface{}) uint16) [][]interface{} {
	chunks := make([][]interface{}, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]interface{}, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]interface{}, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInterface) ChunkByUint32(f func(el interface{}) uint32) [][]interface{} {
	chunks := make([][]interface{}, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]interface{}, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]interface{}, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInterface) ChunkByUint64(f func(el interface{}) uint64) [][]interface{} {
	chunks := make([][]interface{}, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]interface{}, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]interface{}, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkBy splits arr on every element for which f returns a new value.
func (s SliceInterface) ChunkByInterface(f func(el interface{}) interface{}) [][]interface{} {
	chunks := make([][]interface{}, 0)
	if len(s.Data) == 0 {
		return chunks
	}

	chunk := make([]interface{}, 0)
	prev := f(s.Data[0])
	chunk = append(chunk, s.Data[0])

	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			chunks = append(chunks, chunk)
			chunk = make([]interface{}, 0)
			prev = curr
		}
		chunk = append(chunk, el)
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks
}

// ChunkEvery returns slice of slices containing count elements each
func (s SliceInterface) ChunkEvery(count int) ([][]interface{}, error) {
	chunks := make([][]interface{}, 0)
	if count <= 0 {
		return chunks, ErrNegativeValue
	}
	chunk := make([]interface{}, 0, count)
	for i, el := range s.Data {
		chunk = append(chunk, el)
		if (i+1)%count == 0 {
			chunks = append(chunks, chunk)
			chunk = make([]interface{}, 0, count)
		}
	}
	if len(chunk) > 0 {
		chunks = append(chunks, chunk)
	}
	return chunks, nil
}

// Contains returns true if el in arr.
func (s SliceInterface) Contains(el interface{}) bool {
	for _, val := range s.Data {
		if val == el {
			return true
		}
	}
	return false
}

// Count return count of el occurences in arr.
func (s SliceInterface) Count(el interface{}) int {
	count := 0
	for _, val := range s.Data {
		if val == el {
			count++
		}
	}
	return count
}

// CountBy returns how many times f returns true.
func (s SliceInterface) CountBy(f func(el interface{}) bool) int {
	count := 0
	for _, el := range s.Data {
		if f(el) {
			count++
		}
	}
	return count
}

// Cycle is an infinite loop over slice
func (s SliceInterface) Cycle() chan interface{} {
	c := make(chan interface{}, 1)
	go func() {
		defer close(c)
		if len(s.Data) == 0 {
			return
		}
		for {
			for _, val := range s.Data {
				c <- val
			}
		}
	}()
	return c
}

// Dedup returns a given slice without consecutive duplicated elements
func (s SliceInterface) Dedup() []interface{} {
	if len(s.Data) == 0 {
		return s.Data
	}

	result := make([]interface{}, 0, len(s.Data))
	prev := s.Data[0]
	result = append(result, prev)
	for _, el := range s.Data[1:] {
		if el != prev {
			result = append(result, el)
			prev = el
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInterface) DedupByBool(f func(el interface{}) bool) []interface{} {
	result := make([]interface{}, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInterface) DedupByByte(f func(el interface{}) byte) []interface{} {
	result := make([]interface{}, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInterface) DedupByString(f func(el interface{}) string) []interface{} {
	result := make([]interface{}, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInterface) DedupByFloat32(f func(el interface{}) float32) []interface{} {
	result := make([]interface{}, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInterface) DedupByFloat64(f func(el interface{}) float64) []interface{} {
	result := make([]interface{}, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInterface) DedupByInt(f func(el interface{}) int) []interface{} {
	result := make([]interface{}, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInterface) DedupByInt8(f func(el interface{}) int8) []interface{} {
	result := make([]interface{}, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInterface) DedupByInt16(f func(el interface{}) int16) []interface{} {
	result := make([]interface{}, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInterface) DedupByInt32(f func(el interface{}) int32) []interface{} {
	result := make([]interface{}, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInterface) DedupByInt64(f func(el interface{}) int64) []interface{} {
	result := make([]interface{}, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInterface) DedupByUint(f func(el interface{}) uint) []interface{} {
	result := make([]interface{}, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInterface) DedupByUint8(f func(el interface{}) uint8) []interface{} {
	result := make([]interface{}, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInterface) DedupByUint16(f func(el interface{}) uint16) []interface{} {
	result := make([]interface{}, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInterface) DedupByUint32(f func(el interface{}) uint32) []interface{} {
	result := make([]interface{}, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInterface) DedupByUint64(f func(el interface{}) uint64) []interface{} {
	result := make([]interface{}, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// DedupBy returns a given slice without consecutive elements
// For which f returns the same result
func (s SliceInterface) DedupByInterface(f func(el interface{}) interface{}) []interface{} {
	result := make([]interface{}, 0, len(s.Data))
	if len(s.Data) == 0 {
		return result
	}

	prev := f(s.Data[0])
	result = append(result, s.Data[0])
	for _, el := range s.Data[1:] {
		curr := f(el)
		if curr != prev {
			result = append(result, el)
			prev = curr
		}
	}
	return result
}

// Delete deletes the first occurence of the element from the slice
func (s SliceInterface) Delete(element interface{}) []interface{} {
	result := make([]interface{}, 0, len(s.Data)-1)
	deleted := false
	for _, el := range s.Data {
		if !deleted && el == element {
			continue
		}
		result = append(result, el)
	}
	return result

}

// DeleteAt returns the slice without elements on given positions
func (s SliceInterface) DeleteAt(index int) ([]interface{}, error) {
	if index >= len(s.Data) {
		return s.Data, ErrOutOfRange
	}

	result := make([]interface{}, 0, len(s.Data)-1)
	for i, el := range s.Data {
		if i != index {
			result = append(result, el)
		}
	}
	return result, nil
}

// DropEvery returns a slice of every nth element in the enumerable dropped,
// starting with the first element.
func (s SliceInterface) DropEvery(nth int) ([]interface{}, error) {
	if nth <= 0 {
		return s.Data, ErrNonPositiveValue
	}
	result := make([]interface{}, 0, len(s.Data)/nth)
	for i, el := range s.Data {
		if (i+1)%nth != 0 {
			result = append(result, el)
		}
	}
	return result, nil
}

// DropWhile drops elements from arr while f returns true
func (s SliceInterface) DropWhile(f func(arr interface{}) bool) []interface{} {
	result := make([]interface{}, 0, len(s.Data))
	for _, el := range s.Data {
		if !f(el) {
			return result
		}
		result = append(result, el)
	}
	return result
}

// Each calls f for every element from arr
func (s SliceInterface) Each(f func(el interface{})) {
	for _, el := range s.Data {
		f(el)
	}
}

// Equal returns true if slices are equal
func (s SliceInterface) Equal(other []interface{}) bool {
	if len(s.Data) != len(other) {
		return false
	}
	for i, el := range other {
		if s.Data[i] != el {
			return false
		}
	}
	return true
}

// Filter returns slice of T for which F returned true
func (s SliceInterface) Filter(f func(el interface{}) bool) []interface{} {
	result := make([]interface{}, 0, len(s.Data))
	for _, el := range s.Data {
		if f(el) {
			result = append(result, el)
		}
	}
	return result
}

// Find returns the first element for which f returns true
func (s SliceInterface) Find(f func(el interface{}) bool) (interface{}, error) {
	for _, el := range s.Data {
		if f(el) {
			return el, nil
		}
	}
	var tmp interface{}
	return tmp, ErrNotFound
}

// FindIndex is like Find, but return element index instead of element itself
func (s SliceInterface) FindIndex(f func(el interface{}) bool) (int, error) {
	for i, el := range s.Data {
		if f(el) {
			return i, nil
		}
	}
	return 0, ErrNotFound
}

// GroupBy groups element from array by value returned by f
func (s SliceInterface) GroupByBool(f func(el interface{}) bool) map[bool][]interface{} {
	result := make(map[bool][]interface{})
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]interface{}, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInterface) GroupByByte(f func(el interface{}) byte) map[byte][]interface{} {
	result := make(map[byte][]interface{})
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]interface{}, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInterface) GroupByString(f func(el interface{}) string) map[string][]interface{} {
	result := make(map[string][]interface{})
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]interface{}, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInterface) GroupByFloat32(f func(el interface{}) float32) map[float32][]interface{} {
	result := make(map[float32][]interface{})
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]interface{}, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInterface) GroupByFloat64(f func(el interface{}) float64) map[float64][]interface{} {
	result := make(map[float64][]interface{})
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]interface{}, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInterface) GroupByInt(f func(el interface{}) int) map[int][]interface{} {
	result := make(map[int][]interface{})
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]interface{}, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInterface) GroupByInt8(f func(el interface{}) int8) map[int8][]interface{} {
	result := make(map[int8][]interface{})
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]interface{}, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInterface) GroupByInt16(f func(el interface{}) int16) map[int16][]interface{} {
	result := make(map[int16][]interface{})
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]interface{}, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInterface) GroupByInt32(f func(el interface{}) int32) map[int32][]interface{} {
	result := make(map[int32][]interface{})
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]interface{}, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInterface) GroupByInt64(f func(el interface{}) int64) map[int64][]interface{} {
	result := make(map[int64][]interface{})
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]interface{}, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInterface) GroupByUint(f func(el interface{}) uint) map[uint][]interface{} {
	result := make(map[uint][]interface{})
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]interface{}, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInterface) GroupByUint8(f func(el interface{}) uint8) map[uint8][]interface{} {
	result := make(map[uint8][]interface{})
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]interface{}, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInterface) GroupByUint16(f func(el interface{}) uint16) map[uint16][]interface{} {
	result := make(map[uint16][]interface{})
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]interface{}, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInterface) GroupByUint32(f func(el interface{}) uint32) map[uint32][]interface{} {
	result := make(map[uint32][]interface{})
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]interface{}, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInterface) GroupByUint64(f func(el interface{}) uint64) map[uint64][]interface{} {
	result := make(map[uint64][]interface{})
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]interface{}, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// GroupBy groups element from array by value returned by f
func (s SliceInterface) GroupByInterface(f func(el interface{}) interface{}) map[interface{}][]interface{} {
	result := make(map[interface{}][]interface{})
	for _, el := range s.Data {
		key := f(el)
		val, ok := result[key]
		if !ok {
			result[key] = make([]interface{}, 1)
		}
		result[key] = append(val, el)
	}
	return result
}

// InsertAt returns the slice with element inserted at given index.
func (s SliceInterface) InsertAt(index int, element interface{}) ([]interface{}, error) {
	result := make([]interface{}, 0, len(s.Data)+1)

	// insert at the end
	if index == len(s.Data) || index == -1 {
		result = append(result, s.Data...)
		result = append(result, element)
		return result, nil
	}

	if index > len(s.Data) {
		return s.Data, ErrOutOfRange
	}
	if index < 0 {
		return s.Data, ErrNegativeValue
	}

	for i, el := range s.Data {
		if i == index {
			result = append(result, element)
		}
		result = append(result, el)
	}
	return result, nil
}

// Intersperse inserts el between each element of arr
func (s SliceInterface) Intersperse(el interface{}) []interface{} {
	if len(s.Data) == 0 {
		return s.Data
	}
	result := make([]interface{}, 0, len(s.Data)*2-1)
	result = append(result, s.Data[0])
	for _, val := range s.Data[1:] {
		result = append(result, el, val)
	}
	return result
}

// Last returns the last element from the slice
func (s SliceInterface) Last() (interface{}, error) {
	if len(s.Data) == 0 {
		var tmp interface{}
		return tmp, ErrEmpty
	}
	return s.Data[len(s.Data)-1], nil
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInterface) MapBool(f func(el interface{}) bool) []bool {
	result := make([]bool, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInterface) MapByte(f func(el interface{}) byte) []byte {
	result := make([]byte, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInterface) MapString(f func(el interface{}) string) []string {
	result := make([]string, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInterface) MapFloat32(f func(el interface{}) float32) []float32 {
	result := make([]float32, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInterface) MapFloat64(f func(el interface{}) float64) []float64 {
	result := make([]float64, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInterface) MapInt(f func(el interface{}) int) []int {
	result := make([]int, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInterface) MapInt8(f func(el interface{}) int8) []int8 {
	result := make([]int8, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInterface) MapInt16(f func(el interface{}) int16) []int16 {
	result := make([]int16, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInterface) MapInt32(f func(el interface{}) int32) []int32 {
	result := make([]int32, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInterface) MapInt64(f func(el interface{}) int64) []int64 {
	result := make([]int64, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInterface) MapUint(f func(el interface{}) uint) []uint {
	result := make([]uint, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInterface) MapUint8(f func(el interface{}) uint8) []uint8 {
	result := make([]uint8, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInterface) MapUint16(f func(el interface{}) uint16) []uint16 {
	result := make([]uint16, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInterface) MapUint32(f func(el interface{}) uint32) []uint32 {
	result := make([]uint32, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInterface) MapUint64(f func(el interface{}) uint64) []uint64 {
	result := make([]uint64, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Map applies F to all elements in slice of T and returns slice of results
func (s SliceInterface) MapInterface(f func(el interface{}) interface{}) []interface{} {
	result := make([]interface{}, 0, len(s.Data))
	for _, el := range s.Data {
		result = append(result, f(el))
	}
	return result
}

// Permutations returns successive size-length permutations of elements from the slice.
// {1, 2, 3} -> {1, 2}, {1, 3}, {2, 1}, {2, 3}, {3, 1}, {3, 2}
func (s SliceInterface) Permutations(size int) chan []interface{} {
	c := make(chan []interface{}, 1)
	go func() {
		if len(s.Data) > 0 {
			s.permutations(c, size, []interface{}{}, s.Data)
		}
		close(c)
	}()
	return c
}

// permutations is a core implementation for Permutations
func (s SliceInterface) permutations(c chan []interface{}, size int, left []interface{}, right []interface{}) {
	if len(left) == size || len(right) == 0 {
		c <- left
		return
	}

	for i, el := range right {
		newLeft := make([]interface{}, 0, len(left)+1)
		newLeft = append(newLeft, left...)
		newLeft = append(newLeft, el)

		newRight := make([]interface{}, 0, len(right)-1)
		for j, other := range right {
			if j != i {
				newRight = append(newRight, other)
			}
		}
		s.permutations(c, size, newLeft, newRight)
	}
}

// Product returns cortesian product of elements
// {{1, 2}, {3, 4}} -> {1, 3}, {1, 4}, {2, 3}, {2, 4}
func (s SliceInterface) Product(repeat int) chan []interface{} {
	c := make(chan []interface{}, 1)
	go s.product(c, repeat, []interface{}{}, 0)
	return c
}

// product is a core implementation for Product
func (s SliceInterface) product(c chan []interface{}, repeat int, left []interface{}, pos int) {
	// iterate over the last array
	if pos == repeat-1 {
		for _, el := range s.Data {
			result := make([]interface{}, 0, len(left)+1)
			result = append(result, left...)
			result = append(result, el)
			c <- result
		}
		return
	}

	for _, el := range s.Data {
		result := make([]interface{}, 0, len(left)+1)
		result = append(result, left...)
		result = append(result, el)
		s.product(c, repeat, result, pos+1)
	}

	if pos == 0 {
		close(c)
	}
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInterface) ReduceBool(acc bool, f func(el interface{}, acc bool) bool) bool {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInterface) ReduceByte(acc byte, f func(el interface{}, acc byte) byte) byte {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInterface) ReduceString(acc string, f func(el interface{}, acc string) string) string {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInterface) ReduceFloat32(acc float32, f func(el interface{}, acc float32) float32) float32 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInterface) ReduceFloat64(acc float64, f func(el interface{}, acc float64) float64) float64 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInterface) ReduceInt(acc int, f func(el interface{}, acc int) int) int {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInterface) ReduceInt8(acc int8, f func(el interface{}, acc int8) int8) int8 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInterface) ReduceInt16(acc int16, f func(el interface{}, acc int16) int16) int16 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInterface) ReduceInt32(acc int32, f func(el interface{}, acc int32) int32) int32 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInterface) ReduceInt64(acc int64, f func(el interface{}, acc int64) int64) int64 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInterface) ReduceUint(acc uint, f func(el interface{}, acc uint) uint) uint {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInterface) ReduceUint8(acc uint8, f func(el interface{}, acc uint8) uint8) uint8 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInterface) ReduceUint16(acc uint16, f func(el interface{}, acc uint16) uint16) uint16 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInterface) ReduceUint32(acc uint32, f func(el interface{}, acc uint32) uint32) uint32 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInterface) ReduceUint64(acc uint64, f func(el interface{}, acc uint64) uint64) uint64 {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// Reduce applies F to acc and every element in slice of T and returns acc
func (s SliceInterface) ReduceInterface(acc interface{}, f func(el interface{}, acc interface{}) interface{}) interface{} {
	for _, el := range s.Data {
		acc = f(el, acc)
	}
	return acc
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInterface) ReduceWhileBool(acc bool, f func(el interface{}, acc bool) (bool, error)) (bool, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInterface) ReduceWhileByte(acc byte, f func(el interface{}, acc byte) (byte, error)) (byte, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInterface) ReduceWhileString(acc string, f func(el interface{}, acc string) (string, error)) (string, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInterface) ReduceWhileFloat32(acc float32, f func(el interface{}, acc float32) (float32, error)) (float32, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInterface) ReduceWhileFloat64(acc float64, f func(el interface{}, acc float64) (float64, error)) (float64, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInterface) ReduceWhileInt(acc int, f func(el interface{}, acc int) (int, error)) (int, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInterface) ReduceWhileInt8(acc int8, f func(el interface{}, acc int8) (int8, error)) (int8, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInterface) ReduceWhileInt16(acc int16, f func(el interface{}, acc int16) (int16, error)) (int16, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInterface) ReduceWhileInt32(acc int32, f func(el interface{}, acc int32) (int32, error)) (int32, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInterface) ReduceWhileInt64(acc int64, f func(el interface{}, acc int64) (int64, error)) (int64, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInterface) ReduceWhileUint(acc uint, f func(el interface{}, acc uint) (uint, error)) (uint, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInterface) ReduceWhileUint8(acc uint8, f func(el interface{}, acc uint8) (uint8, error)) (uint8, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInterface) ReduceWhileUint16(acc uint16, f func(el interface{}, acc uint16) (uint16, error)) (uint16, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInterface) ReduceWhileUint32(acc uint32, f func(el interface{}, acc uint32) (uint32, error)) (uint32, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInterface) ReduceWhileUint64(acc uint64, f func(el interface{}, acc uint64) (uint64, error)) (uint64, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// ReduceWhile is like Reduce, but stops when f returns error
func (s SliceInterface) ReduceWhileInterface(acc interface{}, f func(el interface{}, acc interface{}) (interface{}, error)) (interface{}, error) {
	for _, el := range s.Data {
		acc, err := f(el, acc)
		if err != nil {
			return acc, err
		}
	}
	return acc, nil
}

// Reverse returns given arr in reversed order
func (s SliceInterface) Reverse() []interface{} {
	if len(s.Data) <= 1 {
		return s.Data
	}
	result := make([]interface{}, 0, len(s.Data))
	for i := len(s.Data) - 1; i >= 0; i-- {
		result = append(result, s.Data[i])
	}
	return result
}

// Same returns true if all element in arr the same
func (s SliceInterface) Same() bool {
	if len(s.Data) <= 1 {
		return true
	}
	for i := 0; i < len(s.Data)-1; i++ {
		if s.Data[i] != s.Data[i+1] {
			return false
		}
	}
	return true
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInterface) ScanBool(acc bool, f func(el interface{}, acc bool) bool) []bool {
	result := make([]bool, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInterface) ScanByte(acc byte, f func(el interface{}, acc byte) byte) []byte {
	result := make([]byte, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInterface) ScanString(acc string, f func(el interface{}, acc string) string) []string {
	result := make([]string, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInterface) ScanFloat32(acc float32, f func(el interface{}, acc float32) float32) []float32 {
	result := make([]float32, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInterface) ScanFloat64(acc float64, f func(el interface{}, acc float64) float64) []float64 {
	result := make([]float64, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInterface) ScanInt(acc int, f func(el interface{}, acc int) int) []int {
	result := make([]int, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInterface) ScanInt8(acc int8, f func(el interface{}, acc int8) int8) []int8 {
	result := make([]int8, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInterface) ScanInt16(acc int16, f func(el interface{}, acc int16) int16) []int16 {
	result := make([]int16, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInterface) ScanInt32(acc int32, f func(el interface{}, acc int32) int32) []int32 {
	result := make([]int32, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInterface) ScanInt64(acc int64, f func(el interface{}, acc int64) int64) []int64 {
	result := make([]int64, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInterface) ScanUint(acc uint, f func(el interface{}, acc uint) uint) []uint {
	result := make([]uint, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInterface) ScanUint8(acc uint8, f func(el interface{}, acc uint8) uint8) []uint8 {
	result := make([]uint8, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInterface) ScanUint16(acc uint16, f func(el interface{}, acc uint16) uint16) []uint16 {
	result := make([]uint16, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInterface) ScanUint32(acc uint32, f func(el interface{}, acc uint32) uint32) []uint32 {
	result := make([]uint32, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInterface) ScanUint64(acc uint64, f func(el interface{}, acc uint64) uint64) []uint64 {
	result := make([]uint64, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Scan is like Reduce, but returns slice of f results
func (s SliceInterface) ScanInterface(acc interface{}, f func(el interface{}, acc interface{}) interface{}) []interface{} {
	result := make([]interface{}, 0, len(s.Data))
	for _, el := range s.Data {
		acc = f(el, acc)
		result = append(result, acc)
	}
	return result
}

// Shuffle in random order arr elements
func (s SliceInterface) Shuffle() []interface{} {
	if len(s.Data) <= 1 {
		return s.Data
	}
	rand.Seed(time.Now().UnixNano())
	swap := func(i, j int) {
		s.Data[i], s.Data[j] = s.Data[j], s.Data[i]
	}
	rand.Shuffle(len(s.Data), swap)
	return s.Data
}

// Split splits arr by sep
func (s SliceInterface) Split(sep interface{}) [][]interface{} {
	result := make([][]interface{}, 0)
	curr := make([]interface{}, 0)
	for _, el := range s.Data {
		if el == sep {
			result = append(result, curr)
		} else {
			curr = append(curr, el)
		}
	}
	result = append(result, curr)
	return result
}

// StartsWith returns true if slice starts with the given prefix slice.
// If prefix is empty, it returns true.
func (s SliceInterface) StartsWith(prefix []interface{}) bool {
	if len(prefix) > len(s.Data) {
		return false
	}
	for i, el := range prefix {
		if el != s.Data[i] {
			return false
		}
	}
	return true
}

// TakeEvery returns slice of every nth elements
func (s SliceInterface) TakeEvery(nth int) ([]interface{}, error) {
	if nth <= 0 {
		return s.Data, ErrNonPositiveValue
	}
	result := make([]interface{}, 0, len(s.Data))
	for i, el := range s.Data {
		if (i+1)%nth == 0 {
			result = append(result, el)
		}
	}
	return result, nil
}

// TakeRandom returns slice of count random elements from the slice
func (s SliceInterface) TakeRandom(count int) ([]interface{}, error) {
	if count > len(s.Data) {
		return nil, ErrOutOfRange
	}
	if count <= 0 {
		return nil, ErrNonPositiveValue
	}

	rand.Seed(time.Now().UnixNano())
	swap := func(i, j int) {
		s.Data[i], s.Data[j] = s.Data[j], s.Data[i]
	}
	rand.Shuffle(len(s.Data), swap)
	return s.Data[:count], nil
}

// TakeWhile takes elements from arr while f returns true
func (s SliceInterface) TakeWhile(f func(el interface{}) bool) []interface{} {
	result := make([]interface{}, 0, len(s.Data))
	for _, el := range s.Data {
		if !f(el) {
			return result
		}
		result = append(result, el)
	}
	return result
}

// ToChannel returns channel with elements from the slice
func (s SliceInterface) ToChannel() chan interface{} {
	c := make(chan interface{}, 1)
	go func() {
		for _, el := range s.Data {
			c <- el
		}
		close(c)
	}()
	return c
}

// Uniq returns arr with only first occurences of every element.
func (s SliceInterface) Uniq() []interface{} {
	if len(s.Data) <= 1 {
		return s.Data
	}
	added := make(map[interface{}]struct{})
	nothing := struct{}{}
	result := make([]interface{}, 0, len(s.Data))
	for _, el := range s.Data {
		_, exists := added[el]
		if !exists {
			result = append(result, el)
			added[el] = nothing
		}
	}
	return result

}

// Window makes sliding window for a given slice:
// ({1,2,3}, 2) -> (1,2), (2,3)
func (s SliceInterface) Window(size int) ([][]interface{}, error) {
	if size <= 0 {
		return nil, ErrNonPositiveValue
	}
	result := make([][]interface{}, 0, len(s.Data)/size)
	for i := 0; i <= len(s.Data)-size; i++ {
		chunk := s.Data[i : i+size]
		result = append(result, chunk)
	}
	return result, nil
}

// Without returns the slice with filtered out element
func (s SliceInterface) Without(elements ...interface{}) []interface{} {
	result := make([]interface{}, 0, len(s.Data))
	for _, el := range s.Data {
		allowed := true
		for _, other := range elements {
			if el == other {
				allowed = false
			}
		}
		if allowed {
			result = append(result, el)
		}
	}
	return result
}

// Concat concatenates given slices into a single slice.
func (s SlicesInterface) Concat() []interface{} {
	result := make([]interface{}, 0)
	for _, arr := range s.Data {
		result = append(result, arr...)
	}
	return result
}

// Product returns cortesian product of elements
// {{1, 2}, {3, 4}} -> {1, 3}, {1, 4}, {2, 3}, {2, 4}
func (s SlicesInterface) Product() chan []interface{} {
	c := make(chan []interface{}, 1)
	go s.product(c, []interface{}{}, 0)
	return c
}

// product is a core implementation of Product
func (s SlicesInterface) product(c chan []interface{}, left []interface{}, pos int) {
	// iterate over the last array
	if pos == len(s.Data)-1 {
		for _, el := range s.Data[pos] {
			result := make([]interface{}, 0, len(left)+1)
			result = append(result, left...)
			result = append(result, el)
			c <- result
		}
		return
	}

	for _, el := range s.Data[pos] {
		result := make([]interface{}, 0, len(left)+1)
		result = append(result, left...)
		result = append(result, el)
		s.product(c, result, pos+1)
	}

	if pos == 0 {
		close(c)
	}
}

// Zip returns array of arrays of elements from given arrs
// on the same position
func (s SlicesInterface) Zip() [][]interface{} {
	size := len(s.Data[0])
	for _, arr := range s.Data[1:] {
		if len(arr) > size {
			size = len(arr)
		}
	}

	result := make([][]interface{}, 0, size)
	for i := 0; i <= size; i++ {
		chunk := make([]interface{}, 0, len(s.Data))
		for _, arr := range s.Data {
			chunk = append(chunk, arr[i])
		}
		result = append(result, chunk)
	}
	return result
}
